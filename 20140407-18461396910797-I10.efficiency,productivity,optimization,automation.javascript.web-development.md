Smashing Magazine[![Smashing Magazine](http://coding.smashingmagazine.com/wp-content/themes/smashingv4/images/logo.png "Jump to the front page")](http://www.smashingmagazine.com/)
===================================================================================================================================================================================

[Menu](#mobile-navigation-footer) [Search](#mobile-search-footer)

-   [![Smashing
    Magazine](http://coding.smashingmagazine.com/wp-content/themes/smashingv4/images/logo.png "Jump to the front page")](http://www.smashingmagazine.com/)
-   [Books](http://www.smashingmagazine.com/books/)
-   [Library](http://www.smashingmagazine.com/ebooks/)
-   [Workshops](http://www.smashingmagazine.com/workshops/)
-   [Job Board](http://jobs.smashingmagazine.com/)

-   [RSS](http://rss1.smashingmagazine.com/feed/ "Subscribe to our RSS-feed (1200K)")
-   [Facebook](http://www.facebook.com/smashmag "Join our Facebook page! (190k)")
-   [Twitter](http://twitter.com/smashingmag "Follow us on Twitter! (767k)")
-   [Newsletter](http://www.smashingmagazine.com/the-smashing-newsletter/ "Subscribe to our Email Newsletter (175k)")

Search

-   [Coding](http://coding.smashingmagazine.com)
    -   [CSS](http://coding.smashingmagazine.com/tag/css/)
    -   [HTML](http://coding.smashingmagazine.com/tag/html/)
    -   [JavaScript](http://coding.smashingmagazine.com/tag/javascript/)
    -   [Techniques](http://coding.smashingmagazine.com/tag/techniques/)

-   [Design](http://www.smashingmagazine.com/category/design/)
    -   [Web Design](http://www.smashingmagazine.com/tag/web-design/)
    -   [Typography](http://www.smashingmagazine.com/tag/typography/)
    -   [Inspiration](http://www.smashingmagazine.com/tag/inspiration/)
    -   [Business](http://www.smashingmagazine.com/tag/business/)

-   [Mobile](http://mobile.smashingmagazine.com)
    -   [Responsive](http://mobile.smashingmagazine.com/tag/responsive-design/)
    -   [iPhone & iPad](http://mobile.smashingmagazine.com/tag/ios/)
    -   [Android](http://mobile.smashingmagazine.com/tag/android/)
    -   [Design
        Patterns](http://mobile.smashingmagazine.com/tag/design-patterns/)

-   [Graphics](http://www.smashingmagazine.com/category/graphics/)
    -   [Photoshop](http://www.smashingmagazine.com/tag/photoshop/)
    -   [Fireworks](http://fireworks.smashingmagazine.com)
    -   [Wallpapers](http://www.smashingmagazine.com/tag/wallpapers/)
    -   [Freebies](http://www.smashingmagazine.com/tag/freebies/)

-   [UX Design](http://uxdesign.smashingmagazine.com)
    -   [Usability](http://uxdesign.smashingmagazine.com/tag/usability/)
    -   [User
        Experience](http://uxdesign.smashingmagazine.com/tag/user-experience/)
    -   [UI Design](http://uxdesign.smashingmagazine.com/tag/ui/)
    -   [E-Commerce](http://uxdesign.smashingmagazine.com/tag/e-commerce/)

-   [WPWordPress](http://wp.smashingmagazine.com)
    -   [Essentials](http://wp.smashingmagazine.com/tag/essentials/)
    -   [Techniques](http://wp.smashingmagazine.com/tag/techniques/)
    -   [Plugins](http://wp.smashingmagazine.com/tag/plugins/)
    -   [Themes](http://wp.smashingmagazine.com/tag/themes/)

\

[PerformanceWriting Fast, Memory-Efficient JavaScript](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/ "Read 'Writing Fast, Memory-Efficient JavaScript'")
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-   By [Addy
    Osmani](http://coding.smashingmagazine.com/author/addy-osmani/?rel=author "Posts by Addy Osmani")
-   -   November 5th, 2012
-   [JavaScript](http://coding.smashingmagazine.com/tag/javascript/),
    [Optimization](http://coding.smashingmagazine.com/tag/optimization/),
    [Performance](http://coding.smashingmagazine.com/tag/performance/)
-   [92
    Comments](#comments "Comment on Writing Fast, Memory-Efficient JavaScript")

Advertisement

JavaScript engines such as Google’s [V8](http://code.google.com/p/v8/)
(Chrome, Node) are specifically designed for the [fast
execution](http://www.html5rocks.com/en/tutorials/speed/v8/) of large
JavaScript applications. As you develop, if you care about memory usage
and performance, you should be aware of some of what’s going on in your
user’s browser’s JavaScript engine behind the scenes.

Whether it’s V8,
[SpiderMonkey](https://developer.mozilla.org/en-US/docs/SpiderMonkey)
(Firefox), [Carakan](http://my.opera.com/ODIN/blog/carakan-faq) (Opera),
[Chakra](http://en.wikipedia.org/wiki/Chakra_(JScript_engine)) (IE) or
something else, doing so can help you **better optimize your
applications**. That’s not to say one should optimize for a single
browser or engine. Never do that.

You should, however, ask yourself questions such as:

-   Is there anything I could be doing more efficiently in my code?
-   What (common) optimizations do popular JavaScript engines make?
-   What is the engine unable to optimize for, and is the garbage
    collector able to clean up what I’m expecting it to?

[![Dashboard
Speedometer](http://media.smashingmagazine.com/wp-content/uploads/2012/10/fast_memory.jpg "Dashboard Speedometer")](http://dhybridcars.com/toyota-hybrid/2013-scion-fr-s-sexy-sport-car/media/2013-scion-fr-s-speed-gauge-img-8/)\
 *Fast-loading Web sites — like fast cars — require the use specialized
tools. Image source:
[dHybridcars](http://dhybridcars.com/toyota-hybrid/2013-scion-fr-s-sexy-sport-car/media/2013-scion-fr-s-speed-gauge-img-8/).*

There are many common pitfalls when it comes to writing memory-efficient
and fast code, and in this article we’re going to explore some
test-proven approaches for writing code that performs better.

### So, How Does JavaScript Work In V8?

While it’s possible to develop large-scale applications without a
thorough understanding of JavaScript engines, any car owner will tell
you they’ve looked under the hood at least once. As Chrome is my browser
of choice, I’m going to talk a little about its JavaScript engine. V8 is
made up of a few core pieces.

-   A **base compiler**, which parses your JavaScript and generates
    native machine code before it is executed, rather than executing
    bytecode or simply interpreting it. This code is initially not
    highly optimized.
-   V8 represents your objects in an **object model**. Objects are
    represented as associative arrays in JavaScript, but in V8 they are
    represented with [hidden
    classes](https://developers.google.com/v8/design), which are an
    internal type system for optimized lookups.
-   The **runtime profiler** monitors the system being run and
    identifies “hot” functions (i.e. code that ends up spending a long
    time running).
-   An **optimizing compiler** recompiles and optimizes the “hot” code
    identified by the runtime profiler, and performs optimizations such
    as inlining (i.e. replacing a function call site with the body of
    the callee).
-   V8 supports **deoptimization**, meaning the optimizing compiler can
    bail out of code generated if it discovers that some of the
    assumptions it made about the optimized code were too optimistic.
-   It has a **garbage collector**. Understanding how it works can be
    just as important as the optimized JavaScript.

### Garbage Collection

Garbage collection is **a form of memory management**. It’s where we
have the notion of a collector which attempts to reclaim memory occupied
by objects that are no longer being used. In a garbage-collected
language such as JavaScript, objects that are still referenced by your
application are not cleaned up.

Manually de-referencing objects is not necessary in most cases. By
simply putting the variables where they need to be (ideally, as local as
possible, i.e. inside the function where they are used versus an outer
scope), things should just work.

[![Garbage collection attempts to reclaim
memory.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/robot-cleaner.jpg "Garbage Collection Attempts To Reclaim Memory")](http://www.flickr.com/photos/26817893@N05/2864644153/)\
 *Garbage collection attempts to reclaim memory. Image source: [Valtteri
Mäki](http://www.flickr.com/photos/26817893@N05/2864644153/).*

It’s not possible to force garbage collection in JavaScript. You
wouldn’t want to do this, because the garbage collection process is
controlled by the runtime, and it generally knows best when things
should be cleaned up.

#### De-Referencing Misconceptions

In quite a few discussions online about reclaiming memory in JavaScript,
the `delete` keyword is brought up, as although it was supposed to be
used for just removing keys from a map, some developers think you can
force de-referencing using it. Avoid using `delete` if you can. In the
below example, `delete o.x` does a lot more harm than good behind the
scenes, as it changes `o`‘s hidden class and makes it a generic slow
object.

    var o = { x: 1 }; 
    delete o.x; // true 
    o.x; // undefined

That said, you are almost certain to find references to `delete` in many
popular JavaScript libraries – it does have a purpose in the language.
The main takeaway here is to avoid modifying the structure of hot
objects at runtime. JavaScript engines can detect such “hot” objects and
attempt to optimize them. This is easier if the object’s structure
doesn’t heavily change over its lifetime and `delete` can trigger such
changes.

There are also misconceptions about how `null` works. Setting an object
reference to `null` doesn’t “null” the object. It sets the object
reference to `null`. Using `o.x = null` is better than using `delete`,
but it’s probably not even necessary.

    var o = { x: 1 }; 
    o = null;
    o; // null
    o.x // TypeError

If this reference was the last reference to the object, the object is
then eligible for garbage collection. If the reference was not the last
reference to the object, the object is reachable and will not be garbage
collected.

Another important note to be aware of is that global variables are not
cleaned up by the garbage collector during the life of your page.
Regardless of how long the page is open, variables scoped to the
JavaScript runtime global object will stick around.

    var myGlobalNamespace = {};

Globals are cleaned up when you refresh the page, navigate to a
different page, close tabs or exit your browser. Function-scoped
variables get cleaned up when a variable falls out of scope. When
functions have exited and there aren’t any more references to it, the
variable gets cleaned up.

#### Rules of Thumb

To give the garbage collector a chance to collect as many objects as
possible as early as possible, **don’t hold on to objects you no longer
need**. This mostly happens automatically; here are a few things to keep
in mind.

-   As mentioned earlier, a better alternative to manual de-referencing
    is to use variables with an appropriate scope. I.e. instead of a
    global variable that’s nulled out, just use a function-local
    variable that goes out of scope when it’s no longer needed. This
    means cleaner code with less to worry about.
-   Ensure that you’re unbinding event listeners where they are no
    longer required, especially when the DOM objects they’re bound to
    are about to be removed
-   If you’re using a data cache locally, make sure to clean that cache
    or use an aging mechanism to avoid large chunks of data being stored
    that you’re unlikely to reuse

#### Functions

Next, let’s look at functions. As we’ve already said, garbage collection
works by reclaiming blocks of memory (objects) which are no longer
reachable. To better illustrate this, here are some examples.

    function foo() {
        var bar = new LargeObject();
        bar.someCall();
    }

When `foo` returns, the object which `bar` points to is automatically
available for garbage collection, because there is nothing left that has
a reference to it.

Compare this to:

    function foo() {
        var bar = new LargeObject();
        bar.someCall();
        return bar;
    }

    // somewhere else
    var b = foo();

We now have a reference to the object which survives the call and
persists until the caller assigns something else to `b` (or `b` goes out
of scope).

#### Closures

When you see a function that returns an inner function, that inner
function will have access to the outer scope even after the outer
function is executed. This is basically a
[closure](http://robertnyman.com/2008/10/09/explaining-javascript-scope-and-closures/)
— an expression which can work with variables set within a specific
context. For example:

    function sum (x) {
        function sumIt(y) {
            return x + y;
        };
        return sumIt;
    }

    // Usage
    var sumA = sum(4);
    var sumB = sumA(3);
    console.log(sumB); // Returns 7

The function object created within the execution context of the call to
`sum` can’t be garbage collected, as it’s referenced by a global
variable and is still very much accessible. It can still be executed via
`sumA(n)`.

Let’s look at another example. Here, can we access `largeStr`?

    var a = function () {
        var largeStr = new Array(1000000).join('x');
        return function () {
            return largeStr;
        };
    }();

Yes, we can, via `a()`, so it’s not collected. How about this one?

    var a = function () {
        var smallStr = 'x';
        var largeStr = new Array(1000000).join('x');
        return function (n) {
            return smallStr;
        };
    }();

We can’t access it anymore and it’s a candidate for garbage collection.

#### Timers

One of the worst places to leak is in a loop, or in
`setTimeout()`/`setInterval()`, but this is quite common.

Consider the following example.

    var myObj = {
        callMeMaybe: function () {
            var myRef = this;
            var val = setTimeout(function () { 
                console.log('Time is running out!'); 
                myRef.callMeMaybe();
            }, 1000);
        }
    };

If we then run:

    myObj.callMeMaybe();

to begin the timer, we can see every second “Time is running out!” If we
then run:

    myObj = null;

The timer will still fire. `myObj` won’t be garbage collected as the
closure passed to `setTimeout` has to be kept alive in order to be
executed. In turn, it holds references to `myObj` as it captures
`myRef`. This would be the same if we’d passed the closure to any other
function, keeping references to it.

It is also worth keeping in mind that references inside a
`setTimeout`/`setInterval` call, such as functions, will need to execute
and complete before they can be garbage collected.

### Be Aware Of Performance Traps

It’s important never to optimize code until you actually need to. This
can’t be stressed enough. It’s easy to see a number of micro-benchmarks
showing that N is more optimal than M in V8, but test it in a real
module of code or in an actual application, and **the true impact of
those optimizations may be much more minimal** than you were expecting.

[![Speed
trap.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/speed-trap.jpg "Speed Trap")](http://www.flickr.com/photos/tim_uk/7717078488/sizes/c/in/photostream/)\
 *Doing too much can be as harmful as not doing anything. Image source:
[Tim
Sheerman-Chase](http://www.flickr.com/photos/tim_uk/7717078488/sizes/c/in/photostream/).*

Let’s say we want to create a module which:

-   Takes a local source of data containing items with a numeric ID,
-   Draws a table containing this data,
-   Adds event handlers for toggling a class when a user clicks on any
    cell.

There are a few different factors to this problem, even though it’s
quite straightforward to solve. How do we store the data? How do we
efficiently draw the table and append it to the DOM? How do we handle
events on this table optimally?

A first (naive) take on this problem might be to store each piece of
available data in an object which we group into an array. One might use
jQuery to iterate through the data and draw the table, then append it to
the DOM. Finally, one might use event binding for adding the click
behavior we desire.

**Note: This is NOT what you should be doing**

    var moduleA = function () {

        return {

            data: dataArrayObject,

            init: function () {
                this.addTable();
                this.addEvents();
            },

            addTable: function () {

                for (var i = 0; i < rows; i++) {
                    $tr = $('<tr></tr>');
                    for (var j = 0; j < this.data.length; j++) {
                        $tr.append('<td>' + this.data[j]['id'] + '</td>');
                    }
                    $tr.appendTo($tbody);
                }

            },
            addEvents: function () {
                $('table td').on('click', function () {
                    $(this).toggleClass('active');
                });
            }

        };
    }();

Simple, but it gets the job done.

In this case however, the only data we’re iterating are IDs, a numeric
property which could be more simply represented in a standard array.
Interestingly, directly using `DocumentFragment` and native DOM methods
are more optimal than using jQuery (in this manner) for our table
generation, and of course, event delegation is typically more performant
than binding each `td` individually.

Note that jQuery does use `DocumentFragment` internally behind the
scenes, but in our example, the code is calling `append()` within a loop
and each of these calls has little knowledge of the other so it may not
be able to optimize for this example. This should hopefully not be a
pain point, but be sure to benchmark your own code to be sure.

In our case, adding in these changes results in some good (expected)
performance gains. Event delegation provides decent improvement over
simply binding, and [opting for
`documentFragment`](http://jsperf.com/first-pass) was a real booster.

    var moduleD = function () {

        return {

            data: dataArray,

            init: function () {
                this.addTable();
                this.addEvents();
            },
            addTable: function () {
                var td, tr;
                var frag = document.createDocumentFragment();
                var frag2 = document.createDocumentFragment();

                for (var i = 0; i < rows; i++) {
                    tr = document.createElement('tr');
                    for (var j = 0; j < this.data.length; j++) {
                        td = document.createElement('td');
                        td.appendChild(document.createTextNode(this.data[j]));

                        frag2.appendChild(td);
                    }
                    tr.appendChild(frag2);
                    frag.appendChild(tr);
                }
                tbody.appendChild(frag);
            },
            addEvents: function () {
                $('table').on('click', 'td', function () {
                    $(this).toggleClass('active');
                });
            }

        };

    }();

We might then look to other ways of improving performance. You may have
read somewhere that using the prototypal pattern is more optimal than
the module pattern (we confirmed it wasn’t earlier), or heard that using
JavaScript templating frameworks are highly optimized. Sometimes they
are, but use them because they make for readable code. Also,
precompile!. Let’s test and find out how true this hold in practice.

    moduleG = function () {};

    moduleG.prototype.data = dataArray;
    moduleG.prototype.init = function () {
        this.addTable();
        this.addEvents();
    };
    moduleG.prototype.addTable = function () {
        var template = _.template($('#template').text());
        var html = template({'data' : this.data});
        $tbody.append(html);
    };
    moduleG.prototype.addEvents = function () {
       $('table').on('click', 'td', function () {
           $(this).toggleClass('active');
       });
    };

    var modG = new moduleG();

As it turns out, in this case the performance benefits are negligible.
[Opting for templating and prototypes](http://jsperf.com/second-pass)
didn’t really offer anything more than what we had before. That said,
performance isn’t really the reason modern developers use either of
these things — it’s the readability, inheritance model and
maintainability they bring to your codebase.

More complex problems include [efficiently drawing images using
canvas](http://jsperf.com/canvas-drawimage-vs-webgl-drawarrays/6) and
[manipulating pixel
data](http://jsperf.com/canvas-pixel-manipulation/30) with or without
[typed arrays](http://jsperf.com/typed-arrays-for-pixel-manipulation)

Always give micro-benchmarks a close lookover before exploring their use
in your application. Some of you may recall the [JavaScript templating
shoot-off](http://jsperf.com/dom-vs-innerhtml-based-templating/473) and
the [extended shoot-off that
followed](http://jsperf.com/javascript-templating-shootoff-extended/26).
You want to make sure that tests aren’t being impacted by constraints
you’re unlikely to see in real world applications — test optimizations
together in actual code.

### V8 Optimization Tips

Whilst detailing every V8 optimization is outside the scope of this
article, there are certainly many tips worth noting. Keep these in mind
and you’ll reduce your chances of writing unperformant code.

-   Certain patterns will cause V8 to bail out of optimizations. A
    try-catch, for example, will cause such a bailout. For more
    information on what functions can and can’t be optimized, you can
    use `--trace-opt file.js` with the d8 shell utility that comes with
    V8.
-   If you care about speed, try very hard to keep your functions
    monomorphic, i.e. make sure that variables (including properties,
    arrays and function parameters) only ever contain objects with the
    same hidden class. For example, don’t do this:

<!-- -->

    function add(x, y) { 
       return x+y;
    } 

    add(1, 2); 
    add('a','b'); 
    add(my_custom_object, undefined);

-   Don’t load from uninitialized or deleted elements. This won’t make a
    difference in output, but it will make things slower.
-   Don’t write enormous functions, as they are more difficult to
    optimize

For more tips, watch Daniel Clifford’s Google I/O talk [Breaking the
JavaScript Speed Limit with
V8](http://www.youtube.com/watch?v=UJPdhx5zTaw) as it covers these
topics well. [Optimizing For V8 — A
Series](http://floitsch.blogspot.co.uk/2012/03/optimizing-for-v8-introduction.html)
is also worth a read.

#### Objects Vs. Arrays: Which Should I Use?

-   If you want to store a bunch of numbers, or a list of objects of the
    same type, use an array.
-   If what you semantically need is an object with a bunch of
    properties (of varying types), use an object with properties. That’s
    pretty efficient in terms of memory, and it’s also pretty fast.
-   Integer-indexed elements, regardless of whether they’re stored in an
    array or an object, are [much faster to iterate over than object
    properties](http://jsperf.com/performance-of-array-vs-object/3).
-   Properties on objects are quite complex: they can be created with
    setters, and with differing enumerability and writability. Items in
    arrays aren’t able to be customized as heavily — they either exist
    or they don’t. At an engine level, this allows for more optimization
    in terms of organizing the memory representing the structure. This
    is particularly beneficial when the array contains numbers. For
    example, when you need vectors, don’t define a class with properties
    x, y, z; use an array instead..

There’s really only one major difference between objects and arrays in
JavaScript, and that’s the arrays’ magic `length` property. If you’re
keeping track of this property yourself, objects in V8 should be just as
fast as arrays.

#### Tips When Using Objects

-   Create objects using a constructor function. This ensures that all
    objects created with it have the same hidden class and helps avoid
    changing these classes. As an added benefit, it’s also [slightly
    faster than
    `Object.create()`](http://jsperf.com/object-create-vs-constructor-vs-object-literal/7)
-   There are no restrictions on the number of different object types
    you can use in your application or on their complexity (within
    reason: long prototype chains tend to hurt, and objects with only a
    handful of properties get a special representation that’s a bit
    faster than bigger objects). For “hot” objects, try to keep the
    prototype chains short and the field count low.

**Object Cloning**\
 Object cloning is a common problem for app developers. While it’s
possible to benchmark how well various implementations work with this
type of problem in V8, be very careful when copying anything. Copying
big things is generally slow — don’t do it. `for..in` loops in
JavaScript are particularly bad for this, as they have a devilish
specification and will likely never be fast in any engine for arbitrary
objects.

When you absolutely do need to copy objects in a performance-critical
code path (and you can’t get out of this situation), use an array or a
custom “copy constructor” function which copies each property
explicitly. This is probably the fastest way to do it:

    function clone(original) {
      this.foo = original.foo;
      this.bar = original.bar;
    }
    var copy = new clone(original);

**Cached Functions in the Module Pattern**\
 Caching your functions when using the module pattern can lead to
performance improvements. See below for an example where the variation
you’re probably used to seeing is slower as it forces new copies of the
member functions to be created all the time.

![Performance
improvements](http://media.smashingmagazine.com/wp-content/uploads/2012/11/Screen-Shot-2012-11-06-at-10.42.10.png "Performance Improvements When Using The Module And Prototypal Patterns")\
 *Performance improvements when using the module or prototypal
patterns.*

Here is a [test of prototype versus module pattern
performance](http://jsperf.com/prototypal-performance/12)

    // Prototypal pattern
      Klass1 = function () {}
      Klass1.prototype.foo = function () {
          log('foo');
      }
      Klass1.prototype.bar = function () {
          log('bar');
      }

      // Module pattern
      Klass2 = function () {
          var foo = function () {
              log('foo');
          },
          bar = function () {
              log('bar');
          };

          return {
              foo: foo,
              bar: bar
          }
      }


      // Module pattern with cached functions
      var FooFunction = function () {
          log('foo');
      };
      var BarFunction = function () {
          log('bar');
      };

      Klass3 = function () {
          return {
              foo: FooFunction,
              bar: BarFunction
          }
      }


      // Iteration tests

      // Prototypal
      var i = 1000,
          objs = [];
      while (i--) {
          var o = new Klass1()
          objs.push(new Klass1());
          o.bar;
          o.foo;
      }

      // Module pattern
      var i = 1000,
          objs = [];
      while (i--) {
          var o = Klass2()
          objs.push(Klass2());
          o.bar;
          o.foo;
      }

      // Module pattern with cached functions
      var i = 1000,
          objs = [];
      while (i--) {
          var o = Klass3()
          objs.push(Klass3());
          o.bar;
          o.foo;
      }
    // See the test for full details

**Note:** If you don’t require a class, avoid the trouble of creating
one. Here’s an example of how to gain performance boosts by remoxing the
class overhead altogether
[http://jsperf.com/prototypal-performance/54](http://jsperf.com/prototypal-performance/54).

#### Tips When Using Arrays

Next let’s look at a few tips for arrays. In general, **don’t delete
array elements**. It would make the array transition to a slower
internal representation. When the key set becomes sparse, V8 will
eventually switch elements to dictionary mode, which is even slower.

**Array Literals**\
 Array literals are useful because they give a hint to the VM about the
size and type of the array. They’re typically good for small to medium
sized arrays.

    // Here V8 can see that you want a 4-element array containing numbers:
    var a = [1, 2, 3, 4];

    // Don't do this:
    a = []; // Here V8 knows nothing about the array
    for(var i = 1; i <= 4; i++) {
         a.push(i);
    }

**Storage of Single Types Vs. Mixed Types**\
 It’s never a good idea to mix values of different types (e.g. numbers,
strings, undefined or true/false) in the same array (i.e.
`var arr = [1, “1”, undefined, true, “true”]`)

[Test of type inference
performance](http://jsperf.com/type-inference-performance/2)

As we can see from the results, the array of `ints` is the fastest.

**Sparse Arrays vs. Full Arrays**\
 When you use sparse arrays, be aware that accessing elements in them is
much slower than in full arrays. That’s because V8 doesn’t allocate a
flat backing store for the elements if only a few of them are used.
Instead, it manages them in a dictionary, which saves space, but costs
time on access.

[Test of sparse arrays versus full
arrays](http://jsperf.com/sparse-arrays-vs-full-arrays).

The full array `sum` and `sum` of all elements on an array without zeros
were actually the fastest. Whether the full array contains zeroes or not
should not make a difference.

**Packed Vs. Holey Arrays**\
 Avoid “holes” in an array (created by deleting elements or `a[x] = foo`
with `x > a.length`). Even if only a single element is deleted from an
otherwise “full” array, things will be much slower.

[Test of packed versus holey
arrays](http://jsperf.com/packed-vs-holey-arrays).

**Pre-allocating Arrays Vs. Growing As You Go**\
 Don’t pre-allocate large arrays (i.e. greater than 64K elements) to
their maximum size, instead grow as you go. Before we get to the
performance tests for this tip, keep in mind that this is specific to
only some JavaScript engines.

![Test of empty literal versus pre-allocated arrays in various
browsers.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/graph2.jpg "Empty Literal VS. Pre-Allocated Array In Various Browsers")\
 *Test of empty literal versus pre-allocated array in various browsers.*

Nitro (Safari) actually treats pre-allocated arrays more favorably.
However, in other engines (V8, SpiderMonkey), not pre-allocating is more
efficient.

[Test of pre-allocated arrays](http://jsperf.com/pre-allocated-arrays).

    // Empty array
    var arr = [];
    for (var i = 0; i < 1000000; i++) {
        arr[i] = i;
    }

    // Pre-allocated array
    var arr = new Array(1000000);
    for (var i = 0; i < 1000000; i++) {
        arr[i] = i;
    }

### Optimizing Your Application

In the world of Web applications, **speed is everything**. No user wants
a spreadsheet application to take seconds to sum up an entire column or
a summary of their messages to take a minute before it’s ready. This is
why squeezing every drop of extra performance you can out of code can
sometimes be critical.

[![An old phone on the screen of an
iPad.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/improving-apps.jpg "Old Phone On iPad Screen")](http://www.flickr.com/photos/perolofforsberg/6691744587/in/photostream/)\
 *Image source: [Per Olof
Forsberg](http://www.flickr.com/photos/perolofforsberg/6691744587/in/photostream/).*

While understanding and improving your application performance is
useful, it can also be difficult. We recommend the following steps to
fix performance pain points:

-   Measure it: Find the slow spots in your application (\~45%)
-   Understand it: Find out what the actual problem is (\~45%)
-   Fix it! (\~10%)

Some of the tools and techniques recommended below can assist with this
process.

#### Benchmarking

There are many ways to run benchmarks on JavaScript snippets to test
their performance — the general assumption being that benchmarking is
simply comparing two timestamps. One such pattern was pointed out by the
[jsPerf](http://jsperf.com) team, and happens to be used in
[SunSpider](http://www.webkit.org/perf/sunspider/sunspider.html)‘s and
[Kraken](http://krakenbenchmark.mozilla.org/)‘s benchmark suites:

    var totalTime,
        start = new Date,
        iterations = 1000;
    while (iterations--) {
      // Code snippet goes here
    }
    // totalTime → the number of milliseconds taken 
    // to execute the code snippet 1000 times
    totalTime = new Date - start;

Here, the code to be tested is placed within a loop and run a set number
of times (e.g. six). After this, the start date is subtracted from the
end date to find the time taken to perform the operations in the loop.

However, this oversimplifies how benchmarking should be done, especially
if you want to run the benchmarks in multiple browsers and environments.
Garbage collection itself can have an impact on your results. Even if
you’re using a solution like `window.performance`, you still have to
account for these pitfalls.

Regardless of whether you are simply running benchmarks against parts of
your code, writing a test suite or coding a benchmarking library,
there’s a lot more to JavaScript benchmarking than you might think. For
a more detailed guide to benchmarking, I highly recommend reading
[JavaScript
Benchmarking](http://mathiasbynens.be/notes/javascript-benchmarking) by
Mathias Bynens and John-David Dalton.

#### Profiling

The Chrome Developer Tools have good support for [JavaScript
profiling](https://developers.google.com/chrome-developer-tools/docs/profiles).
You can use this feature to detect what functions are eating up the most
of your time so that you can then go optimize them. This is important,
as even small changes to your codebase can have serious impacts on your
overall performance.

![Profiles panel in Chrome Developer
Tools.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/profiling.jpg "Profiles Panel In Chrome Developer Tools")\
 *Profiles Panel in Chrome Developer Tools.*

Profiling starts with obtaining a baseline for your code’s current
performance, which can be discovered using the Timeline. This will tell
us how long our code took to run. The Profiles tab then gives us a
better view into what’s happening in our application. The JavaScript CPU
profile shows us how much CPU time is being used by our code, the CSS
selector profile shows us how much time is spent processing selectors
and Heap snapshots show how much memory is being used by our objects.

Using these tools, we can isolate, tweak and reprofile to gauge whether
changes we’re making to specific functions or operations are improving
performance.

![The profile tab gives information about your code's
performance.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/profiling2.jpg "The Profile Tab Gives Information About Your Code's Performance")\
 *The Profile tab gives you information about your code’s performance.*

For a good introduction to profiling, read [JavaScript Profiling With
The Chrome Developer
Tools](http://coding.smashingmagazine.com/2012/06/12/javascript-profiling-chrome-developer-tools/),
by Zack Grossbart.

Tip: Ideally, you want to ensure that your profiling isn’t being
affected by extensions or applications you’ve installed, so run Chrome
using the `--user-data-dir <empty_directory>` flag. Most of the time,
this approach to optimization testing should be enough, but there are
times when you need more. This is where V8 flags can be of help.

#### Avoiding Memory Leaks — Three Snapshot Techniques for Discovery

Internally at Google, the Chrome Developer Tools are heavily used by
teams such as Gmail to help us discover and squash memory leaks.

![Memory statistics in Chrome Developer
Tools.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/devtools.jpg "Memory Statistics In Chrome Developer Tools")\
 *Memory statistics in Chrome Developer Tools.*

Some of the memory statistics that our teams care about include private
memory usage, JavaScript heap size, DOM node counts, storage clearing,
event listener counts and what’s going on with garbage collection. For
those familiar with event-driven architectures, you might be interested
to know that one of the most common issues we used to have were
`listen()`’s without `unlisten()`’s (Closure) and missing `dispose()`’s
for objects that create event listeners.

Luckily the DevTools can help locate some of these issues, and Loreena
Lee has a fantastic presentation available documenting the [“3 snapshot”
technique](https://docs.google.com/presentation/d/1wUVmf78gG-ra5aOxvTfYdiLkdGaR9OhXRnOlIcEmu2s/pub?start=false&loop=false&delayms=3000#slide=id.g1d65bdf6_0_0)
for finding leaks within the DevTools that I can’t recommend reading
through enough.

The gist of the technique is that you record a number of actions in your
application, force a garbage collection, check if the number of DOM
nodes doesn’t return to your expected baseline and then analyze three
heap snapshots to determine if you have a leak.

#### Memory Management in Single-Page Applications

Memory management is quite important when writing modern single-page
applications (e.g. AngularJS, Backbone, Ember) as they almost never get
refreshed. This means that memory leaks can become apparent quite
quickly. This is a huge trap on mobile single-page applications, because
of limited memory, and on long-running applications like email clients
or social networking applications. **With great power comes great
responsibility.**

There are various ways to prevent this. In Backbone, ensure you always
dispose old views and references using `dispose()` (currently available
in [Backbone
(edge)](https://github.com/documentcloud/backbone/blob/master/backbone.js#L1234)).
This function was recently added, and removes any handlers added in the
view’s ‘events’ object, as well as any collection or model listeners
where the view is passed as the third argument (callback context).
`dispose()` is also called by the view’s `remove()`, taking care of the
majority of basic memory cleanup needs when the element is [cleared from
the
screen](https://github.com/documentcloud/backbone/blob/master/backbone.js#L1235).
Other libraries like Ember [clean up
observers](https://github.com/emberjs/ember.js/blob/d8f76a7fdde741ae3d1e07b12df9cb6718170e48/packages/ember-handlebars/lib/helpers/binding.js#L296)
when they detect that elements have been removed from view to avoid
memory leaks.

Some sage advice from Derick Bailey:

> “Other than being aware of how events work in terms of references,
> just follow the standard rules for manage memory in JavaScript and
> you’ll be fine. If you are loading data in to a Backbone collection
> full of User objects you want that collection to be cleaned up so it’s
> not using anymore memory, you must remove all references to the
> collection and the individual objects in it. Once you remove all
> references, things will be cleaned up. This is just the standard
> JavaScript garbage collection rule.”

In his article, Derick covers many of the common [memory
pitfalls](http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/)
when working with Backbone.js and how to fix them.

There is also a helpful tutorial available for [debugging memory leaks
in Node](https://github.com/felixge/node-memory-leak-tutorial) by Felix
Geisendörfer worth reading, especially if it forms a part of your
broader SPA stack.

#### Minimizing Reflows

When a browser has to recalculate the positions and geometrics of
elements in a document for the purpose of re-rendering it, we call this
[reflow](https://www.youtube.com/watch?feature=player_embedded&v=ZHxbs5WEQzE).
Reflow is a user-blocking operation in the browser, so it’s helpful to
understand how to improve reflow time.

![Chart of reflow
time.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/reflow.jpg "Chart Of Reflow Time")\
 *Chart of reflow time.*

You should batch methods that [trigger
reflow](http://stackoverflow.com/questions/510213/when-does-reflow-happen-in-a-dom-environment)
or that repaint, and use them sparingly. It’s important to process off
DOM where possible. This is possible using
[DocumentFragment](http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-B63ED1A3),
a lightweight document object. Think of it as a way to extract a portion
of a document’s tree, or create a new “fragment” of a document. Rather
than constantly adding to the DOM using nodes, we can use document
fragments to build up all we need and only perform a single insert into
the DOM to avoid excessive reflow.

For example, let’s write a function that adds 20 `div`s to an element.
Simply appending each new `div` directly to the element could trigger 20
reflows.

    function addDivs(element) {
      var div;
      for (var i = 0; i < 20; i ++) {
        div = document.createElement('div');
        div.innerHTML = 'Heya!';
        element.appendChild(div);
      }
    }

To work around this issue, we can use `DocumentFragment`, and instead,
append each of our new `div`s to this. When appending to the
`DocumentFragment` with a method like `appendChild`, all of the
fragment’s children are appended to the element triggering only one
reflow.

    function addDivs(element) {
      var div; 
      // Creates a new empty DocumentFragment.
      var fragment = document.createDocumentFragment();
      for (var i = 0; i < 20; i ++) {
        div = document.createElement('a');
        div.innerHTML = 'Heya!';
        fragment.appendChild(div);
      }
      element.appendChild(fragment);
    }

You can read more about this topic at [Make the Web
Faster](https://developers.google.com/speed/articles/javascript-dom),\
 [JavaScript Memory
Optimization](http://blog.tojicode.com/2012/03/javascript-memory-optimization-and.html)
and [Finding Memory
Leaks](http://gent.ilcore.com/2011/08/finding-memory-leaks.html).

#### JavaScript Memory Leak Detector

To help discover JavaScript memory leaks, two of my fellow Googlers
(Marja Hölttä and Jochen Eisinger) developed a tool that works with the
Chrome Developer Tools (specifically, the remote inspection protocol),
and retrieves heap snapshots and detects what objects are causing leaks.

![A tool for detecting JavaScript memory
leaks.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/leak.jpg "A Tool For Detecting JavaScript Memory Leaks")\
 *A tool for detecting JavaScript memory leaks.*

There’s a whole post on [how to use the
tool](http://google-opensource.blogspot.de/2012/08/leak-finder-new-tool-for-javascript.html),
and I encourage you to check it out or view the [Leak Finder project
page](http://code.google.com/p/leak-finder-for-javascript/).

Some more information: In case you’re wondering why a tool like this
isn’t already integrated with our Developer Tools, the reason is
twofold. It was originally developed to help us catch some specific
memory scenarios in the Closure Library, and it makes more sense as an
external tool (or maybe even an extension if we get a heap profiling
extension API in place).

#### V8 Flags for Debugging Optimizations & Garbage Collection

Chrome supports passing a number of flags directly to V8 via the
`js-flags` flag to get more detailed output about what the engine is
optimizing. For example, this traces V8 optimizations:

    "/Applications/Google Chrome/Google Chrome" --js-flags="--trace-opt --trace-deopt"

Windows users will want to run
`chrome.exe --js-flags="--trace-opt --trace-deopt"`

When developing your application, the following V8 flags can be used.

-   `trace-opt` – log names of optimized functions and show where the
    optimizer is skipping code because it can’t figure something out.
-   `trace-deopt` – log a list of code it had to deoptimize while
    running.
-   `trace-gc` – logs a tracing line on each garbage collection.

V8’s tick-processing scripts mark optimized functions with an `*`
(asterisk) and non-optimized functions with `~` (tilde).

If you’re interested in learning more about V8′s flags and how V8′s
internals work in general, I strongly recommend looking through
Vyacheslav Egorov’s [excellent post on V8
internals](http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html),
which summarizes the best resources available on this at the moment.

#### High-Resolution Time and Navigation Timing API

[High Resolution Time](http://www.w3.org/TR/hr-time/) (HRT) is a
JavaScript interface providing the current time in sub-millisecond
resolution that isn’t subject to system clock skews or user adjustments.
Think of it as a way to measure more precisely than we’ve previously had
with `new Date` and `Date.now()`. This is helpful when we’re writing
performance benchmarks.

![High Resolution Time (HRT) provides the current time in
sub-millisecond
resolution.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/perfnow.jpg "High Resolution Time (HRT) Provides The Current Time In Sub-Millisecond Resolution")\
 *High Resolution Time (HRT) provides the current time in
sub-millisecond resolution.*

HRT is currently available in Chrome (stable) as
`window.performance.webkitNow()`, but the prefix is dropped in Chrome
Canary, making it available via `window.performance.now()`. Paul Irish
has written [more about
HRT](http://updates.html5rocks.com/2012/08/When-milliseconds-are-not-enough-performance-now)
in a post on HTML5Rocks.

So, we now know the current time, but what if we wanted an API for
accurately measuring performance on the web?

Well, one is now also available in the [Navigation Timing
API](http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/NavigationTiming/Overview.html).
This API provides a simple way to get accurate and detailed time
measurements that are recorded while a webpage is loaded and presented
to the user. Timing information is exposed via
`window.performance.timing`, which you can simply use in the console:

![Timing information is shown in the
console.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/performance.jpg "Timing Information Is Shown In The Console")\
 *Timing information is shown in the console.*

Looking at the data above, we can extract some very useful information.
For example, network latency is `responseEnd-fetchStart`, the time taken
for a page load once it’s been received from the server is
`loadEventEnd-responseEnd` and the time taken to process between
navigation and page load is `loadEventEnd-navigationStart`.

As you can see above, a `perfomance.memory` property is also available
that gives access to JavaScript memory usage data such as the total heap
size.

For more details on the Navigation Timing API, read Sam Dutton’s great
article [Measuring Page Load Speed With Navigation
Timing](http://www.html5rocks.com/en/tutorials/webperformance/basics/).

#### about:memory and about:tracing

`about:tracing` in Chrome offers an intimate view of the browser’s
performance, recording all of Chrome’s activities across every thread,
tab and process.

![about:tracing offers an intimate view of the browser’s
performance.](http://media.smashingmagazine.com/wp-content/uploads/2012/10/tracing.jpg "About:Tracing Offers An Intimate View Of The Browser’s Performance")\
 *`About:Tracing` offers an intimate view of the browser’s performance.*

What’s really useful about this tool is that it allows you to capture
profiling data about what Chrome is doing under the hood, so you can
properly adjust your JavaScript execution, or optimize your asset
loading.

Lilli Thompson has an excellent [write-up for games
developers](http://www.html5rocks.com/en/tutorials/games/abouttracing/)
on using `about:tracing` to profile WebGL games. The write-up is also
useful for general JavaScripters.

Navigating to `about:memory` in Chrome is also useful as it shows the
exact amount of memory being used by each tab, which is helpful for
tracking down potential leaks.

### Conclusion

As we’ve seen, **there are many hidden performance gotchas in the world
of JavaScript engines**, and no silver bullet available to improve
performance. It’s only when you combine a number of optimizations in a
(real-world) testing environment that you can realize the largest
performance gains. But even then, understanding how engines interpret
and optimize your code can give you insights to help tweak your
applications.

**Measure It. Understand it. Fix it.** Rinse and repeat.

[![Measuring.](http://media.smashingmagazine.com/wp-content/uploads/2012/11/barometer.jpg "Measuring")](http://www.flickr.com/photos/38891164@N02/4266609887/)\
 *Image source: [Sally
Hunter](http://www.flickr.com/photos/38891164@N02/4266609887/).*

Remember to care about optimization, but stop short of opting for
micro-optimization at the cost of convenience. For example, some
developers opt for `.forEach` and `Object.keys` over `for` and `for in`
loops, even though they’re slower, for the convenience of being able to
scope. Do make sanity calls on what optimizations your application
absolutely needs and which ones it could live without.

Also, be aware that although JavaScript engines continue to get faster,
the next real bottleneck is the DOM. Reflows and repaints are just as
important to minimize, so remember to only touch the DOM if it’s
absolutely required. And do care about networking. HTTP requests are
precious, especially on mobile, and you should be using HTTP caching to
reduce the size of assets.

Keeping all of these in mind will ensure that you get the most out of
the information from this post. I hope you found it helpful!

#### Credits

This article was reviewed by Jakob Kummerow, Michael Starzinger, Sindre
Sorhus, Mathias Bynens, John-David Dalton and Paul Irish.

*[Image source](http://www.flickr.com/photos/26817893@N05/2864644153/)
of picture on front page.*

*(cp) (jc)*

**Tags:**[JavaScript](http://coding.smashingmagazine.com/tag/javascript/ "View all articles tagged 'JavaScript' (82)")[Optimization](http://coding.smashingmagazine.com/tag/optimization/ "View all articles tagged 'Optimization' (8)")[Performance](http://coding.smashingmagazine.com/tag/performance/ "View all articles tagged 'Performance' (10)")

[↑ Back to top](#top "Jump to the top of the page")[Share on
Twitter](https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fcoding.smashingmagazine.com%2F2012%2F11%2F05%2Fwriting-fast-memory-efficient-javascript%2F&source=tweetbutton&text=Writing%20Fast%2C%20Memory-Efficient%20JavaScript&url=http%3A%2F%2Fcoding.smashingmagazine.com%2F2012%2F11%2F05%2Fwriting-fast-memory-efficient-javascript%2F&via=smashingmag "Share on Twitter!")

![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=78&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D78&r=G)

[Addy
Osmani](http://coding.smashingmagazine.com/author/addy-osmani/?rel=author "Posts by Addy Osmani")

Addy Osmani is a Developer Programs Engineer on the Chrome team at
Google. A passionate JavaScript developer, he has written open-source
books like 'Learning JavaScript Design Patterns' and 'Developing
Backbone Applications', having also contributed to open-source projects
like Modernizr and jQuery. He is currently working on 'Yeoman' - an
opinionated workflow for building beautiful applications.

Related Articles
----------------

[![Why Coding Style
Matters](http://provide.smashingmagazine.com/related-posts/related-posts-coding-style.jpg)](http://coding.smashingmagazine.com/2012/10/25/why-coding-style-matters/)

### [Why Coding Style Matters](http://coding.smashingmagazine.com/2012/10/25/why-coding-style-matters/)

[![Designing Better JavaScript
APIs](http://provide.smashingmagazine.com/related-posts/related-posts-javaScript-api.jpg)](http://coding.smashingmagazine.com/2012/10/09/designing-javascript-apis-usability/)

### [Designing Better JavaScript APIs](http://coding.smashingmagazine.com/2012/10/09/designing-javascript-apis-usability/)

[![Useful JavaScript Libraries and jQuery
Plugins](http://provide.smashingmagazine.com/related-posts/related-posts-javaScript-jquery.jpg)](http://coding.smashingmagazine.com/2012/09/23/useful-javascript-libraries-jquery-plugins-web-developers/)

### [Useful JavaScript Libraries and jQuery Plugins](http://coding.smashingmagazine.com/2012/09/23/useful-javascript-libraries-jquery-plugins-web-developers/)

Advertising

-   [92 Comments](#show-comments)
-   [Best Comments](#best-comments)

1.  1

    ![image](http://0.gravatar.com/avatar/e27a75707d71787702edaf968fe40c60?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Jeroen Oliemans

    [November 5th, 2012 7:51
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620787 "Commentlink #1")

    Excellent article! Will become very handy when I’am playing with
    box2dweb and other cool processor intensive stuff. I also wasn’t
    aware of the “DocumentFragment” option in the DOM. Very handy!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620787#respond)

    +3

    -   2

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 5th, 2012 8:30
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620794 "Commentlink #2")

        You’re very welcome. If you’re interested in learning more about
        DocumentFragment, you might like to read:

        \*
        [https://developers.google.com/speed/articles/javascript-dom](https://developers.google.com/speed/articles/javascript-dom)\
         \*
        [http://www.nczonline.net/blog/2009/02/03/speed-up-your-javascript-part-4/](http://www.nczonline.net/blog/2009/02/03/speed-up-your-javascript-part-4/)

        Zakas in particular has some great (older) talks that discuss
        the performance benefits of using it.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620794#respond)

        +10

2.  3

    ![image](http://1.gravatar.com/avatar/5c8e523e613b720fec1291442702a708?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Andrew Meredith

    [November 5th, 2012 8:02
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620789 "Commentlink #3")

    Great article! As a web developer who is just now getting into the
    front-end and trying to learn JavaScript, this is very helpful.
    There are so many JavaScript resources out there (I guess that’s an
    advantage of being the most popular programming language in the
    world), but there are not many that focus on performance, especially
    to this level of depth. Thanks again!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620789#respond)

    +1

3.  4

    ![image](http://1.gravatar.com/avatar/59961b48d5e7c04d5ab167d9fe7a4bcd?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Val

    [November 5th, 2012 8:08
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620790 "Commentlink #4")

    Really useful article, thanks.

    Abou variables scope, is the second example with largeStr a safe
    garbage collection?\
     How does the compiler knows that largeStr won’t actually be used?\
     What if, for instance, the inner function was using eval to
    calculate the variable name?

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620790#respond)

    +2

    -   5

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 5th, 2012 8:39
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620797 "Commentlink #5")

        \>What if, for instance, the inner function was using eval to
        calculate the variable name?

        Do you have a code example of what you had in mind?

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620797#respond)

        +3

        -   6

            ![image](http://1.gravatar.com/avatar/fda6f53b0ce7c086978f9840aa4c7715?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

            ### Wyatt

            [November 5th, 2012 11:30
            pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620853 "Commentlink #6")

            Hey Addy,

            Modifying the code to the following makes the necessity of
            the variables ambiguous:

            var a = function () {\
             var smallStr = ‘x’,\
             largeStr = new Array(10).join(‘x’);\
             return function (n) {\
             return eval(n+”Str”)\
             };\
             }();

            Though in this case, v8 barely attempts any optimization due
            specifically to the presence of eval. So to answer Val’s
            question, it is safe because V8 knows it is safe… and if it
            can’t know it doesn’t bother.

            [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620853#respond)

            +1

            -   7

                ![image](http://1.gravatar.com/avatar/59961b48d5e7c04d5ab167d9fe7a4bcd?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

                ### Val

                [November 6th, 2012 2:06
                am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620868 "Commentlink #7")

                Yep, that’s what I was talking about.\
                 I guess there’s an useful lesson here: eval breaks
                engine optimisations for the scope where it’s used.

                [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620868#respond)

                +1

4.  8

    ![image](http://1.gravatar.com/avatar/3389aa5ee38d92f1bdc38131de4bfe75?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Eric Rowell

    [November 5th, 2012 8:22
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620793 "Commentlink #8")

    Wow, it’s nice to see thorough articles like this every now and
    then. Great job!

    One question though, you mentioned that having something like the
    memory leak finder would be a better fit as an external tool, rather
    than being built into Chrome – Why is that? I think it would make an
    excellent addition to the existing tools.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620793#respond)

    +1

    -   9

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 5th, 2012 1:23
        pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620818 "Commentlink #9")

        So, the reason this isn’t a part of the DevTools is two fold. It
        was originally developed to help catch some specific memory
        scenarios in the Closure Library and it makes more sense as an
        external tool as it’s broader usefulness is still being
        evaluated. If there were more developers using the tool, the
        case for it being in there natively would certainly be stronger
        I imagine :)

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620818#respond)

        +1

5.  10

    ![image](http://1.gravatar.com/avatar/195f2398988daa8d20d2c820862be08a?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Roy Bakker

    [November 5th, 2012 8:34
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620795 "Commentlink #10")

    Extremely useful article, only briefly read it just now but i’ll
    definitely read it in full later!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620795#respond)

    +2

6.  11

    ![image](http://0.gravatar.com/avatar/490247488b9fe27f71f2369c3397d3cd?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Neeraj Aggarwal

    [November 5th, 2012 9:24
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620801 "Commentlink #11")

    This is very informative about the JavaScript. Being a front end
    developer, I always try to know how to optimize the performance of
    the JavaScript. This article really points out small tips about the
    JavaScript performance.

    Thanks Addy.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620801#respond)

    +1

7.  12

    ![image](http://1.gravatar.com/avatar/5819f8e8addb33ebd840ffc630af6643?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Adam

    [November 5th, 2012 9:27
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620802 "Commentlink #12")

    Addy…great article! Thanks very much for sharing it with us!

    I had a question – I am returning a bunch of JSON objects from the
    server which are then stored in an array memory and used like a
    local cache.

    I run these objects through a helper function to make sure they all
    have the same keys (some of them are missing a few keys for whatever
    reason) – should I be creating new objects so they’ll all have the
    same hidden class in V8? Or does it really matter?

    The objects all have identical keys and the values are all fairly
    simple – ints, booleans, strings and, in one or 2 cases, arrays –
    but no methods.

    Thanks again!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620802#respond)

    +1

    -   13

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 6th, 2012 3:29
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620881 "Commentlink #13")

        \>I run these objects through a helper function to make sure
        they all have the same keys (some of them are missing a few keys
        for whatever reason) – should I be creating new objects so
        they’ll all have the same hidden class in V8? Or does it really
        matter?

        I’m not entirely sure what your helper function is outputting,
        but I would avoid the overhead of creating new object instances
        just for the sake of it. I’m sure someone will correct me if I’m
        wrong, but V8 should be able to optimize your current setup fine
        as long as you’re not unnecessarily modifying the structure of
        your local array cache.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620881#respond)

        -   14

            ![image](http://1.gravatar.com/avatar/fda6f53b0ce7c086978f9840aa4c7715?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

            ### Wyatt

            [November 6th, 2012 10:11
            am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620917 "Commentlink #14")

            I’d say it would depend on what Adam is doing with the
            objects that get returned from the helper function. But
            returning objects of different shapes will deopt any
            previous inline caching of the function and if he has some
            code where the missing key is accessed and operated on(ie
            Obj1[sometimesMissing] /\*number\*/ + Obj2[sometimesMissing]
            /\* undefined\*/) this will cause v8 to have to use the
            slower interpreter rather than the JIT compiler.

            [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620917#respond)

8.  15

    ![image](http://1.gravatar.com/avatar/f113893fa3966c310b78b0b1fe7a1db1?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Tarun Elankath

    [November 5th, 2012 10:14
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620804 "Commentlink #15")

    AFAIK, JQuery HTML constructors use document fragments behind the
    scenes. See
    [http://www.bennadel.com/blog/2281-jQuery-Appends-Multiple-Elements-Using-Efficient-Document-Fragments.htm](http://www.bennadel.com/blog/2281-jQuery-Appends-Multiple-Elements-Using-Efficient-Document-Fragments.htm)
    .

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620804#respond)

    +2

    -   16

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 5th, 2012 2:23
        pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620826 "Commentlink #16")

        jQuery does indeed use DocumentFragments behind the scenes. That
        said, I found that in my test cases while writing this article
        that using fragments directly appeared to offer performance
        improvements even though jQuery should technically be using a
        similar approach for its constructors. It may be localized to my
        tests, so as mentioned, be sure to benchmark your own code to be
        certain :)

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620826#respond)

        +4

9.  17

    ![image](http://1.gravatar.com/avatar/bfa2b2073378a5de445aa9a885055884?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Luiz Lopes

    [November 5th, 2012 10:36
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620806 "Commentlink #17")

    Addy, thanks for the great post. Specially with the tests on
    documentFragment.\
     I did notice that line 12 of ModuleD should be var td, tr. Correct?

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620806#respond)

    +2

    -   18

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 5th, 2012 1:19
        pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620817 "Commentlink #18")

        Thanks! We actually corrected this a few hours ago but the
        caching might be taking a while to kick in. Hopefully the right
        version will be up soon :)

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620817#respond)

        +1

10. 19

    ![image](http://0.gravatar.com/avatar/8e3972b68c4ef18a540e356b13f5265b?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Razvan Caliman

    [November 5th, 2012 11:02
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620809 "Commentlink #19")

    Great article with tremendous amounts of valuable information.\
     Thank you for sharing all this!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620809#respond)

    -   20

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 6th, 2012 3:29
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620882 "Commentlink #20")

        You’re welcome. Thanks Razvan!

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620882#respond)

        -3

11. 21

    ![image](http://1.gravatar.com/avatar/b4b7e21776a1081ba754619d20e33f4c?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Luke

    [November 5th, 2012 11:22
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620810 "Commentlink #21")

    Hi Addy,\
     Your performance test for Module Pattern vs. Prototypal pattern is
    not an accurate test in that it’s defining the class in every
    iteration. This is not realistic. The use of a class is that you
    define it once and you can create as many instances of that class as
    you need.

    In this modified version of your test, the Prototypal pattern is the
    fastest means of instantiating a new instance of a class in
    Javascript.
    [http://jsperf.com/prototypal-performance/11](http://jsperf.com/prototypal-performance/11)

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620810#respond)

    +2

    -   22

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 5th, 2012 1:48
        pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620819 "Commentlink #22")

        Hey Luke,

        Thanks a lot for your comment! In your test it appears that the
        prototypal pattern is the fastest approach in Chrome, but may
        require further testing to verify if this holds true for other
        browsers (e.g in the results, FF16 actually appears to favor the
        module pattern with cached functions a little better). Will
        review and test further to confirm, but I’ll update the text if
        we can verify its the fastest option.

        Cheers!\
         Addy

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620819#respond)

        +1

        -   23

            ![image](http://1.gravatar.com/avatar/3974d5bcfbdb27cc99d10706dc5b85f7?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

            ### Luke Smith

            [November 5th, 2012 3:52
            pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620831 "Commentlink #23")

            Hi Addy,

            The test is still apples to oranges because neither module
            pattern constructors should be called with new because they
            are returning objects. Calling them with new will (should?
            might?) create a throw away ‘this’ object before the return,
            so they are doing twice the work or more.

            I adjusted the benchmark accordingly, and the results favor
            module pattern with cached functions.
            [http://jsperf.com/prototypal-performance/12](http://jsperf.com/prototypal-performance/12)

            [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620831#respond)

            +2

            -   24

                ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

                ### Addy Osmani

                [November 6th, 2012 3:15
                am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620879 "Commentlink #24")

                Aha. Another good catch. I’m relieved to see the
                original assertion about the cached functions variation
                of the module pattern holds. Article and tests updated.
                Thanks, Luke!

                [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620879#respond)

                +1

                -   25

                    ![image](http://1.gravatar.com/avatar/1c5fbb79fc57057d11be9f3c6da1512b?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

                    ### Artem

                    [November 6th, 2012 4:50
                    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620949 "Commentlink #25")

                    Addy,\
                     Your test of prototype versus module pattern
                    performance doesn’t consider one important
                    real-world scenarios aspect: created object state.
                    If you modify your module/constructor function to
                    take an input parameter that should be accessible
                    from within ‘foo’ and ‘bar’ functions of the module,
                    then using ‘cached’ functions becomes troublesome.
                    One way to make them work is to bind them, but it
                    obviously comes at a price.\
                     The benchmark is here:
                    [http://jsperf.com/prototypal-performance/18](http://jsperf.com/prototypal-performance/18)

                    +4

12. 26

    ![image](http://0.gravatar.com/avatar/89b52afc58270e98d8233ef0a7d4d6c5?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Goles

    [November 5th, 2012 11:25
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620811 "Commentlink #26")

    So coding in Javascript is getting more complex than doing C++
    coding…

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620811#respond)

    +1

    -   27

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 5th, 2012 2:00
        pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620823 "Commentlink #27")

        Complexity, or in this case, writing code that is memory
        efficient is a problem which certainly isn’t exclusive to C++ :)

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620823#respond)

        +6

13. 28

    ![image](http://0.gravatar.com/avatar/ca9b1ef1de9bfa3f922a8f1834270ec9?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Jeff

    [November 5th, 2012 12:34
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620814 "Commentlink #28")

    jQuery already optimizes DOM creation using document fragments. If
    you’re using jQuery, it is not necessary to use documentFragments
    like this article suggests.

    For the setTimeout and setInterval tip, it’s worth noting that
    JavaScript has clearTimeout and clearInterval methods which are the
    correct way to cancel/clear a timeout/interval. Newbies might not
    know these methods exist since they weren’t mentioned in the
    article. Here’s an example:

    var a = setTimeout(function () { alert(‘timeout fired’); }, 10000);
    //10 second delay\
     clearTimeout(a);

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620814#respond)

    +2

    -   29

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 5th, 2012 2:24
        pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620827 "Commentlink #29")

        Hey Jeff – please see my response to Tarun above regarding
        fragments and jQuery.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620827#respond)

        +2

14. 30

    ![image](http://0.gravatar.com/avatar/03e68222ddea40cedf8ced64f0e46d02?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Wix

    [November 5th, 2012 1:48
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620820 "Commentlink #30")

    I wonder if largeStr will really be garbage collected in this case:

    var a = function () {\
     var smallStr = ‘x’;\
     var largeStr = new Array(1000000).join(‘x’);\
     return function (n) {\
     return smallStr;\
     };\
     }();

    because you could have code like that:

    var a = function () {\
     var smallStr = ‘x’;\
     var largeStr = new Array(1000000).join(‘x’);\
     return function (n) {\
     return eval(n);\
     };\
     }();

    and it allows you to access any variable in scope so the compiler
    cannot infer which variable can be collected. This example uses
    explicit eval but it too can be hidden.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620820#respond)

    -1

    -   31

        ![image](http://1.gravatar.com/avatar/fda6f53b0ce7c086978f9840aa4c7715?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Wyatt

        [November 6th, 2012 10:18
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620918 "Commentlink #31")

        Upon detecting the presence of eval, v8 does not perform many
        common operations, including invoking the GC on likely garbage.
        So in the article’s example it will be GC’d, but only because v8
        is smart.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620918#respond)

15. 32

    ![image](http://1.gravatar.com/avatar/9ba93d2ceaec08c874b8014e96655378?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Brett Jones

    [November 5th, 2012 2:00
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620822 "Commentlink #32")

    Great article! Question, though – what are you talking about with
    this dispose() method for Backbone? There is no such method in
    Backbone. There are a few extensions on gitHub which provide a
    dispose() method, though. Were you referring to one of these?

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620822#respond)

    +1

    -   33

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 6th, 2012 2:32
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620873 "Commentlink #33")

        Sure thing! You won’t find \`dispose()\` in the current stable
        version of Backbone, but it is in the latest bleeding edge. See
        [https://github.com/documentcloud/backbone/blob/master/backbone.js\#L1234](https://github.com/documentcloud/backbone/blob/master/backbone.js#L1234).
        As you mentioned, a number of Backbone extension frameworks (e.g
        Marionette) also try to offer similar behaviour.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620873#respond)

16. 34

    ![image](http://0.gravatar.com/avatar/e8c0e7bcdbae699b61373750be72a07a?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### adam

    [November 5th, 2012 2:16
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620824 "Commentlink #34")

    I love this post. I’d really like to read it again when I get home
    tonight. Do you moderate your comments? I don’t get it.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620824#respond)

    +1

    -   35

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 6th, 2012 2:07
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620869 "Commentlink #35")

        Please feel free to. On comments, I believe they get
        automatically approved and shown. I’m just replying to them as
        time allows :)

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620869#respond)

        +1

17. 36

    ![image](http://0.gravatar.com/avatar/6f11b242596a515db6059ad12c384244?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Suvash

    [November 5th, 2012 2:26
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620828 "Commentlink #36")

    Thanks for the article ! It’s awesome, not quite done but had a
    quick question anyway.

    In the “DE-REFERENCING MISCONCEPTIONS” you mention\
     delete o.x being bad\
     What about\
     o.x = undefined

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620828#respond)

    -   37

        ![image](http://1.gravatar.com/avatar/fda6f53b0ce7c086978f9840aa4c7715?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Wyatt

        [November 6th, 2012 10:23
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620919 "Commentlink #37")

        By setting o.x to undefined you nullify any assumptions v8 has
        made about the type of your variable. Such assumptions are
        fairly key to performance/Inline Caching/Type-specializing JIT
        compiler. Type-stability/writing C-like code is probably the
        best rule of thumb for creating fast JavaScript in new engines.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620919#respond)

        +2

18. 38

    ![image](http://1.gravatar.com/avatar/fd06cefb959e4e9dfefb35621f4a993e?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### ryanve

    [November 5th, 2012 8:40
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620841 "Commentlink #38")

    Re: de-referencing – Based on the [hidden
    class](https://developers.google.com/v8/design) docs I imagine the
    described benefit of avoiding \`delete\` only applies when the
    property is expected to be reset at some point later. Is that right?
    What exactly is a “generic slow object”? My interpretation is that
    using \`delete\` is like de-initializing the property (and its
    hidden class) but that setting it to \`null\` or \`undefined\` frees
    memory of the prop’s data but keeps the prop’s hidden class in
    memory. Am I understanding this correctly?

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620841#respond)

    -   39

        ![image](http://1.gravatar.com/avatar/dfe4afb8fb421f33b81635ab90764d28?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Vyacheslav Egorov

        [November 6th, 2012 9:18
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620913 "Commentlink #39")

        “generic slow object” refers to the way V8 stores and accesses
        object properties.

        Fast objects are those that are stored in a way similar to that
        used by more static languages like Java: a linear sequence of
        fields plus a reference to a hidden class that describes layout.
        Properties of fast objects are accessed through offsets on
        monomorphic paths in optimized code and no lookup overhead is
        involved. This representation is compact and fast when accessed
        in monomorphic way.

        Slow objects are those that have their properties stored in the
        hash map. Every time you are accessing a property of a slow
        object V8 does a hash lookup to find it. This representation is
        bloated and slow (compared to fast one).

        When you delete a property from an object V8 will convert the
        object from fast mode (if it was in fast mode) to slow mode.
        This will negatively impact both the memory usage and
        performance of property accesses.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620913#respond)

        +1

19. 40

    ![image](http://0.gravatar.com/avatar/e6fe2e99e6b6e26b966a722703a915e5?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Freddy

    [November 5th, 2012 10:05
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620844 "Commentlink #40")

    Any jsperf sample to support your proposal of “DE-REFERENCING
    MISCONCEPTIONS”? There should be a reason why “delete” exists in js.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620844#respond)

    -   41

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 6th, 2012 3:21
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620880 "Commentlink #41")

        There absolutely is a reason “delete” exists in JavaScript (see
        [http://perfectionkills.com/understanding-delete/](http://perfectionkills.com/understanding-delete/)
        for a great, in-depth article about it from @Kangax). “delete”
        is valid for removing a key from a map but you need to be
        careful about changing the structure of “hot” objects (which
        “delete” does do) as it’s harder for V8 to optimize those cases.
        Also see my response to the question from Amit for more on this
        :)

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620880#respond)

        +1

        -   42

            ![image](http://0.gravatar.com/avatar/e6fe2e99e6b6e26b966a722703a915e5?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

            ### Freddy

            [November 13th, 2012 6:57
            pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621517 "Commentlink #42")

            \`delete\` will still has its purpose. I am working with a
            mobile hybrid apps project that involves a lot of canvas
            manipulation. I used \`delete\` in very tight loop that
            generates a lot of canvas masks. Without delete, it will
            simply crash quite often in those awful Android tablets. I
            wish I can throw one of those android craps out of the
            window down to the swimming pool ;-)

            And coming from native app developer background using
            Objective-C, I am very particular about being memory
            efficient, how I can tell the compiler at which particular
            point that the program should release the memory with
            immediate effect.

            So \`delete\` will still have its own stand.

            You should probably be more specific like what kangax wrote
            his case about instead of generalising everything.

            [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621517#respond)

            +1

20. 43

    ![image](http://0.gravatar.com/avatar/87ace29077a2e36b9481e0889d68bd3a?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Amit Agarwal

    [November 5th, 2012 11:57
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620855 "Commentlink #43")

    Excellent article Addy. I am using many delete’s in my code. Can you
    talk more about why using delete operator is not a good idea? How
    does it harm internal hidden classes? Any example to elaborate on
    this?

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620855#respond)

    -   44

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 6th, 2012 2:40
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620875 "Commentlink #44")

        Sure thing. I can’t comment about other JavaScript engines, but
        when you delete elements (e.g in an array) it makes the key set
        sparse and can lead to V8 switching elements to dictionary mode
        (i.e not fast mode). Even if only a single element is deleted
        from an otherwise “full” array, things will be much slower. This
        demonstrates the effect:
        [http://jsperf.com/packed-vs-holey-arrays](http://jsperf.com/packed-vs-holey-arrays)
        (mentioned in the article above).

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620875#respond)

        +1

21. 45

    ![image](http://0.gravatar.com/avatar/aa38c5057dcbdfd17b29249ff80c7bdd?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Adam

    [November 6th, 2012 12:11
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620858 "Commentlink #45")

    Addy, can you share references to your source material for this
    article?

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620858#respond)

    -   46

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 6th, 2012 2:11
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620871 "Commentlink #46")

        Sure thing! It’s a combination of experience, V8 docs, Daniel
        Clifford’s excellent I/O 2012 presentation
        ([http://www.youtube.com/watch?v=UJPdhx5zTaw](http://www.youtube.com/watch?v=UJPdhx5zTaw)),
        Vyacheslav Egorov’s awesome posts (and talks) about V8, and
        direct input from Jakob Kummerow and Michael Starzinger who are
        both members of the V8 team and reviewed the article at various
        stages. You might find Michael’s JSConf talk on performance also
        useful
        [https://www.youtube.com/watch?feature=player\_embedded&v=ZhshEZIV2F4](https://www.youtube.com/watch?feature=player_embedded&v=ZhshEZIV2F4)

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620871#respond)

        +1

22. 47

    ![image](http://1.gravatar.com/avatar/b858d050bba81b9c3a75bcdabd777fa2?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### chaos

    [November 6th, 2012 12:20
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620860 "Commentlink #47")

    O,I can’t agree in something.\
     1.about “Wix” said.the largeStr will not be collected.\
     2.Object is faster than Array for Array in Javascript is not real
    Array.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620860#respond)

    -3

23. 48

    ![image](http://1.gravatar.com/avatar/faacd7b4b170c52f63220d83b010726d?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Tim Soulo

    [November 6th, 2012 1:15
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620865 "Commentlink #48")

    Now this was a fantastic article! Thanks!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620865#respond)

24. 49

    ![image](http://0.gravatar.com/avatar/2f11d6b2909b72da7c614dc7591f5b3f?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Neranjan

    [November 6th, 2012 7:14
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620903 "Commentlink #49")

    very useful article… Thanks!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620903#respond)

25. 50

    ![image](http://1.gravatar.com/avatar/f58a44742aa894baabc1cc592b404637?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Dan Sutton

    [November 6th, 2012 9:58
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620915 "Commentlink #50")

    Very nice. A lot of this carries over into other languages as well
    (C\# tends to spring to mind, especially in many of the bits about
    garbage collection).

    JavaScript is an especially hard language for many people to grasp
    in terms of how it works internally, (a) because implementations
    vary from browser to browser, and (b) because it’s so loose in terms
    of how it views scope and type that at times, it’s not always
    straightforward to understand in terms of how it handles
    persistence.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620915#respond)

26. 51

    ![image](http://1.gravatar.com/avatar/fda6f53b0ce7c086978f9840aa4c7715?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Wyatt

    [November 6th, 2012 10:48
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620923 "Commentlink #51")

    I would think an even more optimized module for your table question
    would not use frag2, as you aren’t inserting anything to the live
    DOM where you use it. This seems to be the case as shown here:\
     [http://jsperf.com/first-pass/7](http://jsperf.com/first-pass/7)\
     (dDTab function inserted (drawDocumentFragTable without frag2) and
    ModuleC changed to a version of ModuleD which instead calls dDTab)

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620923#respond)

27. 52

    ![image](http://1.gravatar.com/avatar/d13f711705e5b1069b4834588caa55d5?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Cole

    [November 6th, 2012 2:06
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620936 "Commentlink #52")

    AWESOME. Thanks so much! Keep on publishing man. This article and
    your one on MVC have been sooo helpful. I had no clue how much
    potential gain can come from cached functions in the module pattern!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620936#respond)

28. 53

    ![image](http://1.gravatar.com/avatar/fb5e3a539b1e23c54b080b6d12b411c2?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Dan Dascalescu

    [November 6th, 2012 9:55
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620970 "Commentlink #53")

    Other than a few typos, a most excellent article; thank you Addy!

    add(‘a’,”b’); // extra apostrophe

    “an helpful” -\> “a helpful”

    “or that repaints” -\> “or that repaint” or “or repaint”

    PS: Monomorphic variables seem to offer extremely little performance
    improvement (under 2%) –
    [http://jsperf.com/monomorphic-variable-performance](http://jsperf.com/monomorphic-variable-performance)

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620970#respond)

    +1

    -   54

        ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Addy Osmani

        [November 7th, 2012 2:13
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621004 "Commentlink #54")

        Thanks Dan! I’ve corrected the typos you mentioned. I’ll review
        the perf test you shared in a little more depth soon.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621004#respond)

    -   55

        ![image](http://1.gravatar.com/avatar/fda6f53b0ce7c086978f9840aa4c7715?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Wyatt

        [November 8th, 2012 9:25
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621145 "Commentlink #55")

        Monomorphism specifically gives you a benefit in repeated
        property access or function calls, neither of which are
        demonstrated in that test. For monomorphic objects, v8 can
        convert to flat fields with fast access rather than normal
        property lookup. As well, function calls can be fully inlined if
        called with static types.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621145#respond)

        +1

29. 56

    ![image](http://1.gravatar.com/avatar/74c27b07549984a161b5239714e0883d?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Kedar Kamthe

    [November 7th, 2012 12:15
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620985 "Commentlink #56")

    Addy, Thanks for the great post. Especially the background of V8
    engine which you have given before explaining the valuable
    information of Js code optimization .

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=620985#respond)

30. 57

    ![image](http://1.gravatar.com/avatar/3177b0a704ec3ada94d20866ff8000eb?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### mustafa

    [November 7th, 2012 2:04
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621001 "Commentlink #57")

    it would be fantastic if smashing magazine enable printer friendly
    version of writings like this

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621001#respond)

    -1

31. 58

    ![image](http://0.gravatar.com/avatar/04ceab75fbdf653094a81f6b853cd168?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Angelo

    [November 7th, 2012 8:02
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621039 "Commentlink #58")

    @mustafa, I agree. Most of the time, I have to print such great
    article such as this and read it on the home way since I am taking
    the subway as I do not have time to read at work.

    Actually, just found out that if you open this in chrome and try
    printing it, browser will render it nicely and would let you print
    it the way you wanted to see it.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621039#respond)

32. 59

    ![image](http://0.gravatar.com/avatar/663e18a8680c94423018da41a8c67051?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Mihkel

    [November 7th, 2012 9:24
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621046 "Commentlink #59")

    Hi Addy,

    What would be the correct way to do a “self invoking timer” that
    would tick forever?

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621046#respond)

33. 60

    ![image](http://1.gravatar.com/avatar/363faf4de7c4fcdb4824c61c540e949d?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Trajan McGill

    [November 7th, 2012 2:10
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621064 "Commentlink #60")

    Nice article. One thing that could be made clearer, though, is the
    closures section. The examples given and their descriptions seem to
    suggest that the variable closed upon actually needs to be returned
    or otherwise directly accessible to the outside in order to remain
    in use and uncollected by the GC. But that’s not really necessary.
    For instance:

    var someVar =\
     (function()\
     { var innerThing=[]; return function() { innerThing.push(1); return
    true; }; }\
     )();

    You can’t access innerThing from the outside at all, but it persists
    and can’t be garbage-collected, because the function object referred
    to by someVar contains a reference to it. In other words, it doesn’t
    have to do with whether you “can/can’t access” it, it has to do with
    whether some other object, one that can’t itself yet be
    garbage-collected, still holds a reference to it.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621064#respond)

34. 61

    ![image](http://0.gravatar.com/avatar/600a23817dcc8aea105897c93712b85b?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Rodrigo Alves Vieira

    [November 8th, 2012 9:19
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621144 "Commentlink #61")

    You can also make your code more memory efficient by caching length
    inside of JavaScript loops.

    As explained here
    [http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/)

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621144#respond)

    -1

35. 62

    ![image](http://0.gravatar.com/avatar/c54e76d2a8908b68d73f73485a540855?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Daniel Beauchamp

    [November 8th, 2012 3:20
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621169 "Commentlink #62")

    Hey Addy,

    Great article. I was just wondering if you have a source for global
    variables not being cleaned by the garbage collector.

    I tried to reproduce this on Chrome 23, and it seems like the
    garbage collector does in fact clean up de-referenced objects. I
    have the experiment here:
    [https://gist.github.com/4035423](https://gist.github.com/4035423)

    Any clarification would be greatly appreciated.\
     Thanks,\
     Daniel

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621169#respond)

36. 63

    ![image](http://1.gravatar.com/avatar/d3ba747177213af5a7394e5633360ed7?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Pipo

    [November 9th, 2012 3:50
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621206 "Commentlink #63")

    “For example, when you need vectors, don’t define a class with
    properties x, y, z; use an array instead.”

    It seems this is only faster in Chrome. In Opera (12) it doesn’t
    really matter and in Firefox (16) and Safari (6) an object with x
    and y properties is faster.\
     See:
    [http://jsperf.com/properties-vs-indices](http://jsperf.com/properties-vs-indices)

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621206#respond)

    -   64

        ![image](http://1.gravatar.com/avatar/b430141a8ee7c3c6b47a79efbcd435de?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Andrew Petersen

        [November 14th, 2012 1:58
        pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621583 "Commentlink #64")

        As you basically said, I think the speed comparison of
        performing actions on an array vs object is debatable. So
        instead, I think of it this way:

        \1) It’s all about context. \`xyz\` is easier to read, in my
        opinion, but If you’re doing webGL, arrays can be passed
        directly to webGL functions without having to create temporary
        objects or “convert”.\
         2) Never make a “Vec3″ class, as the \`this\` lookup is
        apparently slower:
        [http://jsperf.com/new-vecA3-vs-duck](http://jsperf.com/new-vecA3-vs-duck)

        I like your perf test, but it’s good to keep in mind that there
        are two (maybe more?) aspects to measure: property lookup speed
        (your test) and creation speed (my test).

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621583#respond)

        -   65

            ![image](http://1.gravatar.com/avatar/d3ba747177213af5a7394e5633360ed7?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

            ### Pipo

            [November 15th, 2012 6:27
            am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621627 "Commentlink #65")

            Just for everyone else: Andrews link had a typo. The correct
            link is
            [http://jsperf.com/new-vec3-vs-duck](http://jsperf.com/new-vec3-vs-duck).

            Thanks for your test. I’ve extended your test so it has an
            array test case as well:\

            [http://jsperf.com/new-vec3-vs-duck/2](http://jsperf.com/new-vec3-vs-duck/2)\
             It seems in Chrome it doesn’t matter, but in every other
            browser the arrays are the slowest.

            [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621627#respond)

            -   66

                ![image](http://1.gravatar.com/avatar/b430141a8ee7c3c6b47a79efbcd435de?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

                ### Andrew Petersen

                [November 15th, 2012 11:01
                am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621640 "Commentlink #66")

                Thanks for the typo fix! I think it was a vim leak.

                If you checkout the results, FF18 has some pretty crazy
                results comparatively. Factory is fastest by a long
                shot, and everything else is middling.

                [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621640#respond)

37. 67

    ![image](http://0.gravatar.com/avatar/8bb75c7c1989c0cf27be3f592af639d6?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Kate Matsudaira

    [November 13th, 2012 12:19
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621497 "Commentlink #67")

    This is a fantastic collection of best practices and how to make the
    most of JavaScript. This is a must read if you work with JavaScript
    or are interviewing front-end devs. Thanks for sharing!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621497#respond)

    +1

38. 68

    ![image](http://1.gravatar.com/avatar/b430141a8ee7c3c6b47a79efbcd435de?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Andrew Petersen

    [November 14th, 2012 1:18
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621579 "Commentlink #68")

    Addy, thank you for writing this article, and that the points you
    made were accompanied by “hard data”!

    tl;dr; Is there a way to use “private” variables with your cached
    module pattern?

    I was reviewing the section on the module pattern, and got excited
    about cached functions being just as fast in V8 as prototypes. But
    then I realized that the cached functions give you no way to use
    “private” variables, which to me is the primary benefit of using a
    module pattern variant. I edited your perf test (I added Klass5 & 6)
    ([http://jsperf.com/prototypal-performance/26](http://jsperf.com/prototypal-performance/26))
    to examine approaches using bind, and am curious if you have a
    solution that allows for cached functions \_and\_ private variables.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=621579#respond)

    +3

39. 69

    ![image](http://0.gravatar.com/avatar/4400f78118fff331a7faa1933d8f88f5?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Justin

    [November 22nd, 2012 12:24
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-622038 "Commentlink #69")

    Sour grapes, but … the whole detect an element has been removed and
    unbind has been in JMVC for 4 years and it’s a big and heavily
    promoted feature of CanJS.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=622038#respond)

40. 70

    ![image](http://1.gravatar.com/avatar/1e9f1348d218b0a904215a82c15d5602?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Laerte Saliai

    [November 22nd, 2012 12:47
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-622043 "Commentlink #70")

    Thank you Addy.\
     Always excellent articles and good ideas.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=622043#respond)

    +1

41. 71

    ![image](http://1.gravatar.com/avatar/1577c5579fd5b4c5c80aec42b1744728?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Guilherme Medeiros

    [November 27th, 2012 6:18
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-622392 "Commentlink #71")

    Most required article of 2012.\
     Thanks Addy!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=622392#respond)

42. 72

    ![image](http://1.gravatar.com/avatar/3478efd1de1ba3c35784d870b77fae89?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### ciembor

    [November 28th, 2012 9:18
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-622444 "Commentlink #72")

    This is really useful article. I hoped I will find here the answer
    for my current dilemma: custom events vs observer pattern:
    [http://stackoverflow.com/questions/13609994/performance-of-custom-events-and-observer-pattern-in-node-js](http://stackoverflow.com/questions/13609994/performance-of-custom-events-and-observer-pattern-in-node-js).
    I think it’s good topic for some research…

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=622444#respond)

43. 73

    ![image](http://1.gravatar.com/avatar/f5e2d19cb5918ca81feb1b19ba6aa8e2?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Bob Rogan

    [February 2nd, 2013 7:34
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-632493 "Commentlink #73")

    With due respect your rationalizations in support of the CHROME
    browser/Java-script-code-executioner are absurd. Google decided to
    model their Java-script internet browser (Chrome) based on the
    success of their URL rapid look-up algorithms. In so doing the
    Chrome Browser randomly initiates copies of itself, thus making
    execution of Java-script based Web-site software precarious, and
    super slow compared to the same code running on any of the other
    Browsers. My question is why did Google make such an egregious
    design mistake? , and is there anyway to rectify the problem with
    CHROME randomly initiating copies of itself ?\
     Thanks\
     Bob Rogan

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=632493#respond)

    -3

44. 74

    ![image](http://1.gravatar.com/avatar/5a39b8e048d7ca23ba3e43110975bd4a?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### David Corbacho

    [February 13th, 2013 7:38
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-634906 "Commentlink #74")

    Hi Addy,

    Excellent article.

    A small issue: Someone created a revision ( I think it’s the
    benchmark you wanted to post) for the “second pass”

    [http://jsperf.com/second-pass/3](http://jsperf.com/second-pass/3)

    Because the link you posted doesn’t have any sense with //
    modG.init() line commented.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=634906#respond)

45. 75

    ![image](http://0.gravatar.com/avatar/ce6f1572ba020046a4db5ab40374f6e3?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### kamylko

    [March 10th, 2013 7:28
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-644747 "Commentlink #75")

    I’d like to ask, what means “to bail out” in this context? I’m not
    native speaker and I am confused with meaning of that phrase. Can
    somebody explain to me, or rather rewrite these paragraphs please?

    this one:\
     V8 supports deoptimization, meaning the optimizing compiler can
    bail out of code generated if it discovers that some of the
    assumptions it made about the optimized code were too optimistic.

    and this one:\
     Certain patterns will cause V8 to bail out of optimizations. A
    try-catch, for example, will cause such a bailout. For more
    information on what functions can and can’t be optimized, you can
    use –trace-opt file.js with the d8 shell utility that comes with V8.

    THANK YOU!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=644747#respond)

    -   76

        ![image](http://1.gravatar.com/avatar/9f54c1f814e618404997a7291930064a?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Esailija

        [September 22nd, 2013 11:18
        pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-970319 "Commentlink #76")

        It means giving up on optimizations.

        In the first example, if a function is optimized under the
        assumption that the second argument passed is always an integer,
        and then you pass something else, then that function will be
        deoptimized. However, it doesn’t completely give up on the
        function yet and it can be later optimized again under better
        assumptions.

        In the second example V8 permanently gives up on optimizing the
        function because it contains unsupported syntax such as
        try-catch. A function that contains try-catch will not be
        optimized.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=970319#respond)

46. 77

    ![image](http://1.gravatar.com/avatar/9831b6298412930d048f750f941d05e4?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Howard

    [March 26th, 2013 11:06
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-660200 "Commentlink #77")

    Excellent article — thanks!

    I’m not sure that I saw our local current subject of debate
    discussed, though: use of inner functions (whether they’re actual
    closures or not) vs object properties, e.g.

    var myObj = {\
     methodProp: function() {\
     var x,y;\
     function doSomethingIOnlyNeedHere(a,b) {\
     return a – b\*2;\
     }\
     return doSomethingIOnlyNeedHere(y,x);\
     }\
     }

    as opposed to

    var myObj = {\
     \_pseudoPrivateDoSomething: function(a,b) {\
     return a – b\*2;\
     },\
     methodProp: function() {\
     var x,y;\
     return this.\_pseudoDoSomething(y,x);\
     }\
     }

    I’d argue that data privacy and the rule/pattern: “hide by policy,
    reveal by necessity” supports the first variant; but a coworker
    argues that testability and memory usage issues makes the second
    variant more desirable.

    What do you say?

    Thanks!

    –

    Howard

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=660200#respond)

    -   78

        ![image](http://1.gravatar.com/avatar/9f54c1f814e618404997a7291930064a?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Esailija

        [September 22nd, 2013 11:30
        pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-970320 "Commentlink #78")

        Just because the underscore prefix doesn’t actually hide the
        properties during runtime, doesn’t mean it didn’t achieve the
        goals. In most languages, it is possible to access “hidden”
        properties during runtime through e.g. reflection or directly
        using memory, yet they have clearly achieved the goals.

        The second variant when used with constructors also enables much
        better code reuse and usability since the methods won’t be tied
        to concrete closures but remain abstract and generic.

        And yes, having to allocate N JSFunctions when you create an
        instance is slower than not having to allocate anything but the
        object itself. N=25 jsperf
        [http://jsperf.com/prtorpropr](http://jsperf.com/prtorpropr)

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=970320#respond)

47. 79

    ![image](http://0.gravatar.com/avatar/82ece4643b9e711b9ac6c3b4cb674622?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### amy

    [May 4th, 2013 8:30
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-832103 "Commentlink #79")

    Can someone explain why the document fragment code doesn’t result in
    table rows where each cell has one more cell than the row above it?
    Does adding the fragment to something else somehow clear it out for
    reuse?

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=832103#respond)

48. 80

    ![image](http://0.gravatar.com/avatar/8b04f8283fa64916fc5041138ac85548?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Neeraj

    [June 5th, 2013 9:55
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-947372 "Commentlink #80")

    Excellent article. I am trying to find out performance overhead of
    associative array with long key name. Suppose I have an array with
    2000 keys and some of those are very long names, like:\
     myArray['thisisverylongkeyname'] = ‘some value’;

    My general feeling is that lookup with shorter key names will be
    faster, like:\
     myArray['shName'] = ‘some value’; should be faster than above.

    Is it true or it doesn’t matter in browser like chrome? Is there an
    article or documentation to prove my point or otherwise.

    Thanks\
     Neeraj

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=947372#respond)

    -   81

        ![image](http://1.gravatar.com/avatar/9f54c1f814e618404997a7291930064a?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Esailija

        [September 22nd, 2013 11:12
        pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-970317 "Commentlink #81")

        First of all, if you have 2000 such keys in an object, you are
        conceptually using a dictionary. So you should use something
        like a Map, OrderedMap or SortedMap depending on your need.
        There can be subtle bugs when using objects as dictionaries
        because arbitrary keys are not possble. For example
        ?\_\_proto\_\_ will/used to crash express body parser. At least
        use hasOwnProperty.

        In V8, having so many properties turns an object into dictionary
        mode and lookup speed is indeed proportional to the key length
        at this point. However, strings can be internalized and also
        cache their hash code so it’s not as clear-cut.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=970317#respond)

49. 82

    ![image](http://0.gravatar.com/avatar/c544d4d73d09238286b2a4ad69b15121?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Kash

    [June 10th, 2013 5:34
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-948461 "Commentlink #82")

    Is it just me or does the link under below does not work?

    [https://docs.google.com/presentation/d/1wUVmf78gG-ra5aOxvTfYdiLkdGaR9OhXRnOlIcEmu2s/pub?start=false&loop=false&delayms=3000\#slide=id.g1d65bdf6\_0\_0](https://docs.google.com/presentation/d/1wUVmf78gG-ra5aOxvTfYdiLkdGaR9OhXRnOlIcEmu2s/pub?start=false&loop=false&delayms=3000#slide=id.g1d65bdf6_0_0)

    from the section –

    “Luckily the DevTools can help locate some of these issues, and
    Loreena Lee has a fantastic presentation available documenting the
    “3 snapshot” technique for finding leaks within the DevTools that I
    can’t recommend reading through enough.”

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=948461#respond)

50. 83

    ![image](http://1.gravatar.com/avatar/de7ad23198aa560c9a12516481196fe1?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### sathya

    [July 12th, 2013 8:20
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-953148 "Commentlink #83")

    Hi,

    If possible please see this post.\

    [http://www.bennadel.com/blog/1482-A-Graphical-Explanation-Of-Javascript-Closures-In-A-jQuery-Context.htm](http://www.bennadel.com/blog/1482-A-Graphical-Explanation-Of-Javascript-Closures-In-A-jQuery-Context.htm)

    Most of the jQuery stuffs will be like that. I did many times like
    that. Are they all stay in memory until user closes their browser?

    Expecting your reply. Thanks !!!!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=953148#respond)

    +1

51. 84

    ![image](http://1.gravatar.com/avatar/de7ad23198aa560c9a12516481196fe1?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### sathya

    [July 12th, 2013 9:37
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-953175 "Commentlink #84")

    Please see this stack overflow post as well.

    [http://codereview.stackexchange.com/questions/19686/will-this-kind-of-codes-leak-memory](http://codereview.stackexchange.com/questions/19686/will-this-kind-of-codes-leak-memory)

    This is very common use case, that you could find among many
    developers. As per your article, this type of code will leak memory.
    right?

    Please do reply. I am really confused with clsoure + jQuery
    scenario.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=953175#respond)

    +1

52. 85

    ![image](http://1.gravatar.com/avatar/7aee58de3a50c13e688140bc06d60225?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Kevin Reid

    [August 5th, 2013 10:25
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-956995 "Commentlink #85")

    Small correction — “Items in arrays aren’t able to be customized as
    heavily — they either exist or they don’t.” is false. Array elements
    are just properties with names which happen to be decimal numbers.
    You can certainly expect that “un-customized” numeric-named
    properties on arrays will be optimized for by the implementation,
    but there is no restriction against reconfiguring array properties
    as any other.

    `var a = []; Object.defineProperty(a, '0', { get: function() { console.log('boo'); return 1; } }); console.log(a.length, a[0]);`

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=956995#respond)

    -   86

        ![image](http://1.gravatar.com/avatar/9f54c1f814e618404997a7291930064a?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

        ### Esailija

        [September 23rd, 2013 12:04
        am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-970323 "Commentlink #86")

        He is speaking from the point of view of V8 implementation. Any
        customization of an indexed property at all will permanently
        turn that object into a slow mode that it cannot exit from. But
        this isn’t true for customization of a named property for which
        you can define any kind of descriptor without direct penalty.

        [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=970323#respond)

53. 87

    ![image](http://1.gravatar.com/avatar/7a16950d09f405418289b25cb38e4b4c?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Eduardo F. Sandino

    [October 2nd, 2013 12:28
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-971078 "Commentlink #87")

    Hello, I have added new mixed patterns for testing and the results
    are quite interesting for people that use Firefox.

    \* Module Pattern + Cached Functions 22,608 ops/sec ±0.72%9% slower\
     \* Module Pattern + Dinamyc Functions 12,516 ops/sec ±1.86%50%
    slower\
     \* Module Pattern + Anonymous Functions 25,009 ops/sec
    ±1.30%fastest\
     \* Module Pattern + Anonymous Cached Functions 22,827 ops/sec
    ±6.94%14% slower

    [http://jsperf.com/javascript-module-pattern-test-cases](http://jsperf.com/javascript-module-pattern-test-cases)

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=971078#respond)

54. 88

    ![image](http://1.gravatar.com/avatar/f8967ec8a7540e8202eb31cf02cdd1e2?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### James

    [October 15th, 2013 8:41
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-973040 "Commentlink #88")

    This is an excellent article. I was having issues tearing down
    objects in my HTML5 game and this blog confirmed that my setInterval
    method was the issue. Thanks a lot!

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=973040#respond)

55. 89

    ![image](http://1.gravatar.com/avatar/1cc6dfb5b3b93f0a9fba12a89c4b9a7b?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### don sweitzer

    [October 28th, 2013 5:04
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-975033 "Commentlink #89")

    great article. Nice read, very informative.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=975033#respond)

56. 90

    ![image](http://1.gravatar.com/avatar/10aedf09de37178d5e7efe94988d8d7a?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### doug65536

    [December 16th, 2013 4:33
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-990614 "Commentlink #90")

    Explain this
    [http://jsperf.com/array-by-literals-vs-constructors](http://jsperf.com/array-by-literals-vs-constructors)

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=990614#respond)

57. 91

    ![image](http://1.gravatar.com/avatar/d1d33806049a5a98ad2c3a9f8b6e2ab6?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Tremayne Christ

    [January 16th, 2014 11:20
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-998066 "Commentlink #91")

    Another problem people may face, is the issue of not being able to
    add private methods onto the prototype chain. I have built a
    solution to this here
    [https://github.com/TremayneChrist/ProtectJS](https://github.com/TremayneChrist/ProtectJS)

    It allows you to add all of your methods to the prototype and then
    applies protection to the private ones so that they cannot be called
    from outside of the object.

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=998066#respond)

58. 92

    ![image](http://0.gravatar.com/avatar/493c283dabec69efdfc26eba0dc62dc9?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Daniel

    [March 27th, 2014 12:45
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-1032173 "Commentlink #92")

    “Create objects using a constructor function. This ensures that all
    objects created with it have the same hidden class and helps avoid
    changing these classes. As an added benefit, it’s also slightly
    faster than Object.create()”

    Using supplied jsperf link:

    Object.create() using pre-defined property object: 715,068 ops/sec\
     Constructor function: 157,804,384 ops/sec

    220 times difference? Yeah, I guess you could say that’s “slightly”
    faster.

    That’s in Chrome 34. Firefox 28 has a ‘mere’ 12x difference (with
    constructor function again in front).

    I would prefer to use Object.create() to constructor functions for
    the added flexibility, and while I understand that sometimes
    flexibility comes with a runtime cost, looking at those numbers I
    believe it’s fair to say: WTF?

    [Reply](/2012/11/05/writing-fast-memory-efficient-javascript/?replytocom=1032173#respond)

1.  1

    ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Addy Osmani

    [November 5th, 2012 8:30
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620794 "Commentlink #1")

    You’re very welcome. If you’re interested in learning more about
    DocumentFragment, you might like to read:

    \*
    [https://developers.google.com/speed/articles/javascript-dom](https://developers.google.com/speed/articles/javascript-dom)\
     \*
    [http://www.nczonline.net/blog/2009/02/03/speed-up-your-javascript-part-4/](http://www.nczonline.net/blog/2009/02/03/speed-up-your-javascript-part-4/)

    Zakas in particular has some great (older) talks that discuss the
    performance benefits of using it.

    +10

2.  2

    ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Addy Osmani

    [November 5th, 2012 2:00
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620823 "Commentlink #2")

    Complexity, or in this case, writing code that is memory efficient
    is a problem which certainly isn’t exclusive to C++ :)

    +6

3.  3

    ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Addy Osmani

    [November 5th, 2012 2:23
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620826 "Commentlink #3")

    jQuery does indeed use DocumentFragments behind the scenes. That
    said, I found that in my test cases while writing this article that
    using fragments directly appeared to offer performance improvements
    even though jQuery should technically be using a similar approach
    for its constructors. It may be localized to my tests, so as
    mentioned, be sure to benchmark your own code to be certain :)

    +4

4.  4

    ![image](http://1.gravatar.com/avatar/1c5fbb79fc57057d11be9f3c6da1512b?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Artem

    [November 6th, 2012 4:50
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620949 "Commentlink #4")

    Addy,\
     Your test of prototype versus module pattern performance doesn’t
    consider one important real-world scenarios aspect: created object
    state. If you modify your module/constructor function to take an
    input parameter that should be accessible from within ‘foo’ and
    ‘bar’ functions of the module, then using ‘cached’ functions becomes
    troublesome. One way to make them work is to bind them, but it
    obviously comes at a price.\
     The benchmark is here:
    [http://jsperf.com/prototypal-performance/18](http://jsperf.com/prototypal-performance/18)

    +4

5.  5

    ![image](http://0.gravatar.com/avatar/e27a75707d71787702edaf968fe40c60?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Jeroen Oliemans

    [November 5th, 2012 7:51
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620787 "Commentlink #5")

    Excellent article! Will become very handy when I’am playing with
    box2dweb and other cool processor intensive stuff. I also wasn’t
    aware of the “DocumentFragment” option in the DOM. Very handy!

    +3

6.  6

    ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Addy Osmani

    [November 5th, 2012 8:39
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620797 "Commentlink #6")

    \>What if, for instance, the inner function was using eval to
    calculate the variable name?

    Do you have a code example of what you had in mind?

    +3

7.  7

    ![image](http://1.gravatar.com/avatar/b430141a8ee7c3c6b47a79efbcd435de?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Andrew Petersen

    [November 14th, 2012 1:18
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-621579 "Commentlink #7")

    Addy, thank you for writing this article, and that the points you
    made were accompanied by “hard data”!

    tl;dr; Is there a way to use “private” variables with your cached
    module pattern?

    I was reviewing the section on the module pattern, and got excited
    about cached functions being just as fast in V8 as prototypes. But
    then I realized that the cached functions give you no way to use
    “private” variables, which to me is the primary benefit of using a
    module pattern variant. I edited your perf test (I added Klass5 & 6)
    ([http://jsperf.com/prototypal-performance/26](http://jsperf.com/prototypal-performance/26))
    to examine approaches using bind, and am curious if you have a
    solution that allows for cached functions \_and\_ private variables.

    +3

8.  8

    ![image](http://1.gravatar.com/avatar/59961b48d5e7c04d5ab167d9fe7a4bcd?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Val

    [November 5th, 2012 8:08
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620790 "Commentlink #8")

    Really useful article, thanks.

    Abou variables scope, is the second example with largeStr a safe
    garbage collection?\
     How does the compiler knows that largeStr won’t actually be used?\
     What if, for instance, the inner function was using eval to
    calculate the variable name?

    +2

9.  9

    ![image](http://1.gravatar.com/avatar/195f2398988daa8d20d2c820862be08a?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Roy Bakker

    [November 5th, 2012 8:34
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620795 "Commentlink #9")

    Extremely useful article, only briefly read it just now but i’ll
    definitely read it in full later!

    +2

10. 10

    ![image](http://1.gravatar.com/avatar/f113893fa3966c310b78b0b1fe7a1db1?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Tarun Elankath

    [November 5th, 2012 10:14
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620804 "Commentlink #10")

    AFAIK, JQuery HTML constructors use document fragments behind the
    scenes. See
    [http://www.bennadel.com/blog/2281-jQuery-Appends-Multiple-Elements-Using-Efficient-Document-Fragments.htm](http://www.bennadel.com/blog/2281-jQuery-Appends-Multiple-Elements-Using-Efficient-Document-Fragments.htm)
    .

    +2

11. 11

    ![image](http://1.gravatar.com/avatar/bfa2b2073378a5de445aa9a885055884?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Luiz Lopes

    [November 5th, 2012 10:36
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620806 "Commentlink #11")

    Addy, thanks for the great post. Specially with the tests on
    documentFragment.\
     I did notice that line 12 of ModuleD should be var td, tr. Correct?

    +2

12. 12

    ![image](http://1.gravatar.com/avatar/b4b7e21776a1081ba754619d20e33f4c?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Luke

    [November 5th, 2012 11:22
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620810 "Commentlink #12")

    Hi Addy,\
     Your performance test for Module Pattern vs. Prototypal pattern is
    not an accurate test in that it’s defining the class in every
    iteration. This is not realistic. The use of a class is that you
    define it once and you can create as many instances of that class as
    you need.

    In this modified version of your test, the Prototypal pattern is the
    fastest means of instantiating a new instance of a class in
    Javascript.
    [http://jsperf.com/prototypal-performance/11](http://jsperf.com/prototypal-performance/11)

    +2

13. 13

    ![image](http://0.gravatar.com/avatar/ca9b1ef1de9bfa3f922a8f1834270ec9?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Jeff

    [November 5th, 2012 12:34
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620814 "Commentlink #13")

    jQuery already optimizes DOM creation using document fragments. If
    you’re using jQuery, it is not necessary to use documentFragments
    like this article suggests.

    For the setTimeout and setInterval tip, it’s worth noting that
    JavaScript has clearTimeout and clearInterval methods which are the
    correct way to cancel/clear a timeout/interval. Newbies might not
    know these methods exist since they weren’t mentioned in the
    article. Here’s an example:

    var a = setTimeout(function () { alert(‘timeout fired’); }, 10000);
    //10 second delay\
     clearTimeout(a);

    +2

14. 14

    ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Addy Osmani

    [November 5th, 2012 2:24
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620827 "Commentlink #14")

    Hey Jeff – please see my response to Tarun above regarding fragments
    and jQuery.

    +2

15. 15

    ![image](http://1.gravatar.com/avatar/3974d5bcfbdb27cc99d10706dc5b85f7?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Luke Smith

    [November 5th, 2012 3:52
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620831 "Commentlink #15")

    Hi Addy,

    The test is still apples to oranges because neither module pattern
    constructors should be called with new because they are returning
    objects. Calling them with new will (should? might?) create a throw
    away ‘this’ object before the return, so they are doing twice the
    work or more.

    I adjusted the benchmark accordingly, and the results favor module
    pattern with cached functions.
    [http://jsperf.com/prototypal-performance/12](http://jsperf.com/prototypal-performance/12)

    +2

16. 16

    ![image](http://1.gravatar.com/avatar/fda6f53b0ce7c086978f9840aa4c7715?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Wyatt

    [November 6th, 2012 10:23
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620919 "Commentlink #16")

    By setting o.x to undefined you nullify any assumptions v8 has made
    about the type of your variable. Such assumptions are fairly key to
    performance/Inline Caching/Type-specializing JIT compiler.
    Type-stability/writing C-like code is probably the best rule of
    thumb for creating fast JavaScript in new engines.

    +2

17. 17

    ![image](http://1.gravatar.com/avatar/de7ad23198aa560c9a12516481196fe1?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### sathya

    [July 12th, 2013 8:20
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-953148 "Commentlink #17")

    Hi,

    If possible please see this post.\

    [http://www.bennadel.com/blog/1482-A-Graphical-Explanation-Of-Javascript-Closures-In-A-jQuery-Context.htm](http://www.bennadel.com/blog/1482-A-Graphical-Explanation-Of-Javascript-Closures-In-A-jQuery-Context.htm)

    Most of the jQuery stuffs will be like that. I did many times like
    that. Are they all stay in memory until user closes their browser?

    Expecting your reply. Thanks !!!!

    +1

18. 18

    ![image](http://1.gravatar.com/avatar/5c8e523e613b720fec1291442702a708?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Andrew Meredith

    [November 5th, 2012 8:02
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620789 "Commentlink #18")

    Great article! As a web developer who is just now getting into the
    front-end and trying to learn JavaScript, this is very helpful.
    There are so many JavaScript resources out there (I guess that’s an
    advantage of being the most popular programming language in the
    world), but there are not many that focus on performance, especially
    to this level of depth. Thanks again!

    +1

19. 19

    ![image](http://1.gravatar.com/avatar/3389aa5ee38d92f1bdc38131de4bfe75?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Eric Rowell

    [November 5th, 2012 8:22
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620793 "Commentlink #19")

    Wow, it’s nice to see thorough articles like this every now and
    then. Great job!

    One question though, you mentioned that having something like the
    memory leak finder would be a better fit as an external tool, rather
    than being built into Chrome – Why is that? I think it would make an
    excellent addition to the existing tools.

    +1

20. 20

    ![image](http://0.gravatar.com/avatar/490247488b9fe27f71f2369c3397d3cd?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Neeraj Aggarwal

    [November 5th, 2012 9:24
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620801 "Commentlink #20")

    This is very informative about the JavaScript. Being a front end
    developer, I always try to know how to optimize the performance of
    the JavaScript. This article really points out small tips about the
    JavaScript performance.

    Thanks Addy.

    +1

21. 21

    ![image](http://1.gravatar.com/avatar/5819f8e8addb33ebd840ffc630af6643?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Adam

    [November 5th, 2012 9:27
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620802 "Commentlink #21")

    Addy…great article! Thanks very much for sharing it with us!

    I had a question – I am returning a bunch of JSON objects from the
    server which are then stored in an array memory and used like a
    local cache.

    I run these objects through a helper function to make sure they all
    have the same keys (some of them are missing a few keys for whatever
    reason) – should I be creating new objects so they’ll all have the
    same hidden class in V8? Or does it really matter?

    The objects all have identical keys and the values are all fairly
    simple – ints, booleans, strings and, in one or 2 cases, arrays –
    but no methods.

    Thanks again!

    +1

22. 22

    ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Addy Osmani

    [November 5th, 2012 1:23
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620818 "Commentlink #22")

    So, the reason this isn’t a part of the DevTools is two fold. It was
    originally developed to help catch some specific memory scenarios in
    the Closure Library and it makes more sense as an external tool as
    it’s broader usefulness is still being evaluated. If there were more
    developers using the tool, the case for it being in there natively
    would certainly be stronger I imagine :)

    +1

23. 23

    ![image](http://0.gravatar.com/avatar/89b52afc58270e98d8233ef0a7d4d6c5?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Goles

    [November 5th, 2012 11:25
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620811 "Commentlink #23")

    So coding in Javascript is getting more complex than doing C++
    coding…

    +1

24. 24

    ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Addy Osmani

    [November 5th, 2012 1:19
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620817 "Commentlink #24")

    Thanks! We actually corrected this a few hours ago but the caching
    might be taking a while to kick in. Hopefully the right version will
    be up soon :)

    +1

25. 25

    ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Addy Osmani

    [November 5th, 2012 1:48
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620819 "Commentlink #25")

    Hey Luke,

    Thanks a lot for your comment! In your test it appears that the
    prototypal pattern is the fastest approach in Chrome, but may
    require further testing to verify if this holds true for other
    browsers (e.g in the results, FF16 actually appears to favor the
    module pattern with cached functions a little better). Will review
    and test further to confirm, but I’ll update the text if we can
    verify its the fastest option.

    Cheers!\
     Addy

    +1

26. 26

    ![image](http://1.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Addy Osmani

    [November 6th, 2012 3:21
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620880 "Commentlink #26")

    There absolutely is a reason “delete” exists in JavaScript (see
    [http://perfectionkills.com/understanding-delete/](http://perfectionkills.com/understanding-delete/)
    for a great, in-depth article about it from @Kangax). “delete” is
    valid for removing a key from a map but you need to be careful about
    changing the structure of “hot” objects (which “delete” does do) as
    it’s harder for V8 to optimize those cases. Also see my response to
    the question from Amit for more on this :)

    +1

27. 27

    ![image](http://1.gravatar.com/avatar/9ba93d2ceaec08c874b8014e96655378?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Brett Jones

    [November 5th, 2012 2:00
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620822 "Commentlink #27")

    Great article! Question, though – what are you talking about with
    this dispose() method for Backbone? There is no such method in
    Backbone. There are a few extensions on gitHub which provide a
    dispose() method, though. Were you referring to one of these?

    +1

28. 28

    ![image](http://0.gravatar.com/avatar/e8c0e7bcdbae699b61373750be72a07a?s=38&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### adam

    [November 5th, 2012 2:16
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620824 "Commentlink #28")

    I love this post. I’d really like to read it again when I get home
    tonight. Do you moderate your comments? I don’t get it.

    +1

29. 29

    ![image](http://1.gravatar.com/avatar/fda6f53b0ce7c086978f9840aa4c7715?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Wyatt

    [November 5th, 2012 11:30
    pm](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620853 "Commentlink #29")

    Hey Addy,

    Modifying the code to the following makes the necessity of the
    variables ambiguous:

    var a = function () {\
     var smallStr = ‘x’,\
     largeStr = new Array(10).join(‘x’);\
     return function (n) {\
     return eval(n+”Str”)\
     };\
     }();

    Though in this case, v8 barely attempts any optimization due
    specifically to the presence of eval. So to answer Val’s question,
    it is safe because V8 knows it is safe… and if it can’t know it
    doesn’t bother.

    +1

30. 30

    ![image](http://1.gravatar.com/avatar/59961b48d5e7c04d5ab167d9fe7a4bcd?s=38&d=http%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D38&r=G)

    ### Val

    [November 6th, 2012 2:06
    am](http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/#comment-620868 "Commentlink #30")

    Yep, that’s what I was talking about.\
     I guess there’s an useful lesson here: eval breaks engine
    optimisations for the scope where it’s used.

    +1

### Leave a Comment

Yay! You've decided to leave a comment. That's fantastic! Please keep in
mind that comments are moderated and `rel="nofollow"` is in use. So,
please do not use a spammy keyword or a domain as your name, or else it
will be deleted. Let's have a personal and meaningful conversation
instead. Thanks for dropping by!

[Click here to cancel
reply.](/2012/11/05/writing-fast-memory-efficient-javascript/#respond)

### [Click here to cancel reply.](/2012/11/05/writing-fast-memory-efficient-javascript/#respond)

Your name\*

Your email\*

Your message\*

[↑ Back to top](#top "Jump to the top of the page")

[↑ Back to top](#top "Jump to the top of the page")

Search

[↑ Back to top](#top "Jump to the top of the page")

-   Categories
-   [Coding](http://coding.smashingmagazine.com)
-   [Design](http://www.smashingmagazine.com/category/design/)
-   [Mobile](http://mobile.smashingmagazine.com/)
-   [Graphics](http://www.smashingmagazine.com/category/graphics/)
-   [UX Design](http://uxdesign.smashingmagazine.com/)
-   [WordPress](http://wp.smashingmagazine.com/)

-   Pages
-   [Books](http://www.smashingmagazine.com/books/)
-   [eBook Library](http://www.smashingmagazine.com/ebooks/)
-   [Workshops](http://www.smashingmagazine.com/workshops/)
-   [Email
    Newsletter](http://www.smashingmagazine.com/the-smashing-newsletter/)
-   [Job Board](http://jobs.smashingmagazine.com/)
-   [About us](http://www.smashingmagazine.com/about/)

Search on Smashing Magazine Search

Advertisement [Advertise with
us!](mailto:advertising@smashingmagazine.com "Advertise with us!")

### [![Smashing Newsletter](http://www.smashingmagazine.com/files/smashing-widget/v006/img/smnl.png) Smashing Newsletter](http://www.smashingmagazine.com/the-smashing-newsletter/)

Subscribe to our email newsletter for useful tips and valuable
resources, sent out every second Tuesday.

Subscribe

[![Digital Adaptation by Paul
Boag](http://media.smashingmagazine.com/wp-content/uploads/2013/04/sidebar-digital-adaptation-paul-boag-v5-opt.png)](http://www.smashingmagazine.com/books/#digital-adaptation)

Nothing is more frustrating than **stubborn management**. That's why we
published [Digital
Adaptation](http://www.smashingmagazine.com/books/#digital-adaptation),
a new book by Paul Boag on how to help management overcome legacy
practices — for good.

[![Smashing Printed
Books](http://media.smashingmagazine.com/wp-content/uploads/2013/04/Smashing-Book-4-sidebar-transparent-opt.png)](http://www.smashingmagazine.com/smashing-book-4-new-perspectives/?pk_campaign=sb4-sidebar)

It's done. The [Smashing Book
\#4](http://www.smashingmagazine.com/smashing-book-4-new-perspectives/?pk_campaign=sb4-sidebar),
our brand new book with smart **front-end techniques** and design
approaches. Written by respected designers and developers, neatly packed
in a gorgeous hardcover.

[![Smashing Printed
Books](http://media.smashingmagazine.com/wp-content/uploads/2013/10/smashing-library-footer-new-opt.png)](http://www.smashingmagazine.com/ebooks/?pk_campaign=sb4-sidebar)

Hungry for more content? Over 60 **eBooks** are waiting to be discovered
in our lovely [Smashing
Library](http://www.smashingmagazine.com/ebooks/?pk_campaign=sb4-sidebar).
And guess what? You can watch Smashing Conference talks there, too.

### [Smashing Job Board![Smashing Jobs](http://www.smashingmagazine.com/files/smashing-widget/v006/img/sm-jobs.png)](http://jobs.smashingmagazine.com/?pk_campaign=sm&piwik_kwd=widget)

-   -   [Web Developer - Agora Financial - (Baltimore, MD) -
    FullTime](http://feedproxy.google.com/~r/smjobs/~3/vdYZ1p6OrNc/2411067)

    Baltimore-based Independent publisher, Agora Financial, is looking
    for a highly intelligent in-house developer that loves to figure out
    complex problems and make…

-   [Sr. Front End Developer - NextCapital Group - (Chicago, IL) -
    FullTime](http://feedproxy.google.com/~r/smjobs/~3/ZfmtIztsBbc/2411045)

    NextCapital is looking for a senior front end developer to build a
    cross platform framework that will power the NextCapital digital
    advice mobile and web experience…

[View more job
openings…](http://jobs.smashingmagazine.com?pk_campaign=sm&piwik_kwd=widget)

[![Smashing Book
\#4](http://media.smashingmagazine.com/wp-content/uploads/2013/10/smashing-book-4-footer-opt.png)](http://www.smashingmagazine.com/smashing-book-4-new-perspectives/?pk_campaign=sb4-footer)

[**Smashing Book
\#4**](http://www.smashingmagazine.com/smashing-book-4-new-perspectives/?pk_campaign=sb4-footer)\
 Get our brand new Smashing Book \#4, available as print and eBook.
[Learn
more...](http://www.smashingmagazine.com/smashing-book-4-new-perspectives/?pk_campaign=sb4-footer)

[![The Smashing
Library](http://media.smashingmagazine.com/wp-content/uploads/2013/10/smashing-library-footer-new-opt.png)](https://shop.smashingmagazine.com/smashing-library-complete.html?pk_campaign=smashingmagazine-footer)

[**The Smashing
Library**](https://shop.smashingmagazine.com/smashing-library-complete.html?pk_campaign=smashingmagazine-footer)\
 Grab all published and upcoming Smashing eBooks, in one swoop. [Learn
more...](https://shop.smashingmagazine.com/smashing-library-complete.html?pk_campaign=smashingmagazine-footer)

[![Smashing
Workshops](http://media.smashingmagazine.com/wp-content/uploads/2014/02/aarron-walter-footer.jpg)](http://www.smashingmagazine.com/workshops/?pk_campaign=smashingmagazine-footer)

[**Smashing
Workshops**](http://www.smashingmagazine.com/workshops/?pk_campaign=smashingmagazine-footer)\
 Join our hands-on full-day workshops, run by experts of the industry.
Good stuff. [Learn
more...](http://www.smashingmagazine.com/workshops/?pk_campaign=smashingmagazine-footer)

*With a commitment to quality content for the design community.*\
 Founded by Vitaly Friedman and Sven Lennartz. 2006-2014.\
 Made in Germany. ✎ [Write for
us](http://www.smashingmagazine.com/write-for-us/) – [Contact
us](http://www.smashingmagazine.com/contact/) –
[Impressum](http://www.smashingmagazine.com/about/).

var
elements=["http://coding.smashingmagazine.com/wp-content/themes/smashingv4/javascripts/footnotes.min.js","http://coding.smashingmagazine.com/wp-content/themes/smashingv4/javascripts/prism.js"];var
downloadJSAtOnload=function(elements){if(toString.call(elements)!=="[object
Array]"){return false}var i,element;for(i=0;i

This markdown document has been converted from the html document located at:
http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/
