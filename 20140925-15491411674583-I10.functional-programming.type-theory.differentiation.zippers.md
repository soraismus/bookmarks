Haskell/Zippers
===============

From Wikibooks, open books for an open world

< [Haskell](/wiki/Haskell "Haskell")

![Unreviewed changes are displayed on this
page](//bits.wikimedia.org/static-1.24wmf22/extensions/FlaggedRevs/frontend/modules/img/1.png "Unreviewed changes are displayed on this page")This
page may need to be
[reviewed](/wiki/Wikibooks:REVIEW "Wikibooks:REVIEW") for quality.

Jump to: [navigation](#mw-navigation), [search](#p-search)

**Zippers**
([Solutions](/w/index.php?title=Haskell/Solutions/Zippers&action=edit&redlink=1 "Haskell/Solutions/Zippers (does not exist)"))

Contents
--------

-   [1 Theseus and the Zipper](#Theseus_and_the_Zipper)
    -   [1.1 The Labyrinth](#The_Labyrinth)
    -   [1.2 Ariadne's Zipper](#Ariadne.27s_Zipper)

-   [2 Differentiation of data types](#Differentiation_of_data_types)
    -   [2.1 Mechanical Differentiation](#Mechanical_Differentiation)
    -   [2.2 Zippers via Differentiation](#Zippers_via_Differentiation)
    -   [2.3 Differentation of Fixed
        Point](#Differentation_of_Fixed_Point)
    -   [2.4 Differentation with respect to functions of the
        argument](#Differentation_with_respect_to_functions_of_the_argument)
    -   [2.5 Zippers vs Contexts](#Zippers_vs_Contexts)
    -   [2.6 Conclusion](#Conclusion)

-   [3 Notes](#Notes)
-   [4 See Also](#See_Also)

**Advanced Haskell**

[Monoids](/wiki/Haskell/Monoids "Haskell/Monoids") [![50%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/6/62/50_percents.svg/9px-50_percents.svg.png)](/wiki/Help:Development_stages "50% developed")\
 [Applicative
Functors](/wiki/Haskell/Applicative_Functors "Haskell/Applicative Functors")
[![50%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/6/62/50_percents.svg/9px-50_percents.svg.png)](/wiki/Help:Development_stages "50% developed")\
 [Arrow
tutorial](/wiki/Haskell/Arrow_tutorial "Haskell/Arrow tutorial")\
 [Understanding
arrows](/wiki/Haskell/Understanding_arrows "Haskell/Understanding arrows")\
 [Continuation passing style
(CPS)](/wiki/Haskell/Continuation_passing_style "Haskell/Continuation passing style")\
 [Value recursion
(MonadFix)](/w/index.php?title=Haskell/MonadFix&action=edit&redlink=1 "Haskell/MonadFix (does not exist)")\
 **Zippers** [![75%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/6/62/75_percent.svg/9px-75_percent.svg.png)](/wiki/Help:Development_stages "75% developed")\
 [Mutable
objects](/wiki/Haskell/Mutable_objects "Haskell/Mutable objects") [![0%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/8/83/00_percents.svg/9px-00_percents.svg.png)](/wiki/Help:Development_stages "0% developed")\
 [Concurrency](/wiki/Haskell/Concurrency "Haskell/Concurrency") [![0%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/8/83/00_percents.svg/9px-00_percents.svg.png)](/wiki/Help:Development_stages "0% developed")

[edit this
chapter](//en.wikibooks.org/w/index.php?title=Template:Haskell_chapter/Advanced_Haskell&action=edit)

Theseus and the Zipper[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=1 "Edit section: Theseus and the Zipper")]
-------------------------------------------------------------------------------------------------------------------------------

### The Labyrinth[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=2 "Edit section: The Labyrinth")]

"Theseus, we have to do something" said Homer, chief marketing officer
of Ancient Geeks Inc.. Theseus put the Minotaur action figure™ back onto
the shelf and nodded. "Today's children are no longer interested in the
ancient myths, they prefer modern heroes like Spiderman or Sponge Bob."
*Heroes*. Theseus knew well how much he had been a hero in the labyrinth
back then on Crete^[[1]](#cite_note-1)^. But those "modern heroes" did
not even try to appear realistic. What made them so successful? Anyway,
if the pending sales problems could not be resolved, the shareholders
would certainly arrange a passage over the Styx for Ancient Geeks Inc.

"Heureka! Theseus, I have an idea: we implement your story with the
Minotaur as a computer game! What do you say?" Homer was right. There
had been several books, epic (and chart breaking) songs, a mandatory
movie trilogy and uncountable Theseus & the Minotaur™ gimmicks, but a
computer game was missing. "Perfect, then. Now, Theseus, your task is to
implement the game".

A true hero, Theseus chose Haskell as the language to implement the
company's redeeming product in. Of course, exploring the labyrinth of
the Minotaur was to become one of the game's highlights. He pondered:
"We have a two-dimensional labyrinth whose corridors can point in many
directions. Of course, we can abstract from the detailed lengths and
angles: for the purpose of finding the way out, we only need to know how
the path forks. To keep things easy, we model the labyrinth as a tree.
This way, the two branches of a fork cannot join again when walking
deeper and the player cannot go round in circles. But I think there is
enough opportunity to get lost; and this way, if the player is patient
enough, he can explore the entire labyrinth with the left-hand rule."

    data Node a = DeadEnd a
                | Passage a (Node a)
                | Fork    a (Node a) (Node a)

[![image](//upload.wikimedia.org/wikibooks/en/c/c0/Labyrinth-Tree.png)](/wiki/File:Labyrinth-Tree.png)

An example labyrinth and its representation as tree.

Theseus made the nodes of the labyrinth carry an extra parameter of type
`a`. Later on, it may hold game relevant information like the
coordinates of the spot a node designates, the ambience around it, a
list of game items that lie on the floor, or a list of monsters
wandering in that section of the labyrinth. We assume that two helper
functions

    get :: Node a -> a
    put :: a -> Node a -> Node a

retrieve and change the value of type `a` stored in the first argument
of every constructor of `Node a`.

Exercises

1.  Implement `get` and `put`. One case for `get` is\
     `get (Passage x _) = x`.
2.  To get a concrete example, write down the labyrinth shown in the
    picture as a value of type `Node (Int,Int)`. The extra parameter
    `(Int,Int)` holds the cartesian coordinates of a node.

"Mh, how to represent the player's current position in the labyrinth?
The player can explore deeper by choosing left or right branches, like
in"

     turnRight :: Node a -> Maybe (Node a)
     turnRight (Fork _ l r) = Just r
     turnRight _            = Nothing

"But replacing the current top of the labyrinth with the corresponding
sub-labyrinth this way is not an option, because he cannot go back
then." He pondered. "Ah, we can apply *Ariadne's trick with the thread*
for going back. We simply represent the player's position by the list of
branches his thread takes, the labyrinth always remains the same."

    data Branch = KeepStraightOn
                | TurnLeft
                | TurnRight
    type Thread = [Branch]

[![image](//upload.wikimedia.org/wikibooks/en/d/d2/Labyrinth-Thread.png)](/wiki/File:Labyrinth-Thread.png)

Representation of the player's position by Ariadne's thread.

"For example, a thread `[TurnRight,KeepStraightOn]` means that the
player took the right branch at the entrance and then went straight down
a `Passage` to reach its current position. With the thread, the player
can now explore the labyrinth by extending or shortening it. For
instance, the function `turnRight` extends the thread by appending the
`TurnRight` to it."

    turnRight :: Thread -> Thread
    turnRight t = t ++ [TurnRight]

"To access the extra data, i.e. the game relevant items and such, we
simply follow the thread into the labyrinth."

    retrieve :: Thread -> Node a -> a
    retrieve []                  n             = get n
    retrieve (KeepStraightOn:bs) (Passage _ n) = retrieve bs n
    retrieve (TurnLeft      :bs) (Fork _ l r)  = retrieve bs l
    retrieve (TurnRight     :bs) (Fork _ l r)  = retrieve bs r

  Exercises
  ----------------------------------------------------------------------------------------------------------------
  Write a function `update` that applies a function of type `a -> a` to the extra data at the player's position.

Theseus' satisfaction over this solution did not last long.
"Unfortunately, if we want to extend the path or go back a step, we have
to change the last element of the list. We could store the list in
reverse, but even then, we have to follow the thread again and again to
access the data in the labyrinth at the player's position. Both actions
take time proportional to the length of the thread and for large
labyrinths, this will be too long. Isn't there another way?"

### Ariadne's Zipper[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=3 "Edit section: Ariadne's Zipper")]

While Theseus was a skillful warrior, he did not train much in the art
of programming and could not find a satisfying solution. After intense
but fruitless cogitation, he decided to call his former love Ariadne to
ask her for advice. After all, it was she who had the idea with the
thread.\
 "Ariadne Consulting. What can I do for you?"\
 Our hero immediately recognized the voice.\
 "Hello Ariadne, it's Theseus."\
 An uneasy silence paused the conversation. Theseus remembered well that
he had abandoned her on the island of Naxos and knew that she would not
appreciate his call. But Ancient Geeks Inc. was on the road to Hades and
he had no choice.\
 "Uhm, darling, ... how are you?"\
 Ariadne retorted an icy response, "Mr. Theseus, the times of *darling*
are long over. What do you want?"\
 "Well, I uhm ... I need some help with a programming problem. I'm
programming a new Theseus & the Minotaur™ computer game."\
 She jeered, "Yet another artifact to glorify your 'heroic being'? And
you want me of all people to help you?"\
 "Ariadne, please, I beg of you, Ancient Geeks Inc. is on the brink of
insolvency. The game is our last hope!"\
 After a pause, she came to a decision.\
 "Fine, I will help you. But only if you transfer a substantial part of
Ancient Geeks Inc. to me. Let's say thirty percent."\
 Theseus turned pale. But what could he do? The situation was desperate
enough, so he agreed but only after negotiating Ariadne's share to a
tenth.

After Theseus told Ariadne of the labyrinth representation he had in
mind, she could immediately give advice,\
 "You need a **zipper**."\
 "Huh? What does the problem have to do with my fly?"\
 "Nothing, it's a data structure first published by Gérard
Huet^[[2]](#cite_note-2)^."\
 "Ah."\
 "More precisely, it's a purely functional way to augment tree-like data
structures like lists or binary trees with a single **focus** or
**finger** that points to a subtree inside the data structure and allows
constant time updates and lookups at the spot it points
to^[[3]](#cite_note-3)^. In our case, we want a focus on the player's
position."\
 "I know for myself that I want fast updates, but how do I code it?"\
 "Don't get impatient, you cannot solve problems by coding, you can only
solve them by thinking. The only place where we can get constant time
updates in a purely functional data structure is the topmost
node^[[4]](#cite_note-4)^^[[5]](#cite_note-5)^. So, the focus
necessarily has to be at the top. Currently, the topmost node in your
labyrinth is always the entrance, but your previous idea of replacing
the labyrinth by one of its sub-labyrinths ensures that the player's
position is at the topmost node."\
 "But then, the problem is how to go back, because all those
sub-labyrinths get lost that the player did not choose to branch into."\
 "Well, you can use my thread in order not to lose the sub-labyrinths."\
 Ariadne savored Theseus' puzzlement but quickly continued before he
could complain that he already used Ariadne's thread,\
 "The key is to *glue the lost sub-labyrinths to the thread* so that
they actually don't get lost at all. The intention is that the thread
and the current sub-labyrinth complement one another to the whole
labyrinth. With 'current' sub-labyrinth, I mean the one that the player
stands on top of. The zipper simply consists of the thread and the
current sub-labyrinth."

    type Zipper a = (Thread a, Node a)

[![image](//upload.wikimedia.org/wikibooks/en/b/b3/Labyrinth-Zipper.png)](/wiki/File:Labyrinth-Zipper.png)

The zipper is a pair of Ariadne's thread and the current sub-labyrinth
that the player stands on top. The main thread is colored red and has
sub-labyrinths attached to it, such that the whole labyrinth can be
reconstructed from the pair.

Theseus didn't say anything.\
 "You can also view the thread as a **context** in which the current
sub-labyrinth resides. Now, let's find out how to define `Thread a`. By
the way, `Thread` has to take the extra parameter `a` because it now
stores sub-labyrinths. The thread is still a simple list of branches,
but the branches are different from before."

    data Branch a  = KeepStraightOn a
                   | TurnLeft  a (Node a)
                   | TurnRight a (Node a)
    type Thread a  = [Branch a]

"Most importantly, `TurnLeft` and `TurnRight` have a sub-labyrinth glued
to them. When the player chooses say to turn right, we extend the thread
with a `TurnRight` and now attach the untaken left branch to it, so that
it doesn't get lost."\
 Theseus interrupts, "Wait, how would I implement this behavior as a
function `turnRight`? And what about the first argument of type `a` for
`TurnRight`? Ah, I see. We not only need to glue the branch that would
get lost, but also the extra data of the `Fork` because it would
otherwise get lost as well. So, we can generate a new branch by a
preliminary"

    branchRight (Fork x l r) = TurnRight x l

"Now, we have to somehow extend the existing thread with it."\
 "Indeed. The second point about the thread is that it is stored
*backwards*. To extend it, you put a new branch in front of the list. To
go back, you delete the topmost element."\
 "Aha, this makes extending and going back take only constant time, not
time proportional to the length as in my previous version. So the final
version of `turnRight` is"

    turnRight :: Zipper a -> Maybe (Zipper a)
    turnRight (t, Fork x l r) = Just (TurnRight x l : t, r)
    turnRight _               = Nothing

[![image](//upload.wikimedia.org/wikibooks/en/3/37/Labyrinth-TurnRight.png)](/wiki/File:Labyrinth-TurnRight.png)

Taking the right subtree from the entrance. Of course, the thread is
initially empty. Note that the thread runs backwards, i.e. the topmost
segment is the most recent.

"That was not too difficult. So let's continue with `keepStraightOn` for
going down a passage. This is even easier than choosing a branch as we
only need to keep the extra data:"

    keepStraightOn :: Zipper a -> Maybe (Zipper a)
    keepStraightOn (t, Passage x n) = Just (KeepStraightOn x : t, n)
    keepStraightOn _                = Nothing

[![image](//upload.wikimedia.org/wikibooks/en/f/fa/Labyrinth-KeepStraightOn.png)](/wiki/File:Labyrinth-KeepStraightOn.png)

Now going down a passage.

  Exercises
  --------------------------------
  Write the function `turnLeft`.

Pleased, he continued, "But the interesting part is to go back, of
course. Let's see..."

    back :: Zipper a -> Maybe (Zipper a)
    back ([]                   , _) = Nothing
    back (KeepStraightOn x : t , n) = Just (t, Passage x n)
    back (TurnLeft  x r    : t , l) = Just (t, Fork x l r)
    back (TurnRight x l    : t , r) = Just (t, Fork x l r)

"If the thread is empty, we're already at the entrance of the labyrinth
and cannot go back. In all other cases, we have to wind up the thread.
And thanks to the attachments to the thread, we can actually reconstruct
the sub-labyrinth we came from."\
 Ariadne remarked, "Note that a partial test for correctness is to check
that each bound variable like `x`, `l` and `r` on the left hand side
appears exactly once at the right hands side as well. So, when walking
up and down a zipper, we only redistribute data between the thread and
the current sub-labyrinth."

Exercises

1.  Now that we can navigate the zipper, code the functions `get`, `put`
    and `update` that operate on the extra data at the player's
    position.
2.  Zippers are by no means limited to the concrete example `Node a`,
    they can be constructed for all tree-like data types. Go on and
    construct a zipper for binary trees

         data Tree a = Leaf a | Bin (Tree a) (Tree a)

    Start by thinking about the possible branches `Branch a` that a
    thread can take. What do you have to glue to the thread when
    exploring the tree?

3.  Simple lists have a zipper as well.

         data List a = Empty | Cons a (List a)

    What does it look like?

4.  Write a complete game based on Theseus' labyrinth.

Heureka! That was the solution Theseus sought and Ancient Geeks Inc.
should prevail, even if partially sold to Ariadne Consulting. But one
question remained:\
 "Why is it called zipper?"\
 "Well, I would have called it 'Ariadne's pearl necklace'. But most
likely, it's called zipper because the thread is in analogy to the open
part and the sub-labyrinth is like the closed part of a zipper. Moving
around in the data structure is analogous to zipping or unzipping the
zipper."\
 "'Ariadne's pearl necklace'," he articulated disdainfully. "As if your
thread was any help back then on Crete."\
 "As if the idea with the thread were yours," she replied.\
 "Bah, I need no thread," he defied the fact that he actually did need
the thread to program the game.\
 Much to his surprise, she agreed, "Well, indeed you don't need a
thread. Another view is to literally grab the tree at the focus with
your finger and lift it up in the air. The focus will be at the top and
all other branches of the tree hang down. You only have to assign the
resulting tree a suitable algebraic data type, most likely that of the
zipper."

[![image](//upload.wikimedia.org/wikibooks/en/c/c7/Labyrinth-Finger.png)](/wiki/File:Labyrinth-Finger.png)

Grab the focus with your finger, lift it in the air and the hanging
branches will form new tree with your finger at the top, ready to be
structured by an algebraic data type.

"Ah." He didn't need Ariadne's thread but he needed Ariadne to tell him?
That was too much.\
 "Thank you, Ariadne, good bye."\
 She did not hide her smirk as he could not see it anyway through the
phone.

  Exercises
  -------------------------------------------------------------------------------------------------------------------------------------------
  Take a list, fix one element in the middle with your finger and lift the list into the air. What type can you give to the resulting tree?

\
 Half a year later, Theseus stopped in front of a shop window, defying
the cold rain that tried to creep under his buttoned up anorak. Blinking
letters announced

"Spider-Man: lost in the Web"\

- find your way through the labyrinth of threads -\
 the great computer game by Ancient Geeks Inc.

He cursed the day when he called Ariadne and sold her a part of the
company. Was it she who contrived the unfriendly takeover by WineOS
Corp., led by Ariadne's husband Dionysus? Theseus watched the raindrops
finding their way down the glass window. After the production line was
changed, nobody would produce Theseus and the Minotaur™ merchandise
anymore. He sighed. His time, the time of heroes, was over. Now came the
super-heroes.

Differentiation of data types[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=4 "Edit section: Differentiation of data types")]
---------------------------------------------------------------------------------------------------------------------------------------------

The previous section has presented the zipper, a way to augment a
tree-like data structure `Node a` with a finger that can focus on the
different subtrees. While we constructed a zipper for a particular data
structure `Node a`, the construction can be easily adapted to different
tree data structures by hand.

Exercises

Start with a ternary tree

     data Tree a = Leaf a | Node (Tree a) (Tree a) (Tree a)

and derive the corresponding `Thread a` and `Zipper a`.

### Mechanical Differentiation[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=5 "Edit section: Mechanical Differentiation")]

But there is also an entirely mechanical way to derive the zipper of any
(suitably regular) data type. Surprisingly, 'derive' is to be taken
literally, for the zipper can be obtained by the **derivative** of the
data type, a discovery first described by Conor
McBride^[[6]](#cite_note-6)^. The subsequent section is going to
explicate this truly wonderful mathematical gem.

For a systematic construction, we need to calculate with types. The
basics of structural calculations with types are outlined in a separate
chapter [Generic
Programming](/w/index.php?title=Haskell/Generic_Programming&action=edit&redlink=1 "Haskell/Generic Programming (does not exist)")
and we will heavily rely on this material.

Let's look at some examples to see what their zippers have in common and
how they hint differentiation. The type of binary tree is the fixed
point of the recursive equation

![\\mathit{Tree2} = 1 +
\\mathit{Tree2}\\times\\mathit{Tree2}](//upload.wikimedia.org/math/4/c/3/4c339f75fa51a0252bb83878c1a2069b.png).

When walking down the tree, we iteratively choose to enter the left or
the right subtree and then glue the not-entered subtree to Ariadne's
thread. Thus, the branches of our thread have the type

![\\mathit{Branch2} = \\mathit{Tree2} + \\mathit{Tree2} \\cong
2\\times\\mathit{Tree2}](//upload.wikimedia.org/math/8/4/3/843473058df1191ee7a80da4644e76da.png).

Similarly, the thread for a ternary tree

![\\mathit{Tree3} = 1 +
\\mathit{Tree3}\\times\\mathit{Tree3}\\times\\mathit{Tree3}](//upload.wikimedia.org/math/4/9/a/49a8f6cc1430bc50933330e4eee83fa5.png)

has branches of type

![\\mathit{Branch3} =
3\\times\\mathit{Tree3}\\times\\mathit{Tree3}](//upload.wikimedia.org/math/c/d/3/cd375cf6ba7a28446ecc188eb4f0e166.png)

because at every step, we can choose between three subtrees and have to
store the two subtrees we don't enter. Isn't this strikingly similar to
the derivatives ![\\frac{d}{dx} x\^2 = 2\\times
x](//upload.wikimedia.org/math/8/6/b/86b33770a90701df556d6a53b3b4cce5.png)
and ![\\frac{d}{dx} x\^3 = 3\\times
x\^2](//upload.wikimedia.org/math/7/d/7/7d759422d76e4d7446ef74ad6ddb365b.png)?

The key to the mystery is the notion of the **one-hole context** of a
data structure. Imagine a data structure parameterised over a type
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png),
like the type of trees
![\\mathit{Tree}\\,X](//upload.wikimedia.org/math/d/0/5/d059717039f0dc758868b68be60e834d.png).
If we were to remove one of the items of this type
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png)
from the structure and somehow mark the now empty position, we obtain a
structure with a marked hole. The result is called "one-hole context"
and inserting an item of type
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png)
into the hole gives back a completely filled
![\\mathit{Tree}\\,X](//upload.wikimedia.org/math/d/0/5/d059717039f0dc758868b68be60e834d.png).
The hole acts as a distinguished position, a focus. The figures
illustrate this.

[![image](//upload.wikimedia.org/wikibooks/en/a/a1/One-hole-context-Tree.png)](/wiki/File:One-hole-context-Tree.png)

Removing a value of type
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png)
from a
![\\mathit{Tree}\\,X](//upload.wikimedia.org/math/d/0/5/d059717039f0dc758868b68be60e834d.png)
leaves a hole at that position.

[![image](//upload.wikimedia.org/wikipedia/commons/e/e7/One-hole-context-plug.png)](/wiki/File:One-hole-context-plug.png)

A more abstract illustration of plugging
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png)
into a one-hole context.

Of course, we are interested in the type to give to a one-hole context,
i.e. how to represent it in Haskell. The problem is how to efficiently
mark the focus. But as we will see, finding a representation for
one-hole contexts by induction on the structure of the type we want to
take the one-hole context of automatically leads to an efficient data
type^[[7]](#cite_note-7)^. So, given a data structure ![F\\,
X](//upload.wikimedia.org/math/d/2/8/d2810115ba7f0b9c1317b866d952ee02.png)
with a functor
![F](//upload.wikimedia.org/math/8/0/0/800618943025315f869e4e1f09471012.png)
and an argument type
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png),
we want to calculate the type ![\\partial F\\,
X](//upload.wikimedia.org/math/2/0/6/2063759f2d3ea283252277e3aacdac53.png)
of one-hole contexts from the structure of
![F](//upload.wikimedia.org/math/8/0/0/800618943025315f869e4e1f09471012.png).
As our choice of notation ![\\partial
F](//upload.wikimedia.org/math/5/3/b/53b5f10611f339a3645af95fd8d5f234.png)
already reveals, the rules for constructing one-hole contexts of sums,
products and compositions are exactly Leibniz' rules for
differentiation.

One-hole context

Illustration

![(\\partial\\mathit{Const\_A})\\,X](//upload.wikimedia.org/math/5/8/b/58b97d266081e5cb85ba10f6a55286a6.png)

![=\\,0](//upload.wikimedia.org/math/3/3/6/336215e3a20037760235922dbf014be7.png)

There is no
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png)
in ![A =
\\mathit{Const\_A}\\,X](//upload.wikimedia.org/math/c/4/6/c467a12ac54a331e01e4d0a44b44f07c.png),
so the type of its one-hole contexts must be empty.

![(\\partial\\mathit{Id})\\,X](//upload.wikimedia.org/math/b/9/a/b9a1b73927e58a8714e701b27eb3026a.png)

![=\\,1](//upload.wikimedia.org/math/a/3/5/a35e07f9393903d720b2ffbe24ae141e.png)

There is only one position for items
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png)
in
![X=\\mathit{Id}\\,X](//upload.wikimedia.org/math/9/9/2/992ba81ed16f95f629b9de47849024e2.png).
Removing one
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png)
leaves no
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png)
in the result. And as there is only one position we can remove it from,
there is exactly one one-hole context for
![\\mathit{Id}\\,X](//upload.wikimedia.org/math/f/f/0/ff0bf8440a9081e62d2564b087ff4850.png).
Thus, the type of one-hole contexts is the singleton type.

![\\partial(F +
G)](//upload.wikimedia.org/math/6/4/4/644ba0b9298b7fc1b0736ffe9231ff05.png)

![=\\partial F + \\partial
G](//upload.wikimedia.org/math/5/a/5/5a5c35cd59419e655e2bd3f0d3cf8360.png)

As an element of type
![F+G](//upload.wikimedia.org/math/3/f/d/3fddfb402c7a305b7afa213b93476918.png)
is either of type
![F](//upload.wikimedia.org/math/8/0/0/800618943025315f869e4e1f09471012.png)
or of type
![G](//upload.wikimedia.org/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png),
a one-hole context is also either ![\\partial
F](//upload.wikimedia.org/math/5/3/b/53b5f10611f339a3645af95fd8d5f234.png)
or ![\\partial
G](//upload.wikimedia.org/math/8/f/7/8f7e442e30f370c4d1087eea424fdc5a.png).

![\\partial (F \\times
G)](//upload.wikimedia.org/math/6/b/a/6ba4f5de720b76248a6e76d294cfc049.png)

![=F \\times \\partial G + \\partial F \\times
G](//upload.wikimedia.org/math/1/6/e/16e04654b3e13c8f9e0b4115d0d96531.png)

[![One-hole-context-product.png](//upload.wikimedia.org/wikibooks/en/2/20/One-hole-context-product.png)](/wiki/File:One-hole-context-product.png)\

The hole in a one-hole context of a pair is either in the first or in
the second component.

![\\partial (F \\circ
G)](//upload.wikimedia.org/math/d/5/3/d5375911960246d22006d45986841ffa.png)

![=(\\partial F \\circ G) \\times \\partial
G](//upload.wikimedia.org/math/5/e/1/5e103d97862eddf3dbfc18952469875d.png)

[![One-hole-context-composition.png](//upload.wikimedia.org/wikibooks/en/6/61/One-hole-context-composition.png)](/wiki/File:One-hole-context-composition.png)\

**Chain rule**. The hole in a composition arises by making a hole in the
enclosing structure and fitting the enclosed structure in.

Of course, the function `plug` that fills a hole has the type
![(\\partial F\\,X) \\times X \\to
F\\,X](//upload.wikimedia.org/math/3/2/9/329c46acde7672a22691c5165c798b5f.png).

So far, the syntax
![\\partial](//upload.wikimedia.org/math/5/2/c/52cc749bb1c32abf1dccf613bd847a6e.png)
denotes the differentiation of functors, i.e. of a kind of type
functions with one argument. But there is also a handy expression
oriented notation
**![\\partial\_X](//upload.wikimedia.org/math/3/a/a/3aa92d7779443ae23011ecb0788cc3b6.png)**
slightly more suitable for calculation. The subscript indicates the
variable with respect to which we want to differentiate. In general, we
have

![(\\partial
F)\\,X=\\partial\_X(F\\,X)](//upload.wikimedia.org/math/b/b/5/bb5eb23e965b629f8847142cd80b2046.png)

An example is

![\\partial(\\mathit{Id}\\times\\mathit{Id})\\,X=\\partial\_X(X\\times
X)=1\\times X + X\\times 1 \\cong 2\\times
X](//upload.wikimedia.org/math/7/b/f/7bfd5c354c433dff4fda1515753dab9b.png)

Of course,
![\\partial\_X](//upload.wikimedia.org/math/3/a/a/3aa92d7779443ae23011ecb0788cc3b6.png)
is just point-wise whereas
![\\partial](//upload.wikimedia.org/math/5/2/c/52cc749bb1c32abf1dccf613bd847a6e.png)
is point-free style.

Exercises

1.  Rewrite some rules in point-wise style. For example, the left hand
    side of the product rule becomes ![\\partial\_X(F\\,X \\times G\\,X)
    = \\dots
    ](//upload.wikimedia.org/math/d/e/4/de4aec8e9d03d3d5a0b8716e8536f5c9.png).
2.  To get familiar with one-hole contexts, differentiate the product
    ![X\^n := X\\times X\\times \\dots\\times
    X](//upload.wikimedia.org/math/a/d/6/ad6c7ee276df1e80fa7c7e162876b58a.png)
    of exactly
    ![n](//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png)
    factors formally and convince yourself that the result is indeed the
    corresponding one-hole context.
3.  Of course, one-hole contexts are useless if we cannot plug values of
    type
    ![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png)
    back into them. Write the `plug` functions corresponding to the five
    rules.
4.  Formulate the **chain rule** for **two variables** and prove that it
    yields one-hole contexts. You can do this by viewing a bifunctor
    ![F\\,X\\,Y](//upload.wikimedia.org/math/0/e/9/0e9bf2390228d85c148f8fba1d3825b5.png)
    as an normal functor in the pair
    ![(X,Y)](//upload.wikimedia.org/math/f/0/0/f00acce613318349cb04ab296486fc11.png).
    Of course, you may need a handy notation for partial derivatives of
    bifunctors in point-free style.

### Zippers via Differentiation[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=6 "Edit section: Zippers via Differentiation")]

The above rules enable us to construct **zipper**s for recursive data
types ![\\mu F := \\mu
X.\\,F\\,X](//upload.wikimedia.org/math/8/2/c/82cd9e62c992b0b11a99b7e28251763b.png)
where
![F](//upload.wikimedia.org/math/8/0/0/800618943025315f869e4e1f09471012.png)
is a polynomial functor. A zipper is a focus on a particular subtree,
i.e. substructure of type ![\\mu
F](//upload.wikimedia.org/math/6/5/5/6553eeb26801f18972b09585583658a5.png)
inside a large tree of the same type. As in the previous chapter, it can
be represented by the subtree we want to focus at and the thread, that
is the context in which the subtree resides

![\\mathit{Zipper}\_F = \\mu
F\\times\\mathit{Context}\_F](//upload.wikimedia.org/math/5/9/a/59a3f3c6818a8ef199185e47eb37a3f8.png).

Now, the context is a series of steps each of which chooses a particular
subtree ![\\mu
F](//upload.wikimedia.org/math/6/5/5/6553eeb26801f18972b09585583658a5.png)
among those in ![F\\,\\mu
F](//upload.wikimedia.org/math/a/8/c/a8c26f83188354feb59091c1daea8644.png).
Thus, the unchosen subtrees are collected together by the one-hole
context ![\\partial F\\,(\\mu
F)](//upload.wikimedia.org/math/6/5/0/6501aa80dce5fcf8e55628d7ded3a60c.png).
The hole of this context comes from removing the subtree we've chosen to
enter. Putting things together, we have

![\\mathit{Context}\_F = \\mathit{List}\\, (\\partial F\\,(\\mu
F))](//upload.wikimedia.org/math/4/8/b/48b47d3f75bf5166808a36caee1696c3.png).

or equivalently

![\\mathit{Context}\_F = 1 + \\partial F\\,(\\mu F) \\times
\\mathit{Context}\_F](//upload.wikimedia.org/math/3/a/6/3a6c8a8e1fae0ce816b79f0880828859.png).

To illustrate how a concrete calculation proceeds, let's systematically
construct the zipper for our labyrinth data type

    data Node a = DeadEnd a
                | Passage a (Node a)
                | Fork a (Node a) (Node a)

This recursive type is the fixed point

![\\mathit{Node}\\,A = \\mu
X.\\,\\mathit{NodeF}\_A\\,X](//upload.wikimedia.org/math/9/b/e/9bed050a00ec20ff8a617152b4934d74.png)

of the functor

![\\mathit{NodeF}\_A\\,X = A + A\\times X + A\\times X\\times
X](//upload.wikimedia.org/math/0/3/7/0374a7fa395c291ec3e1f5f367f17270.png).

In other words, we have

![\\mathit{Node}\\,A \\cong \\mathit{NodeF}\_A\\,(\\mathit{Node}\\,A)
\\cong A + A\\times \\mathit{Node}\\,A + A\\times
\\mathit{Node}\\,A\\times
\\mathit{Node}\\,A](//upload.wikimedia.org/math/0/3/5/035add80419eda62b8ddee9368e93181.png).

The derivative reads

![\\partial\_X(\\mathit{NodeF}\_A\\,X) \\cong A + 2\\times A\\times
X](//upload.wikimedia.org/math/8/b/6/8b66e404ed09ab51ec75311d7a860361.png)

and we get

![\\partial \\mathit{NodeF}\_A\\,(\\mathit{Node}\\,A) \\cong A +
2\\times A\\times
\\mathit{Node}\\,A](//upload.wikimedia.org/math/f/e/a/fea7d28003aadf044e9dc17846f7ad26.png).

Thus, the context reads

![\\mathit{Context}\_\\mathit{NodeF} \\cong \\mathit{List}\\,(\\partial
\\mathit{NodeF}\_A\\,(\\mathit{Node}\\,A)) \\cong \\mathit{List}\\,(A +
2\\times A\\times
(\\mathit{Node}\\,A))](//upload.wikimedia.org/math/3/d/f/3df8ac34a4aef16f972c19133de4046b.png).

Comparing with

    data Branch a  = KeepStraightOn a
                   | TurnLeft  a (Node a)
                   | TurnRight a (Node a)
    type Thread a  = [Branch a]

we see that both are exactly the same as expected!

Exercises

1.  Redo the zipper for a ternary tree, but with differentiation this
    time.
2.  Construct the zipper for a list.
3.  Rhetorical question concerning the previous exercise: what's the
    difference between a list and a stack?

### Differentation of Fixed Point[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=7 "Edit section: Differentation of Fixed Point")]

There is more to data types than sums and products, we also have a fixed
point operator with no direct correspondence in calculus. Consequently,
the table is missing a rule of differentiation, namely how to
differentiate fixed points ![\\mu F\\,X = \\mu
Y.\\,F\\,X\\,Y](//upload.wikimedia.org/math/2/e/2/2e23b259988c2ebf527c7c0df5c04700.png):

![\\partial\_X(\\mu F\\,X) =
{?}](//upload.wikimedia.org/math/6/c/5/6c5a15dfa64c9a83d77ae908c62aa8d0.png).

As its formulation involves the chain rule in two variables, we delegate
it to the exercises. Instead, we will calculate it for our concrete
example type
![\\mathit{Node}\\,A](//upload.wikimedia.org/math/4/d/8/4d8b8d5a1883d2e2062566b4c4959709.png):

![\\begin{matrix} \\partial\_A(\\mathit{Node}\\,A) &=& \\partial\_A(A +
A\\times\\mathit{Node}\\,A + A\\times
\\mathit{Node}\\,A\\times\\mathit{Node}\\,A)\\\\ &\\cong& 1 +
\\mathit{Node}\\,A + \\mathit{Node}\\,A\\times\\mathit{Node}\\,A\\\\ &&+
\\partial\_A(\\mathit{Node}\\,A)\\times(A + 2\\times
A\\times\\mathit{Node}\\,A)
.\\end{matrix}](//upload.wikimedia.org/math/8/9/4/89440bc823e90fe75697f65021e07195.png)

Of course, expanding
![\\partial\_A(\\mathit{Node}\\,A)](//upload.wikimedia.org/math/e/3/4/e34267dcad3d823f65037b59896fed24.png)
further is of no use, but we can see this as a fixed point equation and
arrive at

![\\partial\_A(\\mathit{Node}\\,A) = \\mu X.\\,T\\,A + S\\,A \\times
X](//upload.wikimedia.org/math/a/3/1/a3188f9699b35564b6dad873d874e21b.png)

with the abbreviations

![T\\,A = 1 + \\mathit{Node}\\,A +
\\mathit{Node}\\,A\\times\\mathit{Node}\\,A](//upload.wikimedia.org/math/f/5/1/f51edfe4feb161db6c231c0006f77a19.png)

and

![S\\,A = A + 2\\times
A\\times\\mathit{Node}\\,A](//upload.wikimedia.org/math/4/b/8/4b8a4a199200156ec64621249de6d211.png).

The recursive type is like a list with element types
![S\\,A](//upload.wikimedia.org/math/8/d/c/8dc99a4d85983dd07310dbc8d8373f61.png),
only that the empty list is replaced by a base case of type
![T\\,A](//upload.wikimedia.org/math/3/9/6/396c89e0eb5e59493afae14a46d88437.png).
But given that the list is finite, we can replace the base case with
![1](//upload.wikimedia.org/math/c/4/c/c4ca4238a0b923820dcc509a6f75849b.png)
and pull
![T\\,A](//upload.wikimedia.org/math/3/9/6/396c89e0eb5e59493afae14a46d88437.png)
out of the list:

![\\partial\_A(\\mathit{Node}\\,A) \\cong T\\,A \\times (\\mu
X.\\,1+S\\,A\\times X) =
T\\,A\\times\\mathit{List}\\,(S\\,A)](//upload.wikimedia.org/math/c/5/9/c597b9d854eb6dc4439ed820af9c3899.png).

Comparing with the zipper we derived in the last paragraph, we see that
the list type is our context

![\\mathit{List}\\,(S\\,A) \\cong
\\mathit{Context}\_{\\mathit{NodeF}}](//upload.wikimedia.org/math/1/a/9/1a9e9b2ce621376de985f12d0944da86.png)

and that

![A\\times T\\,A \\cong
\\mathit{Node}\\,A](//upload.wikimedia.org/math/b/7/8/b785229d642ed556ab1287d12ed35893.png).

In the end, we have

![\\mathit{Zipper}\_{\\mathit{NodeF}} \\cong
\\partial\_A(\\mathit{Node}\\,A) \\times
A](//upload.wikimedia.org/math/5/b/b/5bb1bf1ead0fda8eb6cd54468c4f73af.png).

Thus, differentiating our concrete example
![\\mathit{Node}\\,A](//upload.wikimedia.org/math/4/d/8/4d8b8d5a1883d2e2062566b4c4959709.png)
with respect to
![A](//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png)
yields the zipper up to an
![A](//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png)!

Exercises

1.  Use the chain rule in two variables to formulate a rule for the
    differentiation of a fixed point.
2.  Maybe you know that there are inductive
    (![\\mu](//upload.wikimedia.org/math/b/7/2/b72bb92668acc30b4474caff40274044.png))
    and coinductive fixed points
    (![\\nu](//upload.wikimedia.org/math/7/3/6/7368318dd3647eb6bbf6afaf6d26c48d.png)).
    What's the rule for coinductive fixed points?

### Differentation with respect to functions of the argument[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=8 "Edit section: Differentation with respect to functions of the argument")]

When finding the type of a one-hole context one does d f(x)/d x. It is
entirely possible to solve expressions like d f(x)/d g(x). For example,
solving d x\^4 / d x\^2 gives 2x\^2 , a two-hole context of a 4-tuple.
The derivation is as follows let u=x\^2 d x\^4 / d x\^2 = d u\^2 /d u =
2u = 2 x\^2 .

### Zippers vs Contexts[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=9 "Edit section: Zippers vs Contexts")]

In general however, zippers and one-hole contexts denote different
things. The zipper is a focus on arbitrary subtrees whereas a one-hole
context can only focus on the argument of a type constructor. Take for
example the data type

     data Tree a = Leaf a | Bin (Tree a) (Tree a)

which is the fixed point

![\\mathit{Tree}\\,A = \\mu X.\\,A+X\\times
X](//upload.wikimedia.org/math/5/5/d/55da41fa480db3d6724aa018d49e4789.png).

The zipper can focus on subtrees whose top is `Bin` or `Leaf` but the
hole of one-hole context of
![\\mathit{Tree}\\,A](//upload.wikimedia.org/math/7/8/c/78c726151d3e0b7595c208eda234dd38.png)
may only focus a `Leaf`s because this is where the items of type
![A](//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png)
reside. The derivative of
![\\mathit{Node}\\,A](//upload.wikimedia.org/math/4/d/8/4d8b8d5a1883d2e2062566b4c4959709.png)
only turned out to be the zipper because every top of a subtree is
always decorated with an
![A](//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png).

Exercises

1.  Surprisingly, ![\\partial\_A(\\mathit{Tree}\\,A)\\times
    A](//upload.wikimedia.org/math/7/2/d/72dbdc558fa28d000f81116a771e0f89.png)
    and the zipper for
    ![\\mathit{Tree}\\,A](//upload.wikimedia.org/math/7/8/c/78c726151d3e0b7595c208eda234dd38.png)
    again turn out to be the same type. Doing the calculation is not
    difficult but can you give a reason why this has to be the case?
2.  Prove that the zipper construction for ![\\mu
    F](//upload.wikimedia.org/math/6/5/5/6553eeb26801f18972b09585583658a5.png)
    can be obtained by introducing an auxiliary variable
    ![Y](//upload.wikimedia.org/math/5/7/c/57cec4137b614c87cb4e24a3d003a3e0.png),
    differentiating ![\\mu X.\\, Y\\times
    F\\,X](//upload.wikimedia.org/math/2/f/4/2f4fcbf05b540ea689116d225460aeeb.png)
    with respect to it and re-substituting
    ![Y=1](//upload.wikimedia.org/math/7/0/8/70834fa19d2b7e7068b7403f87acf573.png).
    Why does this work?
3.  Find a type
    ![G\\,A](//upload.wikimedia.org/math/c/2/5/c258dcb615ca0f64977e121dc133d4bd.png)
    whose zipper is different from the one-hole context.

### Conclusion[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=10 "Edit section: Conclusion")]

We close this section by asking how it may happen that rules from
calculus appear in a discrete setting. Currently, nobody knows. But at
least, there is a discrete notion of **linear**, namely in the sense of
"exactly once". The key feature of the function that plugs an item of
type
![X](//upload.wikimedia.org/math/0/2/1/02129bb861061d1a052c592e2dc6b383.png)
into the hole of a one-hole context is the fact that the item is used
exactly once, i.e. linearly. We may think of the plugging map as having
type

![\\partial\_X F\\,X \\to (X \\multimap
F\\,X)](//upload.wikimedia.org/math/b/1/2/b12fa66b417b79f6b61abcb0694e271c.png)

where ![A \\multimap
B](//upload.wikimedia.org/math/e/1/d/e1db4d5ec6ed1ea29c3f94c110219b09.png)
denotes a linear function, one that does not duplicate or ignore its
argument, as in linear logic. In a sense, the one-hole context is a
representation of the function space ![X \\multimap
F\\,X](//upload.wikimedia.org/math/7/b/2/7b28a2bdf47ea9c01b1fcaf4567b198f.png),
which can be thought of being a linear approximation to ![X\\to
F\\,X](//upload.wikimedia.org/math/8/c/f/8cff78ac0e34531846f00f745b08d313.png).

\

Notes[[edit](/w/index.php?title=Template:Haskell/NotesSection&action=edit&section=T-1 "Template:Haskell/NotesSection")]
-----------------------------------------------------------------------------------------------------------------------

1.  [↑](#cite_ref-1) Ian Stewart. *The true story of how Theseus found
    his way out of the labyrinth*. Scientific American, February 1991,
    page 137.
2.  [↑](#cite_ref-2) Gérard Huet. *The Zipper*. Journal of Functional
    Programming, 7 (5), Sept 1997, pp. 549--554.
    [PDF](http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf)
3.  [↑](#cite_ref-3) Note the notion of *zipper* as coined by Gérard
    Huet also allows to replace whole subtrees even if there is no extra
    data associated with them. In the case of our labyrinth, this is
    irrelevant. We will come back to this in the section
    [Differentiation of data types](#Differentiation_of_data_types).
4.  [↑](#cite_ref-4) Of course, the second topmost node or any other
    node at most a constant number of links away from the top will do as
    well.
5.  [↑](#cite_ref-5) Note that changing the whole data structure as
    opposed to updating the data at a node can be achieved in amortized
    constant time even if more nodes than just the top node is affected.
    An example is incrementing a number in binary representation. While
    incrementing say `111..11` must touch all digits to yield
    `1000..00`, the increment function nevertheless runs in constant
    amortized time (but not in constant worst case time).
6.  [↑](#cite_ref-6) Conor Mc Bride. *The Derivative of a Regular Type
    is its Type of One-Hole Contexts*. Available online.
    [PDF](http://strictlypositive.org/diff.pdf)
7.  [↑](#cite_ref-7) This phenomenon already shows up with generic
    tries.

\

See Also[[edit](/w/index.php?title=Haskell/Zippers&action=edit&section=11 "Edit section: See Also")]
----------------------------------------------------------------------------------------------------

![Wikipedia-logo.png](//upload.wikimedia.org/wikipedia/commons/thumb/6/63/Wikipedia-logo.png/40px-Wikipedia-logo.png)

[Wikipedia](//en.wikipedia.org/wiki/ "w:") has related information at
[***Zipper (data
structure)***](//en.wikipedia.org/wiki/Zipper_(data_structure))

-   [Zipper](http://www.haskell.org/haskellwiki/Zipper) on the
    haskell.org wiki
-   [Generic Zipper and its
    applications](http://okmij.org/ftp/Computation/Continuations.html#zipper)
-   [Zipper-based file
    server/OS](http://okmij.org/ftp/Computation/Continuations.html#zipper-fs)
-   [Scrap Your Zippers: A Generic Zipper for Heterogeneous
    Types](http://www.michaeldadams.org/papers/scrap_your_zippers/)

**Zippers**

[Solutions to
exercises](/w/index.php?title=Haskell/Solutions/Zippers&action=edit&redlink=1 "Haskell/Solutions/Zippers (does not exist)")

**Advanced Haskell**

[Monoids](/wiki/Haskell/Monoids "Haskell/Monoids") [![50%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/6/62/50_percents.svg/9px-50_percents.svg.png)](/wiki/Help:Development_stages "50% developed")
\>\> [Applicative
Functors](/wiki/Haskell/Applicative_Functors "Haskell/Applicative Functors")
[![50%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/6/62/50_percents.svg/9px-50_percents.svg.png)](/wiki/Help:Development_stages "50% developed")
\>\> [Arrow
tutorial](/wiki/Haskell/Arrow_tutorial "Haskell/Arrow tutorial") \>\>
[Understanding
arrows](/wiki/Haskell/Understanding_arrows "Haskell/Understanding arrows")
\>\> [Continuation passing style
(CPS)](/wiki/Haskell/Continuation_passing_style "Haskell/Continuation passing style")
\>\> [Value recursion
(MonadFix)](/w/index.php?title=Haskell/MonadFix&action=edit&redlink=1 "Haskell/MonadFix (does not exist)")
\>\> **Zippers** [![75%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/6/62/75_percent.svg/9px-75_percent.svg.png)](/wiki/Help:Development_stages "75% developed")
\>\> [Mutable
objects](/wiki/Haskell/Mutable_objects "Haskell/Mutable objects") [![0%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/8/83/00_percents.svg/9px-00_percents.svg.png)](/wiki/Help:Development_stages "0% developed")
\>\> [Concurrency](/wiki/Haskell/Concurrency "Haskell/Concurrency")
[![0%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/8/83/00_percents.svg/9px-00_percents.svg.png)](/wiki/Help:Development_stages "0% developed")

[edit this
chapter](//en.wikibooks.org/w/index.php?title=Template:Haskell_chapter/Advanced_Haskell&action=edit)

\

**[Haskell](/wiki/Haskell "Haskell")**

[Haskell Basics](/wiki/Haskell/Haskell_Basics "Haskell/Haskell Basics")
\>\> [Elementary
Haskell](/wiki/Haskell/Elementary_Haskell "Haskell/Elementary Haskell")
\>\> [Intermediate
Haskell](/wiki/Haskell/Intermediate_Haskell "Haskell/Intermediate Haskell")
\>\> [Monads](/wiki/Haskell/Monads "Haskell/Monads")\
 [Advanced
Haskell](/wiki/Haskell/Advanced_Haskell "Haskell/Advanced Haskell") \>\>
[Fun with Types](/wiki/Haskell/Fun_with_Types "Haskell/Fun with Types")
\>\> [Wider Theory](/wiki/Haskell/Wider_Theory "Haskell/Wider Theory")
\>\> [Haskell
Performance](/wiki/Haskell/Haskell_Performance "Haskell/Haskell Performance")\

* * * * *

[Libraries
Reference](/wiki/Haskell/Libraries_Reference "Haskell/Libraries Reference")
\>\> [General
Practices](/wiki/Haskell/General_Practices "Haskell/General Practices")
\>\> [Specialised
Tasks](/wiki/Haskell/Specialised_Tasks "Haskell/Specialised Tasks")

[edit book
structure](//en.wikibooks.org/w/index.php?title=Template:Haskell_navigation&action=edit)

![image](//en.wikibooks.org/wiki/Special:CentralAutoLogin/start?type=1x1)

Retrieved from
"[http://en.wikibooks.org/w/index.php?title=Haskell/Zippers&oldid=2386694](http://en.wikibooks.org/w/index.php?title=Haskell/Zippers&oldid=2386694)"

[Category](/wiki/Special:Categories "Special:Categories"):

-   [Haskell](/wiki/Category:Haskell "Category:Haskell")

Navigation menu
---------------

### Personal tools

-   [Create
    account](/w/index.php?title=Special:UserLogin&returnto=Haskell%2FZippers&type=signup)
-   [Log
    in](/w/index.php?title=Special:UserLogin&returnto=Haskell%2FZippers "You are encouraged to log in; however, it is not mandatory [o]")

### Namespaces

-   [Book](/wiki/Haskell/Zippers "View the content page [c]")
-   [Discussion](/wiki/Talk:Haskell/Zippers "Discussion about the content page [t]")

### Variants[](#)

### Views

-   [Read](/wiki/Haskell/Zippers)
-   [Edit](/w/index.php?title=Haskell/Zippers&action=edit "You can edit this page. Please use the preview button before saving [e]")
-   [View
    history](/w/index.php?title=Haskell/Zippers&action=history "Past revisions of this page [h]")

### More[](#)

### Search

[](/wiki/Main_Page "Visit the main page")

### Navigation

-   [Main Page](/wiki/Main_Page "Visit the main page [z]")
-   [Help](https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents "Find help on how to use and edit Wikibooks")
-   [Browse
    wiki](/wiki/Wikibooks:Card_Catalog_Office "Check out what Wikibooks has to offer")
-   [Cookbook](/wiki/Cookbook:Table_of_Contents "Learn recipes from around the world")
-   [Wikijunior](/wiki/Wikijunior "Books for children")
-   [Featured
    books](/wiki/Wikibooks:Featured_books "The best of Wikibooks")
-   [Recent
    changes](/wiki/Special:RecentChanges "A list of recent changes in the wiki [r]")
-   [Donations](//donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&utm_medium=sidebar&utm_campaign=C13_en.wikibooks.org&uselang=en "Support Wikibooks")
-   [Random book](/wiki/Special:RandomRootpage)
-   [Using Wikibooks](/wiki/Using_Wikibooks)

### Community

-   [Reading
    room](/wiki/Wikibooks:Reading_room "Discuss Wikibooks-related questions and concerns with others")
-   [Community
    portal](/wiki/Wikibooks:Community_Portal "Find your way around the Wikibooks community")
-   [Bulletin
    Board](/wiki/Wikibooks:Reading_room/Bulletin_Board "Important community news")
-   [Help
    out!](/wiki/Wikibooks:Maintenance "Frequent tasks that you can help with")
-   [Policies and
    guidelines](/wiki/Wikibooks:Policies_and_guidelines "Pages detailing important rules and procedures")
-   [Contact
    us](/wiki/Wikibooks:Contact_us "Alternative methods of communication")

### Tools

-   [What links
    here](/wiki/Special:WhatLinksHere/Haskell/Zippers "A list of all wiki pages that link here [j]")
-   [Related
    changes](/wiki/Special:RecentChangesLinked/Haskell/Zippers "Recent changes in pages linked from this page [k]")
-   [Upload
    file](//commons.wikimedia.org/wiki/Special:UploadWizard "Upload files [u]")
-   [Special
    pages](/wiki/Special:SpecialPages "A list of all special pages [q]")
-   [Permanent
    link](/w/index.php?title=Haskell/Zippers&oldid=2386694 "Permanent link to this revision of the page")
-   [Page information](/w/index.php?title=Haskell/Zippers&action=info)
-   [Cite this
    page](/w/index.php?title=Special:Cite&page=Haskell%2FZippers&id=2386694 "Information on how to cite this page")

### In other languages

-   [](#)

### Sister projects

-   [Wikipedia](//en.wikipedia.org/wiki/Main_Page)
-   [Wikiversity](//en.wikiversity.org/wiki/Wikiversity:Main_Page)
-   [Wiktionary](//en.wiktionary.org/wiki/Wiktionary:Main_Page)
-   [Wikiquote](//en.wikiquote.org/wiki/Main_Page)
-   [Wikisource](//en.wikisource.org/wiki/Main_Page)
-   [Wikinews](//en.wikinews.org/wiki/Main_Page)
-   [Wikivoyage](//en.wikivoyage.org/wiki/Main_Page)
-   [Commons](//commons.wikimedia.org/wiki/Main_Page)
-   [Wikidata](//www.wikidata.org/wiki/Wikidata:Main_Page)

### Print/export

-   [Create a
    collection](/w/index.php?title=Special:Book&bookcmd=book_creator&referer=Haskell%2FZippers)
-   [Download as
    PDF](/w/index.php?title=Special:Book&bookcmd=render_article&arttitle=Haskell%2FZippers&oldid=2386694&writer=rl)
-   [Printable
    version](/w/index.php?title=Haskell/Zippers&printable=yes "Printable version of this page [p]")

-   This page was last modified on 3 August 2012, at 00:48.
-   Text is available under the [Creative Commons Attribution-ShareAlike
    License.](//creativecommons.org/licenses/by-sa/3.0/); additional
    terms may apply. By using this site, you agree to the [Terms of
    Use](//wikimediafoundation.org/wiki/Terms_of_Use) and [Privacy
    Policy.](//wikimediafoundation.org/wiki/Privacy_policy)

-   [Privacy
    policy](//wikimediafoundation.org/wiki/Privacy_policy "wikimedia:Privacy policy")
-   [About Wikibooks](/wiki/Wikibooks:Welcome "Wikibooks:Welcome")
-   [Disclaimers](/wiki/Wikibooks:General_disclaimer "Wikibooks:General disclaimer")
-   [Developers](https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute)
-   [Mobile
    view](//en.m.wikibooks.org/w/index.php?title=Haskell/Zippers&mobileaction=toggle_view_mobile)

-   [![Wikimedia
    Foundation](//bits.wikimedia.org/images/wikimedia-button.png)](//wikimediafoundation.org/)
-   [![Powered by
    MediaWiki](//bits.wikimedia.org/static-1.24wmf22/resources/assets/poweredby_mediawiki_88x31.png)](//www.mediawiki.org/)


This markdown document has been converted from the html document located at:
https://en.wikibooks.org/wiki/Haskell/Zippers
