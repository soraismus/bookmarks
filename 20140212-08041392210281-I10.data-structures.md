B-tree
======

From Wikipedia, the free encyclopedia

Jump to: [navigation](#mw-navigation), [search](#p-search)

Not to be confused with [Binary tree](/wiki/Binary_tree "Binary tree").

B-tree

[Type](/wiki/List_of_data_structures "List of data structures")

[Tree](/wiki/Tree_(data_structure) "Tree (data structure)")

Invented

1972

Invented by

[Rudolf Bayer](/wiki/Rudolf_Bayer "Rudolf Bayer"), [Edward M.
McCreight](/wiki/Edward_M._McCreight "Edward M. McCreight")

[Time complexity](/wiki/Time_complexity "Time complexity")\
 in [big O notation](/wiki/Big_O_notation "Big O notation")

Average

Worst case

Space

O(*n*)

O(*n*)

Search

O(log *n*)

O(log *n*)

Insert

O(log *n*)

O(log *n*)

Delete

O(log *n*)

O(log *n*)

In [computer science](/wiki/Computer_science "Computer science"), a
**B-tree** is a [tree data
structure](/wiki/Tree_data_structure "Tree data structure") that keeps
data sorted and allows searches, sequential access, insertions, and
deletions in [logarithmic
time](/wiki/Logarithmic_time "Logarithmic time"). The B-tree is a
generalization of a [binary search
tree](/wiki/Binary_search_tree "Binary search tree") in that a node can
have more than two children ([Comer 1979](#CITEREFComer1979), p. 123).
Unlike [self-balancing binary search
trees](/wiki/Self-balancing_binary_search_tree "Self-balancing binary search tree"),
the B-tree is optimized for systems that read and write large blocks of
data. It is commonly used in [databases](/wiki/Database "Database") and
[filesystems](/wiki/Filesystem "Filesystem").

Contents
--------

-   [1 Overview](#Overview)
    -   [1.1 Variants](#Variants)
    -   [1.2 Etymology unknown](#Etymology_unknown)

-   [2 The database problem](#The_database_problem)
    -   [2.1 Time to search a sorted
        file](#Time_to_search_a_sorted_file)
    -   [2.2 An index speeds the search](#An_index_speeds_the_search)
    -   [2.3 Insertions and deletions cause
        trouble](#Insertions_and_deletions_cause_trouble)
    -   [2.4 The B-tree uses all those
        ideas](#The_B-tree_uses_all_those_ideas)

-   [3 Technical description](#Technical_description)
    -   [3.1 Terminology](#Terminology)
    -   [3.2 Definition](#Definition)

-   [4 Best case and worst case
    heights](#Best_case_and_worst_case_heights)
-   [5 Algorithms](#Algorithms)
    -   [5.1 Search](#Search)
    -   [5.2 Insertion](#Insertion)
    -   [5.3 Deletion](#Deletion)
        -   [5.3.1 Deletion from a leaf
            node](#Deletion_from_a_leaf_node)
        -   [5.3.2 Deletion from an internal
            node](#Deletion_from_an_internal_node)
        -   [5.3.3 Rebalancing after
            deletion](#Rebalancing_after_deletion)

    -   [5.4 Sequential access](#Sequential_access)
    -   [5.5 Initial construction](#Initial_construction)

-   [6 In filesystems](#In_filesystems)
-   [7 Variations](#Variations)
    -   [7.1 Access concurrency](#Access_concurrency)

-   [8 See also](#See_also)
-   [9 Notes](#Notes)
-   [10 References](#References)
    -   [10.1 Original papers](#Original_papers)

-   [11 External links](#External_links)

Overview[[edit](/w/index.php?title=B-tree&action=edit&section=1 "Edit section: Overview")]
------------------------------------------------------------------------------------------

[![image](//upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/400px-B-tree.svg.png)](/wiki/File:B-tree.svg)

[![image](//bits.wikimedia.org/static-1.23wmf12/skins/common/images/magnify-clip.png)](/wiki/File:B-tree.svg "Enlarge")

A B-tree of order 2 ([Bayer & McCreight
1972](#CITEREFBayerMcCreight1972)) or order 5 ([Knuth
1998](#CITEREFKnuth1998)).

In B-trees, internal ([non-leaf](/wiki/Leaf_node "Leaf node")) nodes can
have a variable number of child nodes within some pre-defined range.
When data is inserted or removed from a node, its number of child nodes
changes. In order to maintain the pre-defined range, internal nodes may
be joined or split. Because a range of child nodes is permitted, B-trees
do not need re-balancing as frequently as other self-balancing search
trees, but may waste some space, since nodes are not entirely full. The
lower and upper bounds on the number of child nodes are typically fixed
for a particular implementation. For example, in a [2-3
B-tree](/wiki/2-3_tree "2-3 tree") (often simply referred to as a **2-3
tree**), each internal node may have only 2 or 3 child nodes.

Each internal node of a B-tree will contain a number of keys. The keys
act as separation values which divide its
[subtrees](/wiki/Subtree "Subtree"). For example, if an internal node
has 3 child nodes (or subtrees) then it must have 2 keys: *a*~1~ and
*a*~2~. All values in the leftmost subtree will be less than *a*~1~, all
values in the middle subtree will be between *a*~1~ and *a*~2~, and all
values in the rightmost subtree will be greater than *a*~2~.

Usually, the number of keys is chosen to vary between
![d](//upload.wikimedia.org/math/8/2/7/8277e0910d750195b448797616e091ad.png)
and
![2d](//upload.wikimedia.org/math/c/3/0/c309f0daf5910cf7ac2038ce9520448a.png),
where
![d](//upload.wikimedia.org/math/8/2/7/8277e0910d750195b448797616e091ad.png)
is the minimum number of keys, and
![d+1](//upload.wikimedia.org/math/7/6/5/765f09f9b6abc99f555c131a5475b9db.png)
is the minimum
[degree](/wiki/Outdegree#Indegree_and_outdegree "Outdegree") or
[branching factor](/wiki/Branching_factor "Branching factor") of the
tree. In practice, the keys take up the most space in a node. The factor
of 2 will guarantee that nodes can be split or combined. If an internal
node has
![2d](//upload.wikimedia.org/math/c/3/0/c309f0daf5910cf7ac2038ce9520448a.png)
keys, then adding a key to that node can be accomplished by splitting
the
![2d](//upload.wikimedia.org/math/c/3/0/c309f0daf5910cf7ac2038ce9520448a.png)
key node into two
![d](//upload.wikimedia.org/math/8/2/7/8277e0910d750195b448797616e091ad.png)
key nodes and adding the key to the parent node. Each split node has the
required minimum number of keys. Similarly, if an internal node and its
neighbor each have
![d](//upload.wikimedia.org/math/8/2/7/8277e0910d750195b448797616e091ad.png)
keys, then a key may be deleted from the internal node by combining with
its neighbor. Deleting the key would make the internal node have
![d-1](//upload.wikimedia.org/math/1/9/8/1987a88fc39f6b7f2fdf571395212e68.png)
keys; joining the neighbor would add
![d](//upload.wikimedia.org/math/8/2/7/8277e0910d750195b448797616e091ad.png)
keys plus one more key brought down from the neighbor's parent. The
result is an entirely full node of
![2d](//upload.wikimedia.org/math/c/3/0/c309f0daf5910cf7ac2038ce9520448a.png)
keys.

The number of branches (or child nodes) from a node will be one more
than the number of keys stored in the node. In a 2-3 B-tree, the
internal nodes will store either one key (with two child nodes) or two
keys (with three child nodes). A B-tree is sometimes described with the
parameters
![(d+1)](//upload.wikimedia.org/math/e/b/0/eb0f7f92b35996b9bdaae1962386bad4.png)
—
![(2d+1)](//upload.wikimedia.org/math/c/d/b/cdb92063ff7be07a1e13e1fb993e6caa.png)
or simply with the highest branching order,
![(2d+1)](//upload.wikimedia.org/math/c/d/b/cdb92063ff7be07a1e13e1fb993e6caa.png).

A B-tree is kept balanced by requiring that all leaf nodes be at the
same depth. This depth will increase slowly as elements are added to the
tree, but an increase in the overall depth is infrequent, and results in
all leaf nodes being one more node farther away from the root.

B-trees have substantial advantages over alternative implementations
when otherwise the time to access the data of a node greatly exceeds the
time spent processing that data, because then the cost of accessing the
node may be amortized over multiple operations within the node. This
usually occurs when the node data are in [secondary
storage](/wiki/Secondary_storage "Secondary storage") such as [disk
drives](/wiki/Hard_drive "Hard drive"). By maximizing the number of keys
within each [internal node](/wiki/Internal_node "Internal node"), the
height of the tree decreases and the number of expensive node accesses
is reduced. In addition, rebalancing of the tree occurs less often. The
maximum number of child nodes depends on the information that must be
stored for each child node and the size of a full [disk
block](/wiki/Block_(data_storage) "Block (data storage)") or an
analogous size in secondary storage. While 2-3 B-trees are easier to
explain, practical B-trees using secondary storage need a large number
of child nodes to improve performance.

### Variants[[edit](/w/index.php?title=B-tree&action=edit&section=2 "Edit section: Variants")]

The term **B-tree** may refer to a specific design or it may refer to a
general class of designs. In the narrow sense, a B-tree stores keys in
its internal nodes but need not store those keys in the records at the
leaves. The general class includes variations such as the
[B^+^-tree](/wiki/B%2B_tree "B+ tree") and the B^\*^-tree.

-   In the B^+^-tree, copies of the keys are stored in the internal
    nodes; the keys and records are stored in leaves; in addition, a
    leaf node may include a pointer to the next leaf node to speed
    sequential access ([Comer 1979](#CITEREFComer1979), p. 129).
-   The B^\*^-tree balances more neighboring internal nodes to keep the
    internal nodes more densely packed ([Comer 1979](#CITEREFComer1979),
    p. 129). This variant requires non-root nodes to be at least 2/3
    full instead of 1/2 ([Knuth 1998](#CITEREFKnuth1998), p. 488). To
    maintain this, instead of immediately splitting up a node when it
    gets full, its keys are shared with a node next to it. When both
    nodes are full, then the two nodes are split into three. The act of
    deleting nodes is somewhat more complex than inserting however.
-   B-trees can be turned into [order statistic
    trees](/wiki/Order_statistic_tree "Order statistic tree") to allow
    rapid searches for the Nth record in key order, or counting the
    number of records between any two records, and various other related
    operations.^[[1]](#cite_note-1)^

### Etymology unknown[[edit](/w/index.php?title=B-tree&action=edit&section=3 "Edit section: Etymology unknown")]

[Rudolf Bayer](/wiki/Rudolf_Bayer "Rudolf Bayer") and [Ed
McCreight](/wiki/Edward_M._McCreight "Edward M. McCreight") invented the
B-tree while working at [Boeing Research Labs](/wiki/Boeing "Boeing") in
1971 ([Bayer & McCreight 1972](#CITEREFBayerMcCreight1972)), but they
did not explain what, if anything, the *B* stands for. [Douglas
Comer](/wiki/Douglas_Comer "Douglas Comer") explains:

> The origin of "B-tree" has never been explained by the authors. As we
> shall see, "balanced," "broad," or "bushy" might apply. Others suggest
> that the "B" stands for Boeing. Because of his contributions, however,
> it seems appropriate to think of B-trees as "Bayer"-trees. ([Comer
> 1979](#CITEREFComer1979), p. 123 footnote 1)

[Donald Knuth](/wiki/Donald_Knuth "Donald Knuth") speculates on the
etymology of B-trees in his May, 1980 lecture on the topic "CS144C
classroom lecture about disk storage and B-trees", suggesting the "B"
may have originated from Boeing or from Bayer's
name.^[[2]](#cite_note-2)^

After a talk at CPM 2013 (24th Annual Symposium on Combinatorial Pattern
Matching, Bad Herrenalb, Germany, June 17–19, 2013), Ed McCreight
answered a question on B-tree's name by Martin Farach-Colton saying:
"Bayer and I were in a lunch time where we get to think a name. And we
were, so, B, we were thinking... B is, you know... We were working for
Boeing at the time, we couldn't use the name without talking to lawyers.
So, there is a B. It has to do with balance, another B. Bayer was the
senior author, who did have several years older than I am and had many
more publications than I did. So there is another B. And so, at the
lunch table we never did resolve whether there was one of those that
made more sense than the rest. What really lives to say is: the more you
think about what the B in B-trees means, the better you understand
B-trees."^[[3]](#cite_note-3)^

The database problem[[edit](/w/index.php?title=B-tree&action=edit&section=4 "Edit section: The database problem")]
------------------------------------------------------------------------------------------------------------------

This section describes a problem faced by database designers, outlines a
series of increasingly effective solutions to the problem, and ends by
describing how the B-tree solves the problem completely.

### Time to search a sorted file[[edit](/w/index.php?title=B-tree&action=edit&section=5 "Edit section: Time to search a sorted file")]

Usually, sorting and searching algorithms have been characterized by the
number of comparison operations that must be performed using [order
notation](/wiki/Big_O_notation "Big O notation"). A [binary
search](/wiki/Binary_search "Binary search") of a sorted table with
![N](//upload.wikimedia.org/math/8/d/9/8d9c307cb7f3c4a32822a51922d1ceaa.png)
records, for example, can be done in roughly ![\\lceil \\log
\_{2}N\\rceil
](//upload.wikimedia.org/math/1/6/c/16c431e3ac25bd20acbce1ba193f0fe1.png)
comparisons. If the table had 1,000,000 records, then a specific record
could be located with at most 20 comparisons: ![\\lceil \\log
\_{2}1,000,000\\rceil
=20](//upload.wikimedia.org/math/6/4/0/640cbc7912401ed7a08a31ab2b947206.png).

Large databases have historically been kept on disk drives. The time to
read a record on a disk drive far exceeds the time needed to compare
keys once the record is available. The time to read a record from a disk
drive involves a [seek time](/wiki/Seek_time "Seek time") and a
rotational delay. The seek time may be 0 to 20 or more milliseconds, and
the rotational delay averages about half the rotation period. For a 7200
RPM drive, the rotation period is 8.33 milliseconds. For a drive such as
the Seagate ST3500320NS, the track-to-track seek time is 0.8
milliseconds and the average reading seek time is 8.5
milliseconds.^[[4]](#cite_note-4)^ For simplicity, assume reading from
disk takes about 10 milliseconds.

Naively, then, the time to locate one record out of a million would take
20 disk reads times 10 milliseconds per disk read, which is 0.2 seconds.

The time won't be that bad because individual records are grouped
together in a disk **block**. A disk block might be 16 kilobytes. If
each record is 160 bytes, then 100 records could be stored in each
block. The disk read time above was actually for an entire block. Once
the disk head is in position, one or more disk blocks can be read with
little delay. With 100 records per block, the last 6 or so comparisons
don't need to do any disk reads—the comparisons are all within the last
disk block read.

To speed the search further, the first 13 to 14 comparisons (which each
required a disk access) must be sped up.

### An index speeds the search[[edit](/w/index.php?title=B-tree&action=edit&section=6 "Edit section: An index speeds the search")]

A significant improvement can be made with an
[index](/wiki/Index_(database) "Index (database)"). In the example
above, initial disk reads narrowed the search range by a factor of two.
That can be improved substantially by creating an auxiliary index that
contains the first record in each disk block (sometimes called a [sparse
index](/wiki/Index_(database)#Sparse_index "Index (database)")). This
auxiliary index would be 1% of the size of the original database, but it
can be searched more quickly. Finding an entry in the auxiliary index
would tell us which block to search in the main database; after
searching the auxiliary index, we would have to search only that one
block of the main database—at a cost of one more disk read. The index
would hold 10,000 entries, so it would take at most 14 comparisons. Like
the main database, the last 6 or so comparisons in the aux index would
be on the same disk block. The index could be searched in about 8 disk
reads, and the desired record could be accessed in 9 disk reads.

The trick of creating an auxiliary index can be repeated to make an
auxiliary index to the auxiliary index. That would make an aux-aux index
that would need only 100 entries and would fit in one disk block.

Instead of reading 14 disk blocks to find the desired record, we only
need to read 3 blocks. Reading and searching the first (and only) block
of the aux-aux index identifies the relevant block in aux-index. Reading
and searching that aux-index block identifies the relevant block in the
main database. Instead of 150 milliseconds, we need only 30 milliseconds
to get the record.

The auxiliary indices have turned the search problem from a binary
search requiring roughly ![\\log
\_{2}N](//upload.wikimedia.org/math/4/6/7/4677ee6897958d975f52f326871b938b.png)
disk reads to one requiring only ![\\log
\_{b}N](//upload.wikimedia.org/math/b/6/2/b6205136e95271ba54a468296faedba6.png)
disk reads where
![b](//upload.wikimedia.org/math/9/2/e/92eb5ffee6ae2fec3ad71c777531578f.png)
is the blocking factor (the number of entries per block:
![b=100](//upload.wikimedia.org/math/9/c/b/9cbfd4cf83ead3123a27e57561457de0.png)
entries per block; ![\\log
\_{b}1,000,000=3](//upload.wikimedia.org/math/d/7/e/d7ed7980284aaadd7e2d55d6fddff919.png)
reads).

In practice, if the main database is being frequently searched, the
aux-aux index and much of the aux index may reside in a [disk
cache](/wiki/Page_cache "Page cache"), so they would not incur a disk
read.

### Insertions and deletions cause trouble[[edit](/w/index.php?title=B-tree&action=edit&section=7 "Edit section: Insertions and deletions cause trouble")]

If the database does not change, then compiling the index is simple to
do, and the index need never be changed. If there are changes, then
managing the database and its index becomes more complicated.

Deleting records from a database doesn't cause much trouble. The index
can stay the same, and the record can just be marked as deleted. The
database stays in sorted order. If there is a large number of deletions,
then the searching and storage become less efficient.

Insertions can be very slow in a sorted sequential file because room for
the inserted record must be made. Inserting a record before the first
record in the file requires shifting all of the records down one. Such
an operation is just too expensive to be practical. A trick is to leave
some space lying around to be used for insertions. Instead of densely
storing all the records in a block, the block can have some free space
to allow for subsequent insertions. Those records would be marked as if
they were "deleted" records.

Both insertions and deletions are fast as long as space is available on
a block. If an insertion won't fit on the block, then some free space on
some nearby block must be found and the auxiliary indices adjusted. The
hope is that enough space is nearby such that a lot of blocks do not
need to be reorganized. Alternatively, some out-of-sequence disk blocks
may be used.

### The B-tree uses all those ideas[[edit](/w/index.php?title=B-tree&action=edit&section=8 "Edit section: The B-tree uses all those ideas")]

The B-tree uses all of the ideas described above. In particular, a
B-tree:

-   keeps keys in sorted order for sequential traversing
-   uses a hierarchical index to minimize the number of disk reads
-   uses partially full blocks to speed insertions and deletions
-   keeps the index balanced with an elegant recursive algorithm

In addition, a B-tree minimizes waste by making sure the interior nodes
are at least half full. A B-tree can handle an arbitrary number of
insertions and deletions.

Technical description[[edit](/w/index.php?title=B-tree&action=edit&section=9 "Edit section: Technical description")]
--------------------------------------------------------------------------------------------------------------------

### Terminology[[edit](/w/index.php?title=B-tree&action=edit&section=10 "Edit section: Terminology")]

Unfortunately, the literature on B-trees is not uniform in its
terminology ([Folk & Zoellick 1992](#CITEREFFolkZoellick1992), p. 362).

[Bayer & McCreight (1972](#CITEREFBayerMcCreight1972)), [Comer
(1979](#CITEREFComer1979)), and others define the **order** of B-tree as
the minimum number of keys in a non-root node. [Folk & Zoellick
(1992](#CITEREFFolkZoellick1992)) points out that terminology is
ambiguous because the maximum number of keys is not clear. An order 3
B-tree might hold a maximum of 6 keys or a maximum of 7 keys. [Knuth
(1998](#CITEREFKnuth1998), p. 483) avoids the problem by defining the
**order** to be maximum number of children (which is one more than the
maximum number of keys).

The term **leaf** is also inconsistent. [Bayer & McCreight
(1972](#CITEREFBayerMcCreight1972)) considered the leaf level to be the
lowest level of keys, but Knuth considered the leaf level to be one
level below the lowest keys ([Folk & Zoellick
1992](#CITEREFFolkZoellick1992), p. 363). There are many possible
implementation choices. In some designs, the leaves may hold the entire
data record; in other designs, the leaves may only hold pointers to the
data record. Those choices are not fundamental to the idea of a
B-tree.^[[5]](#cite_note-5)^

There are also unfortunate choices like using the variable *k* to
represent the number of children when *k* could be confused with the
number of keys.

For simplicity, most authors assume there are a fixed number of keys
that fit in a node. The basic assumption is the key size is fixed and
the node size is fixed. In practice, variable length keys may be
employed ([Folk & Zoellick 1992](#CITEREFFolkZoellick1992), p. 379).

### Definition[[edit](/w/index.php?title=B-tree&action=edit&section=11 "Edit section: Definition")]

According to Knuth's definition, a B-tree of order *m* is a tree which
satisfies the following properties:

1.  Every node has at most *m* children.
2.  Every non-leaf node (except root) has at least ⌈^*m*^⁄~2~⌉ children.
3.  The root has at least two children if it is not a leaf node.
4.  A non-leaf node with *k* children contains *k*−1 keys.
5.  All leaves appear in the same level, and internal vertices carry no
    information.

Each internal node’s keys act as separation values which divide its
subtrees. For example, if an internal node has 3 child nodes (or
subtrees) then it must have 2 keys: *a*~1~ and *a*~2~. All values in the
leftmost subtree will be less than *a*~1~, all values in the middle
subtree will be between *a*~1~ and *a*~2~, and all values in the
rightmost subtree will be greater than *a*~2~.

**Internal nodes**
  ~ Internal nodes are all nodes except for leaf nodes and the root
    node. They are usually represented as an ordered set of elements and
    child pointers. Every internal node contains a **maximum** of *U*
    children and a **minimum** of *L* children. Thus, the number of
    elements is always 1 less than the number of child pointers (the
    number of elements is between *L*−1 and *U*−1). *U* must be either
    2*L* or 2*L*−1; therefore each internal node is at least half full.
    The relationship between *U* and *L* implies that two half-full
    nodes can be joined to make a legal node, and one full node can be
    split into two legal nodes (if there’s room to push one element up
    into the parent). These properties make it possible to delete and
    insert new values into a B-tree and adjust the tree to preserve the
    B-tree properties.

**The root node**
  ~ The root node’s number of children has the same upper limit as
    internal nodes, but has no lower limit. For example, when there are
    fewer than *L*−1 elements in the entire tree, the root will be the
    only node in the tree, with no children at all.

**Leaf nodes**
  ~ Leaf nodes have the same restriction on the number of elements, but
    have no children, and no child pointers.

A B-tree of depth *n*+1 can hold about *U* times as many items as a
B-tree of depth *n*, but the cost of search, insert, and delete
operations grows with the depth of the tree. As with any balanced tree,
the cost grows much more slowly than the number of elements.

Some balanced trees store values only at leaf nodes, and use different
kinds of nodes for leaf nodes and internal nodes. B-trees keep values in
every node in the tree, and may use the same structure for all nodes.
However, since leaf nodes never have children, the B-trees benefit from
improved performance if they use a specialized structure.

Best case and worst case heights[[edit](/w/index.php?title=B-tree&action=edit&section=12 "Edit section: Best case and worst case heights")]
-------------------------------------------------------------------------------------------------------------------------------------------

Let *h* be the height of the classic B-tree. Let *n* \> 0 be the number
of entries in the tree.^[[6]](#cite_note-6)^ Let *m* be the maximum
number of children a node can have. Each node can have at most *m*−1
keys.

It can be shown (by induction for example) that a B-tree of height *h*
with all its nodes completely filled has *n*=*m*^*h*^−1 entries. Hence,
the best case height of a B-tree is:

![\\lceil \\log \_{{m}}(n+1)\\rceil
.](//upload.wikimedia.org/math/d/c/3/dc3a6175c797f3fe421a6688b9d52a1b.png)

Let *d* be the minimum number of children an internal (non-root) node
can have. For an ordinary B-tree, *d*=⌈*m*/2⌉.

[Comer (1979](#CITEREFComer1979), p. 127) and [Cormen et al.
(2001](#CITEREFCormenLeisersonRivestStein2001), pp. 383–384) give the
worst case height of a B-tree (where the root node is considered to have
height 0) as

![h\\leq \\left\\lfloor \\log \_{{d}}\\left({\\frac
{n+1}{2}}\\right)\\right\\rfloor
.](//upload.wikimedia.org/math/2/4/4/2444d7fc76269868aad4fbbd94a27a4a.png)

Algorithms[[edit](/w/index.php?title=B-tree&action=edit&section=13 "Edit section: Algorithms")]
-----------------------------------------------------------------------------------------------

![image](//upload.wikimedia.org/wikipedia/en/thumb/f/f2/Edit-clear.svg/40px-Edit-clear.svg.png)

This article **may be [confusing or
unclear](/wiki/Wikipedia:Vagueness "Wikipedia:Vagueness") to readers**.
In particular, the discussion below uses "element", "value", "key",
"separator", and "separation value" to mean essentially the same thing.
The terms are not clearly defined. There are some subtle issues at the
root and leaves. Please help us [clarify the
article](/wiki/Wikipedia:Please_clarify "Wikipedia:Please clarify");
suggestions may be found on the [talk
page](/wiki/Talk:B-tree "Talk:B-tree"). *(February 2012)*

### Search[[edit](/w/index.php?title=B-tree&action=edit&section=14 "Edit section: Search")]

Searching is similar to searching a binary search tree. Starting at the
root, the tree is recursively traversed from top to bottom. At each
level, the search chooses the child pointer (subtree) whose separation
values are on either side of the search value.

Binary search is typically (but not necessarily) used within nodes to
find the separation values and child tree of interest.

### Insertion[[edit](/w/index.php?title=B-tree&action=edit&section=15 "Edit section: Insertion")]

[![image](//upload.wikimedia.org/wikipedia/commons/3/33/B_tree_insertion_example.png)](/wiki/File:B_tree_insertion_example.png)

[![image](//bits.wikimedia.org/static-1.23wmf12/skins/common/images/magnify-clip.png)](/wiki/File:B_tree_insertion_example.png "Enlarge")

A B Tree insertion example with each iteration. The nodes of this B tree
have at most 3 children (Knuth order 3).

All insertions start at a leaf node. To insert a new element, search the
tree to find the leaf node where the new element should be added. Insert
the new element into that node with the following steps:

1.  If the node contains fewer than the maximum legal number of
    elements, then there is room for the new element. Insert the new
    element in the node, keeping the node's elements ordered.
2.  Otherwise the node is full, evenly split it into two nodes so:
    1.  A single median is chosen from among the leaf's elements and the
        new element.
    2.  Values less than the median are put in the new left node and
        values greater than the median are put in the new right node,
        with the median acting as a separation value.
    3.  The separation value is inserted in the node's parent, which may
        cause it to be split, and so on. If the node has no parent
        (i.e., the node was the root), create a new root above this node
        (increasing the height of the tree).

If the splitting goes all the way up to the root, it creates a new root
with a single separator value and two children, which is why the lower
bound on the size of internal nodes does not apply to the root. The
maximum number of elements per node is *U*−1. When a node is split, one
element moves to the parent, but one element is added. So, it must be
possible to divide the maximum number *U*−1 of elements into two legal
nodes. If this number is odd, then *U*=2*L* and one of the new nodes
contains (*U*−2)/2 = *L*−1 elements, and hence is a legal node, and the
other contains one more element, and hence it is legal too. If *U*−1 is
even, then *U*=2*L*−1, so there are 2*L*−2 elements in the node. Half of
this number is *L*−1, which is the minimum number of elements allowed
per node.

An improved algorithm ([Mond & Raz 1985](#CITEREFMondRaz1985)) supports
a single pass down the tree from the root to the node where the
insertion will take place, splitting any full nodes encountered on the
way. This prevents the need to recall the parent nodes into memory,
which may be expensive if the nodes are on secondary storage. However,
to use this improved algorithm, we must be able to send one element to
the parent and split the remaining *U*−2 elements into two legal nodes,
without adding a new element. This requires *U* = 2*L* rather than *U* =
2*L*−1, which accounts for why some textbooks impose this requirement in
defining B-trees.

### Deletion[[edit](/w/index.php?title=B-tree&action=edit&section=16 "Edit section: Deletion")]

There are two popular strategies for deletion from a B-tree.

1.  Locate and delete the item, then restructure the tree to regain its
    invariants, **OR**
2.  Do a single pass down the tree, but before entering (visiting) a
    node, restructure the tree so that once the key to be deleted is
    encountered, it can be deleted without triggering the need for any
    further restructuring

The algorithm below uses the former strategy.

There are two special cases to consider when deleting an element:

1.  The element in an internal node is a separator for its child nodes
2.  Deleting an element may put its node under the minimum number of
    elements and children

The procedures for these cases are in order below.

#### Deletion from a leaf node[[edit](/w/index.php?title=B-tree&action=edit&section=17 "Edit section: Deletion from a leaf node")]

1.  Search for the value to delete.
2.  If the value is in a leaf node, simply delete it from the node.
3.  If underflow happens, rebalance the tree as described in section
    "Rebalancing after deletion" below.

#### Deletion from an internal node[[edit](/w/index.php?title=B-tree&action=edit&section=18 "Edit section: Deletion from an internal node")]

Each element in an internal node acts as a separation value for two
subtrees, therefore we need to find a replacement for separation. Note
that the largest element in the left subtree is still less than the
separator. Likewise, the smallest element in the right subtree is still
greater than the separator. Both of those elements are in leaf nodes,
and either one can be the new separator for the two subtrees.
Algorithmically described below:

1.  Choose a new separator (either the largest element in the left
    subtree or the smallest element in the right subtree), remove it
    from the leaf node it is in, and replace the element to be deleted
    with the new separator.
2.  The previous step deleted an element (the new separator) from a leaf
    node. If that leaf node is now deficient (has fewer than the
    required number of nodes), then rebalance the tree starting from the
    leaf node.

#### Rebalancing after deletion[[edit](/w/index.php?title=B-tree&action=edit&section=19 "Edit section: Rebalancing after deletion")]

Rebalancing starts from a leaf and proceeds toward the root until the
tree is balanced. If deleting an element from a node has brought it
under the minimum size, then some elements must be redistributed to
bring all nodes up to the minimum. Usually, the redistribution involves
moving an element from a sibling node that has more than the minimum
number of nodes. That redistribution operation is called a **rotation**.
If no sibling can spare a node, then the deficient node must be
**merged** with a sibling. The merge causes the parent to lose a
separator element, so the parent may become deficient and need
rebalancing. The merging and rebalancing may continue all the way to the
root. Since the minimum element count doesn't apply to the root, making
the root be the only deficient node is not a problem. The algorithm to
rebalance the tree is as
follows:^[*[citation\\ needed](/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")*]^

-   If the deficient node's right sibling exists and has more than the
    minimum number of elements, then rotate left
    1.  Copy the separator from the parent to the end of the deficient
        node (the separator moves down; the deficient node now has the
        minimum number of elements)
    2.  Replace the separator in the parent with the first element of
        the right sibling (right sibling loses one node but still has at
        least the minimum number of elements)
    3.  The tree is now balanced

-   Otherwise, if the deficient node's left sibling exists and has more
    than the minimum number of elements, then rotate right
    1.  Copy the separator from the parent to the start of the deficient
        node (the separator moves down; deficient node now has the
        minimum number of elements)
    2.  Replace the separator in the parent with the last element of the
        left sibling (left sibling loses one node but still has at least
        the minimum number of elements)
    3.  The tree is now balanced

-   Otherwise, if both immediate siblings have only the minimum number
    of elements, then merge with a sibling sandwiching their separator
    taken off from their parent
    1.  Copy the separator to the end of the left node (the left node
        may be the deficient node or it may be the sibling with the
        minimum number of elements)
    2.  Move all elements from the right node to the left node (the left
        node now has the maximum number of elements, and the right node
        – empty)
    3.  Remove the separator from the parent along with its empty right
        child (the parent loses an element)
        -   If the parent is the root and now has no elements, then free
            it and make the merged node the new root (tree becomes
            shallower)
        -   Otherwise, if the parent has fewer than the required number
            of elements, then rebalance the parent

**Note**: The rebalancing operations are different for B^+^-trees (e.g.,
rotation is different because parent has copy of the key) and B\*-tree
(e.g., three siblings are merged into two siblings).

### Sequential access[[edit](/w/index.php?title=B-tree&action=edit&section=20 "Edit section: Sequential access")]

While freshly loaded databases tend to have good sequential behavior,
this behavior becomes increasingly difficult to maintain as a database
grows, resulting in more random I/O and performance
challenges.^[[7]](#cite_note-7)^

### Initial construction[[edit](/w/index.php?title=B-tree&action=edit&section=21 "Edit section: Initial construction")]

In applications, it is frequently useful to build a B-tree to represent
a large existing collection of data and then update it incrementally
using standard B-tree operations. In this case, the most efficient way
to construct the initial B-tree is not to insert every element in the
initial collection successively, but instead to construct the initial
set of leaf nodes directly from the input, then build the internal nodes
from these. This approach to B-tree construction is called
[bulkloading](/w/index.php?title=Bulkloading&action=edit&redlink=1 "Bulkloading (page does not exist)").
Initially, every leaf but the last one has one extra element, which will
be used to build the internal
nodes.^[*[citation\\ needed](/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")*]^

For example, if the leaf nodes have maximum size 4 and the initial
collection is the integers 1 through 24, we would initially construct 4
leaf nodes containing 5 values each and 1 which contains 4 values:

  --- --- --- --- ---
  1   2   3   4   5
  --- --- --- --- ---

  --- --- --- --- ----
  6   7   8   9   10
  --- --- --- --- ----

  ---- ---- ---- ---- ----
  11   12   13   14   15
  ---- ---- ---- ---- ----

  ---- ---- ---- ---- ----
  16   17   18   19   20
  ---- ---- ---- ---- ----

  ---- ---- ---- ----
  21   22   23   24
  ---- ---- ---- ----

We build the next level up from the leaves by taking the last element
from each leaf node except the last one. Again, each node except the
last will contain one extra value. In the example, suppose the internal
nodes contain at most 2 values (3 child pointers). Then the next level
up of internal nodes would be:

  --- ---- ----
  5   10   15
  --- ---- ----

  ----
  20
  ----

  --- --- --- ---
  1   2   3   4
  --- --- --- ---

  --- --- --- ---
  6   7   8   9
  --- --- --- ---

  ---- ---- ---- ----
  11   12   13   14
  ---- ---- ---- ----

  ---- ---- ---- ----
  16   17   18   19
  ---- ---- ---- ----

  ---- ---- ---- ----
  21   22   23   24
  ---- ---- ---- ----

This process is continued until we reach a level with only one node and
it is not overfilled. In the example only the root level remains:

  ----
  15
  ----

  --- ----
  5   10
  --- ----

  ----
  20
  ----

  --- --- --- ---
  1   2   3   4
  --- --- --- ---

  --- --- --- ---
  6   7   8   9
  --- --- --- ---

  ---- ---- ---- ----
  11   12   13   14
  ---- ---- ---- ----

  ---- ---- ---- ----
  16   17   18   19
  ---- ---- ---- ----

  ---- ---- ---- ----
  21   22   23   24
  ---- ---- ---- ----

In filesystems[[edit](/w/index.php?title=B-tree&action=edit&section=22 "Edit section: In filesystems")]
-------------------------------------------------------------------------------------------------------

In addition to its use in databases, the B-tree is also used in
filesystems to allow quick random access to an arbitrary block in a
particular file. The basic problem is turning the file block
![i](//upload.wikimedia.org/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png)
address into a disk block (or perhaps to a
[cylinder-head-sector](/wiki/Cylinder-head-sector "Cylinder-head-sector"))
address.

Some operating systems require the user to allocate the maximum size of
the file when the file is created. The file can then be allocated as
contiguous disk blocks. Converting to a disk block: the operating system
just adds the file block address to the starting disk block of the file.
The scheme is simple, but the file cannot exceed its created size.

Other operating systems allow a file to grow. The resulting disk blocks
may not be contiguous, so mapping logical blocks to physical blocks is
more involved.

[MS-DOS](/wiki/MS-DOS "MS-DOS"), for example, used a simple [File
Allocation Table](/wiki/File_Allocation_Table "File Allocation Table")
(FAT). The FAT has an entry for each disk
block,^[[note\\ 1]](#cite_note-8)^ and that entry identifies whether its
block is used by a file and if so, which block (if any) is the next disk
block of the same file. So, the allocation of each file is represented
as a [linked list](/wiki/Linked_list "Linked list") in the table. In
order to find the disk address of file block
![i](//upload.wikimedia.org/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png),
the operating system (or disk utility) must sequentially follow the
file's linked list in the FAT. Worse, to find a free disk block, it must
sequentially scan the FAT. For MS-DOS, that was not a huge penalty
because the disks and files were small and the FAT had few entries and
relatively short file chains. In the [FAT12](/wiki/FAT12 "FAT12")
filesystem (used on floppy disks and early hard disks), there were no
more than 4,080 ^[[note\\ 2]](#cite_note-9)^ entries, and the FAT would
usually be resident in memory. As disks got bigger, the FAT architecture
began to confront penalties. On a large disk using FAT, it may be
necessary to perform disk reads to learn the disk location of a file
block to be read or written.

[TOPS-20](/wiki/TOPS-20 "TOPS-20") (and possibly
[TENEX](/wiki/TOPS-20#TENEX "TOPS-20")) used a 0 to 2 level tree that
has similarities to a
B-tree^[*[citation\\ needed](/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")*]^.
A disk block was 512 36-bit words. If the file fit in a 512 (2^9^) word
block, then the file directory would point to that physical disk block.
If the file fit in 2^18^ words, then the directory would point to an aux
index; the 512 words of that index would either be NULL (the block isn't
allocated) or point to the physical address of the block. If the file
fit in 2^27^ words, then the directory would point to a block holding an
aux-aux index; each entry would either be NULL or point to an aux index.
Consequently, the physical disk block for a 2^27^ word file could be
located in two disk reads and read on the third.

Apple's filesystem [HFS+](/wiki/HFS%2B "HFS+"), Microsoft's
[NTFS](/wiki/NTFS "NTFS"),^[[8]](#cite_note-insidewin2kntfs-10)^ AIX
(jfs2) and some [Linux](/wiki/Linux "Linux") filesystems, such as
[btrfs](/wiki/Btrfs "Btrfs") and [Ext4](/wiki/Ext4 "Ext4"), use B-trees.

B\*-trees are used in the
[HFS](/wiki/Hierarchical_File_System "Hierarchical File System") and
[Reiser4](/wiki/Reiser4 "Reiser4") [file
systems](/wiki/File_system "File system").

Variations[[edit](/w/index.php?title=B-tree&action=edit&section=23 "Edit section: Variations")]
-----------------------------------------------------------------------------------------------

### Access concurrency[[edit](/w/index.php?title=B-tree&action=edit&section=24 "Edit section: Access concurrency")]

Lehman and Yao^[[9]](#cite_note-11)^ showed that all read locks could be
avoided (and thus concurrent access greatly improved) by linking the
tree blocks at each level together with a "next" pointer. This results
in a tree structure where both insertion and search operations descend
from the root to the leaf. Write locks are only required as a tree block
is modified. This maximizes access concurrency by multiple users, an
important consideration for databases and/or other B-tree based
[ISAM](/wiki/ISAM "ISAM") storage methods. The cost associated with this
improvement is that empty pages cannot be removed from the btree during
normal operations. (However, see ^[[10]](#cite_note-12)^ for various
strategies to implement node merging, and source code
at.^[[11]](#cite_note-13)^)

United States Patent 5283894, granted in 1994, appears to show a way to
use a 'Meta Access Method' ^[[12]](#cite_note-14)^ to allow concurrent
B+Tree access and modification without locks. The technique accesses the
tree 'upwards' for both searches and updates by means of additional
in-memory indexes that point at the blocks in each level in the block
cache. No reorganization for deletes is needed and there are no 'next'
pointers in each block as in Lehman and Yao.

See also[[edit](/w/index.php?title=B-tree&action=edit&section=25 "Edit section: See also")]
-------------------------------------------------------------------------------------------

-   [R-tree](/wiki/R-tree "R-tree")

Notes[[edit](/w/index.php?title=B-tree&action=edit&section=26 "Edit section: Notes")]
-------------------------------------------------------------------------------------

1.  **[\^](#cite_ref-8)** For FAT, what is called a "disk block" here is
    what the FAT documentation calls a "cluster", which is fixed-size
    group of one or more contiguous whole physical disk
    [sectors](/wiki/Cylinder-head-sector "Cylinder-head-sector"). For
    the purposes of this discussion, a cluster has no significant
    difference from a physical sector.
2.  **[\^](#cite_ref-9)** Two of these were reserved for special
    purposes, so only 4078 could actually represent disk blocks
    (clusters).

References[[edit](/w/index.php?title=B-tree&action=edit&section=27 "Edit section: References")]
-----------------------------------------------------------------------------------------------

1.  **[\^](#cite_ref-1)** [Counted
    B-Trees](http://www.chiark.greenend.org.uk/~sgtatham/algorithms/cbtree.html),
    retrieved 2010-01-25
2.  **[\^](#cite_ref-2)** [Knuth's video lectures from
    Stanford](http://scpd.stanford.edu/knuth/index.jsp)
3.  **[\^](#cite_ref-3)** [Talk's
    video](http://vimeo.com/channels/574784), retrieved 2014-01-17
4.  **[\^](#cite_ref-4)** Seagate Technology LLC, Product Manual:
    Barracuda ES.2 Serial ATA, Rev. F., publication 100468393, 2008
    [[1]](http://www.seagate.com/staticfiles/support/disc/manuals/NL35%20Series%20&%20BC%20ES%20Series/Barracuda%20ES.2%20Series/100468393f.pdf),
    page 6
5.  **[\^](#cite_ref-5)** [Bayer & McCreight
    (1972](#CITEREFBayerMcCreight1972)) avoided the issue by saying an
    index element is a (physically adjacent) pair of (*x*, *a*) where
    *x* is the key, and *a* is some associated information. The
    associated information might be a pointer to a record or records in
    a random access, but what it was didn't really matter. [Bayer &
    McCreight (1972](#CITEREFBayerMcCreight1972)) states, "For this
    paper the associated information is of no further interest."
6.  **[\^](#cite_ref-6)** If *n* is zero, then no root node is needed,
    so the height of an empty tree is not well defined.
7.  **[\^](#cite_ref-7)** ["Cache Oblivious
    B-trees"](http://www.cs.sunysb.edu/~bender/pub/cache-oblivious-btree.ps).
    State University of New York (SUNY) at Stony Brook. Retrieved
    2011-01-17.
8.  **[\^](#cite_ref-insidewin2kntfs_10-0)** [Mark
    Russinovich](/wiki/Mark_Russinovich "Mark Russinovich"). ["Inside
    Win2K NTFS, Part
    1"](http://msdn2.microsoft.com/en-us/library/ms995846.aspx).
    [Microsoft Developer Network](/wiki/MSDN "MSDN").
    [Archived](http://web.archive.org/web/20080413181940/http://msdn2.microsoft.com/en-us/library/ms995846.aspx)
    from the original on 13 April 2008. Retrieved 2008-04-18.
9.  **[\^](#cite_ref-11)** ["Efficient locking for concurrent operations
    on
    B-trees"](http://portal.acm.org/citation.cfm?id=319663&dl=GUIDE&coll=GUIDE&CFID=61777986&CFTOKEN=74351190).
    Portal.acm.org.
    [doi](/wiki/Digital_object_identifier "Digital object identifier"):[10.1145/319628.319663](http://dx.doi.org/10.1145%2F319628.319663).
    Retrieved 2012-06-28.
10. **[\^](#cite_ref-12)**
    [http://www.dtic.mil/cgi-bin/GetTRDoc?AD=ADA232287&Location=U2&doc=GetTRDoc.pdf](http://www.dtic.mil/cgi-bin/GetTRDoc?AD=ADA232287&Location=U2&doc=GetTRDoc.pdf)
11. **[\^](#cite_ref-13)** ["Downloads - high-concurrency-btree - High
    Concurrency B-Tree code in C - GitHub Project
    Hosting"](https://github.com/malbrain/Btree-source-code). Retrieved
    2014-01-27.
12. **[\^](#cite_ref-14)** [Lockless Concurrent
    B+Tree](http://www.freepatentsonline.com/5283894.html)

General

-   [Bayer, R.](/wiki/Rudolf_Bayer "Rudolf Bayer"); [McCreight,
    E.](/wiki/Edward_M._McCreight "Edward M. McCreight") (1972),
    ["Organization and Maintenance of Large Ordered
    Indexes"](http://www.minet.uni-jena.de/dbis/lehre/ws2005/dbs1/Bayer_hist.pdf),
    *Acta Informatica* **1** (3): 173–189
-   [Comer, Douglas](/wiki/Douglas_Comer "Douglas Comer") (June 1979),
    "The Ubiquitous B-Tree", *Computing Surveys* **11** (2): 123–137,
    [doi](/wiki/Digital_object_identifier "Digital object identifier"):[10.1145/356770.356776](http://dx.doi.org/10.1145%2F356770.356776),
    [ISSN](/wiki/International_Standard_Serial_Number "International Standard Serial Number")
    [0360-0300](//www.worldcat.org/issn/0360-0300) .
-   [Cormen, Thomas](/wiki/Thomas_H._Cormen "Thomas H. Cormen");
    [Leiserson,
    Charles](/wiki/Charles_E._Leiserson "Charles E. Leiserson");
    [Rivest, Ronald](/wiki/Ronald_L._Rivest "Ronald L. Rivest"); [Stein,
    Clifford](/wiki/Clifford_Stein "Clifford Stein") (2001),
    *[Introduction to
    Algorithms](/wiki/Introduction_to_Algorithms "Introduction to Algorithms")*
    (Second ed.), MIT Press and McGraw-Hill, pp. 434–454,
    [ISBN](/wiki/International_Standard_Book_Number "International Standard Book Number")
    [0-262-03293-7](/wiki/Special:BookSources/0-262-03293-7 "Special:BookSources/0-262-03293-7")
    . Chapter 18: B-Trees.
-   Folk, Michael J.; Zoellick, Bill (1992), *File Structures* (2nd
    ed.), Addison-Wesley,
    [ISBN](/wiki/International_Standard_Book_Number "International Standard Book Number")
    [0-201-55713-4](/wiki/Special:BookSources/0-201-55713-4 "Special:BookSources/0-201-55713-4")
-   [Knuth, Donald](/wiki/Donald_Knuth "Donald Knuth") (1998), *Sorting
    and Searching*, [The Art of Computer
    Programming](/wiki/The_Art_of_Computer_Programming "The Art of Computer Programming"),
    Volume 3 (Second ed.), Addison-Wesley,
    [ISBN](/wiki/International_Standard_Book_Number "International Standard Book Number")
    [0-201-89685-0](/wiki/Special:BookSources/0-201-89685-0 "Special:BookSources/0-201-89685-0")
    . Section 6.2.4: Multiway Trees, pp. 481–491. Also, pp. 476–477 of
    section 6.2.3 (Balanced Trees) discusses 2-3 trees.
-   [Mond,
    Yehudit](/w/index.php?title=Yehudit_Mond&action=edit&redlink=1 "Yehudit Mond (page does not exist)");
    [Raz,
    Yoav](/w/index.php?title=Yoav_Raz&action=edit&redlink=1 "Yoav Raz (page does not exist)")
    (1985), ["Concurrency Control in B+-Trees Databases Using
    Preparatory
    Operations"](http://www.informatik.uni-trier.de/~ley/db/conf/vldb/MondR85.html),
    *VLDB'85, Proceedings of 11th International Conference on Very Large
    Data Bases*: 331–334 .

### Original papers[[edit](/w/index.php?title=B-tree&action=edit&section=28 "Edit section: Original papers")]

-   [Bayer, Rudolf](/wiki/Rudolf_Bayer "Rudolf Bayer"); [McCreight,
    E.](/wiki/Edward_M._McCreight "Edward M. McCreight") (July 1970),
    *Organization and Maintenance of Large Ordered Indices*,
    Mathematical and Information Sciences Report No. 20, Boeing
    Scientific Research Laboratories .
-   [Bayer, Rudolf](/wiki/Rudolf_Bayer "Rudolf Bayer") (1971), "Binary
    B-Trees for Virtual Memory", Proceedings of 1971 ACM-SIGFIDET
    Workshop on Data Description, Access and Control, San Diego,
    California . November 11–12, 1971.

External links[[edit](/w/index.php?title=B-tree&action=edit&section=29 "Edit section: External links")]
-------------------------------------------------------------------------------------------------------

-   [B-tree lecture](http://www.youtube.com/watch?v=I22wEC1tTGo) by
    David Scot Taylor, SJSU
-   [B-Tree animation applet](http://slady.net/java/bt/view.php) by
    slady
-   [B-tree and UB-tree on
    Scholarpedia](http://www.scholarpedia.org/article/B-tree_and_UB-tree)
    Curator: Dr Rudolf Bayer
-   [B-Trees: Balanced Tree Data
    Structures](http://www.bluerwhite.org/btree)
-   [NIST's Dictionary of Algorithms and Data Structures:
    B-tree](http://www.nist.gov/dads/HTML/btree.html)
-   [B-Tree
    Tutorial](http://cis.stvincent.edu/html/tutorials/swd/btree/btree.html)
-   [The InfinityDB BTree
    implementation](http://www.boilerbay.com/infinitydb/TheDesignOfTheInfinityDatabaseEngine.htm)
-   [Cache Oblivious
    B(+)-trees](http://supertech.csail.mit.edu/cacheObliviousBTree.html)
-   [Dictionary of Algorithms and Data Structures entry for
    B\*-tree](http://www.nist.gov/dads/HTML/bstartree.html)
-   [Open Data Structures - Section 14.2 -
    B-Trees](http://opendatastructures.org/versions/edition-0.1e/ods-java/14_2_B_Trees.html)
-   [Counted
    B-Trees](http://www.chiark.greenend.org.uk/~sgtatham/algorithms/cbtree.html)

-   [v](/wiki/Template:CS_trees "Template:CS trees")
-   [t](/wiki/Template_talk:CS_trees "Template talk:CS trees")
-   [e](//en.wikipedia.org/w/index.php?title=Template:CS_trees&action=edit)

[Tree data
structures](/wiki/Tree_(data_structure) "Tree (data structure)")

[Binary trees](/wiki/Binary_tree "Binary tree")

-   [Binary search tree
    (BST)](/wiki/Binary_search_tree "Binary search tree")
-   [Cartesian tree](/wiki/Cartesian_tree "Cartesian tree")
-   [MVP Tree](/wiki/MVP_Tree "MVP Tree")
-   [Top tree](/wiki/Top_tree "Top tree")
-   [T-tree](/wiki/T-tree "T-tree")
-   [Left-child right-sibling binary
    tree](/wiki/Left-child_right-sibling_binary_tree "Left-child right-sibling binary tree")

[Self-balancing binary search
trees](/wiki/Self-balancing_binary_search_tree "Self-balancing binary search tree")

-   [AA tree](/wiki/AA_tree "AA tree")
-   [AVL tree](/wiki/AVL_tree "AVL tree")
-   [LLRB
    tree](/wiki/Left-leaning_red%E2%80%93black_tree "Left-leaning red–black tree")
-   [Red–black tree](/wiki/Red%E2%80%93black_tree "Red–black tree")
-   [Scapegoat tree](/wiki/Scapegoat_tree "Scapegoat tree")
-   [Splay tree](/wiki/Splay_tree "Splay tree")
-   [Treap](/wiki/Treap "Treap")

**B-trees**

-   [B+ tree](/wiki/B%2B_tree "B+ tree")
-   [B\*-tree](/wiki/B*-tree "B*-tree")
-   [B^x^-tree](/wiki/Bx-tree "Bx-tree")
-   [UB-tree](/wiki/UB-tree "UB-tree")
-   [2–3 tree](/wiki/2%E2%80%933_tree "2–3 tree")
-   [2–3–4 tree](/wiki/2%E2%80%933%E2%80%934_tree "2–3–4 tree")
-   [(a,b)-tree](/wiki/(a,b)-tree "(a,b)-tree")
-   [Dancing tree](/wiki/Dancing_tree "Dancing tree")
-   [HTree](/wiki/HTree "HTree")

[Tries](/wiki/Trie "Trie")

-   [Suffix tree](/wiki/Suffix_tree "Suffix tree")
-   [Radix tree](/wiki/Radix_tree "Radix tree")
-   [Hash
    tree](/wiki/Hash_tree_(persistent_data_structure) "Hash tree (persistent data structure)")
-   [Ternary search
    tree](/wiki/Ternary_search_tree "Ternary search tree")
-   [X-fast trie](/wiki/X-fast_trie "X-fast trie")
-   [Y-fast trie](/wiki/Y-fast_trie "Y-fast trie")

[Binary space partitioning
(BSP)](/wiki/Binary_space_partitioning "Binary space partitioning")
trees

-   [Quadtree](/wiki/Quadtree "Quadtree")
-   [Octree](/wiki/Octree "Octree")
-   [*k*-d tree](/wiki/K-d_tree "K-d tree")
-   [Implicit *k*-d tree](/wiki/Implicit_k-d_tree "Implicit k-d tree")
-   [VP tree](/wiki/Vantage-point_tree "Vantage-point tree")

Non-binary trees

-   [Exponential tree](/wiki/Exponential_tree "Exponential tree")
-   [Fusion tree](/wiki/Fusion_tree "Fusion tree")
-   [Interval tree](/wiki/Interval_tree "Interval tree")
-   [PQ tree](/wiki/PQ_tree "PQ tree")
-   [Range tree](/wiki/Range_tree "Range tree")
-   [SPQR tree](/wiki/SPQR_tree "SPQR tree")
-   [Van Emde Boas tree](/wiki/Van_Emde_Boas_tree "Van Emde Boas tree")

[Spatial](/wiki/Spatial_index "Spatial index") data partitioning trees

-   [R-tree](/wiki/R-tree "R-tree")
-   [R+ tree](/wiki/R%2B_tree "R+ tree")
-   [R\* tree](/wiki/R*_tree "R* tree")
-   [X-tree](/wiki/X-tree "X-tree")
-   [M-tree](/wiki/M-tree "M-tree")
-   [Segment tree](/wiki/Segment_tree "Segment tree")
-   [Hilbert R-tree](/wiki/Hilbert_R-tree "Hilbert R-tree")
-   [Priority R-tree](/wiki/Priority_R-tree "Priority R-tree")

Other trees

-   [Heap](/wiki/Heap_(data_structure) "Heap (data structure)")
-   [Hash calendar](/wiki/Hash_calendar "Hash calendar")
-   [Merkle tree](/wiki/Merkle_tree "Merkle tree")
-   [Finger tree](/wiki/Finger_tree "Finger tree")
-   [Order statistic
    tree](/wiki/Order_statistic_tree "Order statistic tree")
-   [Metric tree](/wiki/Metric_tree "Metric tree")
-   [Cover tree](/wiki/Cover_tree "Cover tree")
-   [BK-tree](/wiki/BK-tree "BK-tree")
-   [Doubly chained
    tree](/wiki/Doubly_chained_tree "Doubly chained tree")
-   [iDistance](/wiki/IDistance "IDistance")
-   [Link/cut tree](/wiki/Link/cut_tree "Link/cut tree")
-   [Fenwick tree](/wiki/Fenwick_tree "Fenwick tree")
-   [Log-structured
    merge-tree](/wiki/Log-structured_merge-tree "Log-structured merge-tree")

-   [v](/wiki/Template:Data_structures "Template:Data structures")
-   [t](/wiki/Template_talk:Data_structures "Template talk:Data structures")
-   [e](//en.wikipedia.org/w/index.php?title=Template:Data_structures&action=edit)

[Data structures](/wiki/Data_structure "Data structure")

Types

-   [Collection](/wiki/Collection_(abstract_data_type) "Collection (abstract data type)")
-   [Container](/wiki/Container_(abstract_data_type) "Container (abstract data type)")

[Abstract](/wiki/Abstract_data_type "Abstract data type")

-   [Associative array](/wiki/Associative_array "Associative array")
-   [Double-ended priority
    queue](/wiki/Double-ended_priority_queue "Double-ended priority queue")
-   [Double-ended queue](/wiki/Double-ended_queue "Double-ended queue")
-   [List](/wiki/List_(abstract_data_type) "List (abstract data type)")
-   [Multimap](/wiki/Multimap "Multimap")
-   [Priority queue](/wiki/Priority_queue "Priority queue")
-   [Queue](/wiki/Queue_(abstract_data_type) "Queue (abstract data type)")
-   [Set](/wiki/Set_(abstract_data_type) "Set (abstract data type)")
    -   [multiset](/wiki/Set_(abstract_data_type)#Multiset "Set (abstract data type)")

-   [Disjoint
    Sets](/wiki/Disjoint-set_data_structure "Disjoint-set data structure")
-   [Stack](/wiki/Stack_(abstract_data_type) "Stack (abstract data type)")

[Arrays](/wiki/Array_data_structure "Array data structure")

-   [Bit array](/wiki/Bit_array "Bit array")
-   [Circular buffer](/wiki/Circular_buffer "Circular buffer")
-   [Dynamic array](/wiki/Dynamic_array "Dynamic array")
-   [Hash table](/wiki/Hash_table "Hash table")
-   [Hashed array tree](/wiki/Hashed_array_tree "Hashed array tree")
-   [Sparse array](/wiki/Sparse_array "Sparse array")

[Linked](/wiki/Linked_data_structure "Linked data structure")

-   [Association list](/wiki/Association_list "Association list")
-   [Linked list](/wiki/Linked_list "Linked list")
-   [Skip list](/wiki/Skip_list "Skip list")
-   [Unrolled linked
    list](/wiki/Unrolled_linked_list "Unrolled linked list")
-   [XOR linked list](/wiki/XOR_linked_list "XOR linked list")

[Trees](/wiki/Tree_(data_structure) "Tree (data structure)")

-   **B-tree**
-   [Binary search tree](/wiki/Binary_search_tree "Binary search tree")
    -   [AA](/wiki/AA_tree "AA tree")
    -   [AVL](/wiki/AVL_tree "AVL tree")
    -   [red-black](/wiki/Red%E2%80%93black_tree "Red–black tree")
    -   [self-balancing](/wiki/Self-balancing_binary_search_tree "Self-balancing binary search tree")
    -   [splay](/wiki/Splay_tree "Splay tree")

-   [Heap](/wiki/Heap_(data_structure) "Heap (data structure)")
    -   [binary](/wiki/Binary_heap "Binary heap")
    -   [binomial](/wiki/Binomial_heap "Binomial heap")
    -   [Fibonacci](/wiki/Fibonacci_heap "Fibonacci heap")

-   [R-tree](/wiki/R-tree "R-tree")
    -   [R\*](/wiki/R*_tree "R* tree")
    -   [R+](/wiki/R%2B_tree "R+ tree")
    -   [Hilbert](/wiki/Hilbert_R-tree "Hilbert R-tree")

-   [Trie](/wiki/Trie "Trie")
    -   [Hash
        tree](/wiki/Hash_tree_(persistent_data_structure) "Hash tree (persistent data structure)")

[Graphs](/wiki/Graph_(abstract_data_type) "Graph (abstract data type)")

-   [Binary decision
    diagram](/wiki/Binary_decision_diagram "Binary decision diagram")
-   [Directed acyclic word
    graph](/wiki/Directed_acyclic_word_graph "Directed acyclic word graph")

-   [List of data
    structures](/wiki/List_of_data_structures "List of data structures")

![image](//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1)

Retrieved from
"[http://en.wikipedia.org/w/index.php?title=B-tree&oldid=594230486](http://en.wikipedia.org/w/index.php?title=B-tree&oldid=594230486)"

[Categories](/wiki/Help:Category "Help:Category"):

-   [Trees (data
    structures)](/wiki/Category:Trees_(data_structures) "Category:Trees (data structures)")
-   [1971
    introductions](/wiki/Category:1971_introductions "Category:1971 introductions")
-   [B-tree](/wiki/Category:B-tree "Category:B-tree")
-   [Database index
    techniques](/wiki/Category:Database_index_techniques "Category:Database index techniques")

Hidden categories:

-   [Wikipedia articles needing clarification from February
    2012](/wiki/Category:Wikipedia_articles_needing_clarification_from_February_2012 "Category:Wikipedia articles needing clarification from February 2012")
-   [All Wikipedia articles needing
    clarification](/wiki/Category:All_Wikipedia_articles_needing_clarification "Category:All Wikipedia articles needing clarification")
-   [All articles with unsourced
    statements](/wiki/Category:All_articles_with_unsourced_statements "Category:All articles with unsourced statements")
-   [Articles with unsourced statements from July
    2008](/wiki/Category:Articles_with_unsourced_statements_from_July_2008 "Category:Articles with unsourced statements from July 2008")
-   [Articles with unsourced statements from October
    2009](/wiki/Category:Articles_with_unsourced_statements_from_October_2009 "Category:Articles with unsourced statements from October 2009")

Navigation menu
---------------

### Personal tools

-   [Create
    account](/w/index.php?title=Special:UserLogin&returnto=B-tree&type=signup)
-   [Log
    in](/w/index.php?title=Special:UserLogin&returnto=B-tree "You're encouraged to log in; however, it's not mandatory. [o]")

### Namespaces

-   [Article](/wiki/B-tree "View the content page [c]")
-   [Talk](/wiki/Talk:B-tree "Discussion about the content page [t]")

### 

### Variants[](#)

### Views

-   [Read](/wiki/B-tree)
-   [Edit](/w/index.php?title=B-tree&action=edit "You can edit this page. 
    Please review your changes before saving. [e]")
-   [View
    history](/w/index.php?title=B-tree&action=history "Past versions of this page [h]")

### Actions[](#)

### Search

![Search](//bits.wikimedia.org/static-1.23wmf12/skins/vector/images/search-ltr.png?303-4)

[](/wiki/Main_Page "Visit the main page")

### Navigation

-   [Main page](/wiki/Main_Page "Visit the main page [z]")
-   [Contents](/wiki/Portal:Contents "Guides to browsing Wikipedia")
-   [Featured
    content](/wiki/Portal:Featured_content "Featured content – the best of Wikipedia")
-   [Current
    events](/wiki/Portal:Current_events "Find background information on current events")
-   [Random article](/wiki/Special:Random "Load a random article [x]")
-   [Donate to
    Wikipedia](https://donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&utm_medium=sidebar&utm_campaign=C13_en.wikipedia.org&uselang=en "Support us")
-   [Wikimedia Shop](//shop.wikimedia.org "Visit the Wikimedia Shop")

### Interaction

-   [Help](/wiki/Help:Contents "Guidance on how to use and edit Wikipedia")
-   [About Wikipedia](/wiki/Wikipedia:About "Find out about Wikipedia")
-   [Community
    portal](/wiki/Wikipedia:Community_portal "About the project, what you can do, where to find things")
-   [Recent
    changes](/wiki/Special:RecentChanges "A list of recent changes in the wiki [r]")
-   [Contact page](//en.wikipedia.org/wiki/Wikipedia:Contact_us)

### Tools

-   [What links
    here](/wiki/Special:WhatLinksHere/B-tree "List of all English Wikipedia pages containing links to this page [j]")
-   [Related
    changes](/wiki/Special:RecentChangesLinked/B-tree "Recent changes in pages linked from this page [k]")
-   [Upload file](/wiki/Wikipedia:File_Upload_Wizard "Upload files [u]")
-   [Special
    pages](/wiki/Special:SpecialPages "A list of all special pages [q]")
-   [Permanent
    link](/w/index.php?title=B-tree&oldid=594230486 "Permanent link to this revision of the page")
-   [Page information](/w/index.php?title=B-tree&action=info)
-   [Data
    item](//www.wikidata.org/wiki/Q677051 "Link to connected data repository item [g]")
-   [Cite this
    page](/w/index.php?title=Special:Cite&page=B-tree&id=594230486 "Information on how to cite this page")

### Print/export

-   [Create a
    book](/w/index.php?title=Special:Book&bookcmd=book_creator&referer=B-tree)
-   [Download as
    PDF](/w/index.php?title=Special:Book&bookcmd=render_article&arttitle=B-tree&oldid=594230486&writer=rl)
-   [Printable
    version](/w/index.php?title=B-tree&printable=yes "Printable version of this page [p]")

### Languages

-   [العربية](//ar.wikipedia.org/wiki/%D8%B4%D8%AC%D8%B1%D8%A9_%D8%A8%D8%A7%D9%8A%D8%B1 "شجرة باير – Arabic")
-   [Català](//ca.wikipedia.org/wiki/Arbre-B "Arbre-B – Catalan")
-   [Čeština](//cs.wikipedia.org/wiki/B-strom "B-strom – Czech")
-   [Deutsch](//de.wikipedia.org/wiki/B-Baum "B-Baum – German")
-   [Español](//es.wikipedia.org/wiki/%C3%81rbol-B "Árbol-B – Spanish")
-   [فارسی](//fa.wikipedia.org/wiki/%D8%AF%D8%B1%D8%AE%D8%AA_%D8%A8%DB%8C "درخت بی – Persian")
-   [Français](//fr.wikipedia.org/wiki/Arbre_B "Arbre B – French")
-   [한국어](//ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC "B 트리 – Korean")
-   [Hrvatski](//hr.wikipedia.org/wiki/B-stablo "B-stablo – Croatian")
-   [Italiano](//it.wikipedia.org/wiki/B-Albero "B-Albero – Italian")
-   [עברית](//he.wikipedia.org/wiki/%D7%A2%D7%A5_B "עץ B – Hebrew")
-   [ಕನ್ನಡ](//kn.wikipedia.org/wiki/%E0%B2%AC%E0%B2%BF-%E0%B2%9F%E0%B3%8D%E0%B2%B0%E0%B3%80 "ಬಿ-ಟ್ರೀ – Kannada")
-   [Latviešu](//lv.wikipedia.org/wiki/B-koks "B-koks – Latvian")
-   [Lietuvių](//lt.wikipedia.org/wiki/B-medis "B-medis – Lithuanian")
-   [Magyar](//hu.wikipedia.org/wiki/B-fa "B-fa – Hungarian")
-   [日本語](//ja.wikipedia.org/wiki/B%E6%9C%A8 "B木 – Japanese")
-   [Polski](//pl.wikipedia.org/wiki/B-drzewo "B-drzewo – Polish")
-   [Português](//pt.wikipedia.org/wiki/%C3%81rvore_B "Árvore B – Portuguese")
-   [Русский](//ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE "B-дерево – Russian")
-   [Српски /
    srpski](//sr.wikipedia.org/wiki/%D0%91-%D1%81%D1%82%D0%B0%D0%B1%D0%BB%D0%BE "Б-стабло – Serbian")
-   [Svenska](//sv.wikipedia.org/wiki/B-tr%C3%A4d "B-träd – Swedish")
-   [ไทย](//th.wikipedia.org/wiki/%E0%B8%95%E0%B9%89%E0%B8%99%E0%B9%84%E0%B8%A1%E0%B9%89%E0%B9%81%E0%B8%9A%E0%B8%9A%E0%B8%9A%E0%B8%B5 "ต้นไม้แบบบี – Thai")
-   [Українська](//uk.wikipedia.org/wiki/%D0%91-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE "Б-дерево – Ukrainian")
-   [Tiếng
    Việt](//vi.wikipedia.org/wiki/B-c%C3%A2y "B-cây – Vietnamese")
-   [中文](//zh.wikipedia.org/wiki/B%E6%A0%91 "B树 – Chinese")
-   [Edit
    links](//www.wikidata.org/wiki/Q677051#sitelinks-wikipedia "Edit interlanguage links")

-   This page was last modified on 6 February 2014 at 16:42.\
-   Text is available under the [Creative Commons Attribution-ShareAlike
    License](//en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License)[](//creativecommons.org/licenses/by-sa/3.0/);
    additional terms may apply. By using this site, you agree to the
    [Terms of Use](//wikimediafoundation.org/wiki/Terms_of_Use) and
    [Privacy Policy.](//wikimediafoundation.org/wiki/Privacy_policy) \
     Wikipedia® is a registered trademark of the [Wikimedia Foundation,
    Inc.](//www.wikimediafoundation.org/), a non-profit organization.

-   [Privacy
    policy](//wikimediafoundation.org/wiki/Privacy_policy "wikimedia:Privacy policy")
-   [About Wikipedia](/wiki/Wikipedia:About "Wikipedia:About")
-   [Disclaimers](/wiki/Wikipedia:General_disclaimer "Wikipedia:General disclaimer")
-   [Contact Wikipedia](//en.wikipedia.org/wiki/Wikipedia:Contact_us)
-   [Developers](https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute)
-   [Mobile view](//en.m.wikipedia.org/wiki/B-tree)

-   [![Wikimedia
    Foundation](//bits.wikimedia.org/images/wikimedia-button.png)](//wikimediafoundation.org/)
-   [![Powered by
    MediaWiki](//bits.wikimedia.org/static-1.23wmf12/skins/common/images/poweredby_mediawiki_88x31.png)](//www.mediawiki.org/)


This markdown document has been converted from the html document located at:
https://en.wikipedia.org/wiki/B-tree
