-   [Sign up](#signup)
-   [Sign in](#)
    -   Email/Pw
    -   -   -   [Go](javascript:__doPostBack('ctl00$lbSignInGo',''))

-   [Search](#)

-   [Shop](https://shop.cockburn.us)
-   [Recent](/RecentChanges?view=datelist&showversions=1)
-   [Poems](/Poems?view=grid)
-   [Books](/Books)
-   [Talks](/Talks?view=grid)
-   [Articles](/Articles)
-   [Blog](/Blog?view=dlist)
-   [Courses](/Courses)
-   [Home](http://alistair.cockburn.us/)

[Alistair Cockburn](/)
======================

-   [Agile development](/Agile+development)
-   [Articles](/Articles)
-   [Being](/Being)
-   [Blog](/Blog)
-   [Books](/Books)
-   [Burn charts](/Burn+charts)
-   [Categories](/Categories)
-   [Children](/Children)
-   [Complaints](/Complaints)
-   [Cooperative Game](/Cooperative+Game)
-   [Course list](/Course+list)
-   [Crystal](/Crystal)
-   [Education](/Education)
-   [Emotion](/Emotion)
-   [Environment](/Environment)
-   [Ethics](/Ethics)
-   [Facilitation](/Facilitation)
-   [Games](/Games)
-   [humans](/humans)
-   [Humans in software](/Humans+in+software)
-   [Humor](/Humor)
-   [Images](/Images)
-   [Incorrectly Transferred Muffins](/Incorrectly+Transferred+Muffins)
-   [Increments and iterations](/Increments+and+iterations)
-   [Interviews](/Interviews)
-   [Journal of object-oriented
    programming](/Journal+of+object-oriented+programming)
-   [living](/living)
-   [Management](/Management)
-   [Me](/Me)
-   [Metaphysics](/Metaphysics)
-   [Methodology](/Methodology)
-   [Methods](/Methods)
-   [Misc](/Misc)
-   [Motivation maps](/Motivation+maps)
-   [Notes](/Notes)
-   [Object Magazine](/Object+Magazine)
-   [OO design](/OO+design)
-   [Patterns](/Patterns)
-   [People](/People)
-   [Photos of Alistair](/Photos+of+Alistair)
-   [Poems](/Poems)
-   [Process](/Process)
-   [Project management](/Project+management)
-   [Quotes](/Quotes)
-   [Requirements](/Requirements)
-   [Scrum](/Scrum)
-   [SE2K](/SE2K)
-   [Site](/Site)
-   [Software engineering](/Software+engineering)
-   [Swimming category](/Swimming+category)
-   [Talks](/Talks)
-   [Travel](/Travel)
-   [Type theory](/Type+theory)
-   [Use cases](/Use+cases)
-   [Videos](/Videos)

Responsibility-based modeling
-----------------------------

1/2/1999 | ARTICLES: [<
previous](Constructive+deconstruction+of+subtyping) | [next
\>](Using+CRC+cards)

-   RATING: |
-   |
-   Avg 4.0 on 1

**Content** ([single](Responsibility-based+modeling) or
[multi](Responsibility-based+modeling/v/multi) view) |
[Discuss](Responsibility-based+modeling#discussion) |
[History](history/Responsibility-based+modeling) | [Edit](edit/2047)

**Humans and Technology technical memo HaT TR.99.02 (dated 99.03.11)**\

© Alistair Cockburn

Related pages: [Using CRC Cards](/Using_CRC_cards)

Responsibilities are a way to state the rationale of the system design.
The identification and allocation of responsibilities across the system
are the primary activity of design of business models and software. The
identification and allocation of responsibilities as a primary activity
is followed closely and accompanied by reuse of existing components. In
object-oriented modeling and design, responsibilities are defined and
allocated at the same time, whereas in other techniques, such as
structured analysis, they are defined but not allocated.

People seem naturally well equipped to work with responsibilities and
their allocation, perhaps just from the way our societies are built. Dr.
J. Fisher, professor emeritus of Towson State University, wrote, “A
rational society, be it a corporation or a country, can only maintain
itself if personal responsibility and accountability are at its core;
that is, from top to bottom, every agent or citizen must be empowered to
conduct her or his role and to be fully accountable for its
performance.” My suspicion is that people living in such societies
develop a sensitivity to the ramifications of responsibility allocation.
Whatever the reason, personal experiences in teaching object orientation
in various countries were seconded by advanced designers in each of
those places: not everyone is equally good at inventing and allocating
responsibilities, but most people quickly relate to the following
questions and can answer them,

\1. “Is it really the responsibility of this object to handle this
request?”

\2. “Is it its responsibility to keep track of all that information?”

Even newcomers to object design give a quick sensation of comfort or
discomfort with a proposed responsibility allocation. That sensation is
closely in line with the evaluations of experienced object designers. We
seem well prepared to state, “It is not my responsibility to track that
information.”, or, “Yes, it is that organization’s responsibility to
handle this request.”

Responsibility-based modeling (RBM), as described here, is essentially
the same as Responsibility-driven design (RDD), as described by Rebecca
Wirfs-Brock and used in Beck and Cunningham’s CRC card technique. The
first difference is that in RDD, emphasis is placed on inventing
software classes, whereas RBM works from existing business facts and
models. The second is that the CRC card technique has been separated out
as a particular walk-through and brainstorming technique, distinct from
the discussion and analysis of responsibilities in the model. RBM is
done either looking at the essential business relations, or the business
model, or an object instance diagram, or an object interaction diagram.

Although responsibility-based modeling is well described in both the
original article and the book, the developers uniformly commented on the
need to document the interactions between the objects to show the
hand-off of responsibilities. Responsibility allocation is a design
technique, and interaction diagrams document the resulting design.
Fortunately, most OO methodologies support documenting interactions in
some way, calling them alternately interaction diagrams, object
diagrams, or event traces. Jacobson provides a good introduction and
discussion of interaction diagrams.

Responsibility-based modeling is appropriate for more than designing
software classes. It can be applied equally well to the partitioning of
a system into subsystems. A subsystem is just a one-of-a-kind object,
perhaps the only instance of its type. Responsibility-based modeling
appropriately defers concern about the internal structure of the
subsystem and focuses on its role and interaction with its colleagues.

Principles and assumptions:
---------------------------

The guiding principle of this technique is that the central issues
surrounding how a system is partitioned can be captured by asking what
the responsibility of each part has toward the whole. This question
picks up issues of function, function distribution, communication,
locality of control, robustness with respect to change, and so on.

The success of the technique hangs on the assumption that people can
intuitively make meaningful value judgments about the allocation of
responsibilities. This assumption seems to hold. Novices to object
orientation at different levels, programmers and business people, have
been given CRC exercises. Their intuitive evaluations of whether a
responsibility is phrased and placed reasonably matches the evaluations
of experienced OO designers. People seem well trained by society to
answer the following two questions mentioned above:

-   “Is it really the responsibility of this object to handle this
    request?”
-   “Is it its responsibility to keep track of all that information?”

These are the questions that the design will ask themselves repeatedly
as part of their evaluation of the partitioning. This does not mean that
beginning designers will *invent* proper placement from the start, but
rather, that when presented with two designs, they will be able to
appreciate the improvement of one over the other. Such an ability gives
a person a chance to improve their design skills over time.

The responsibilities act as requirements on the subcomponents. A
principle of the technique is that the designers are responsible for
determining that they exist or can be built. The designers say, in
effect, “If we had these components, with these capabilities, we could
deliver the function. We certify that such components either exist or
can be built.” .

Degrees of design freedom resolved in this technique:
-----------------------------------------------------

-   (1) Components from which the system is constructed.
-   (2) Responsibilities and services provided by them.
-   (3) The way they satisfy the requirements as stated in the use
    cases.

By this time in the development of the system, the requirements have
been expressed as use cases, essential business relations, and a
candidate business model. Now it is time to check, find or invent the
most robust components that work together to deliver the behavior
required by the use cases.

The team is responsible for researching and eventually knowing of the
material that can be made available to the design. That includes any
business or data models that exist, documents stating business rules,
design patterns, frameworks, and program components. The business or
data models supply candidate names for components, and specify
cardinality relationships. The business rules supply information about
collaborations and likely areas of change. Design patterns provide ideas
from previous designs. The frameworks and program components supply
ready-make artifacts that can reduce the new work that must be done. It
is for the partitioning team to decide which new components to create
and introduce into the system, and to simplify the design or design task
wherever possible.

Responsibility-based modeling is a recursive technique. It is likely
that the team will create a set of components that need further
partitioning. Those components may be partitioned by the same or another
team. Each team is responsible for the quality of the way their
components work together, and the way they simplify, ease or protect the
design.

Discussion of design by responsibilities:
-----------------------------------------

This technique uses five activities: preparation, invention, evaluation,
consolidation, documentation.

In preparation, the use cases to be used in the design session are
collected. By the beginning of the session, the team has decided what
portion of the system is being designed (limiting the breadth of the
design activity), at what level the design is addressed (limiting the
depth of the design activity), and what use cases are needed to address
the design of the system at that breadth and depth.

In invention, the object types are posed, and components are freely
named as it appears they may be useful in carrying out the scenario.
Responsibilities are assigned, provisionally. Names get changed. More
components get named than eventually get used. Sometimes components from
other levels get named and used until the level difference is discovered
and they get put on the side for future use.

In evaluation, a series of questions and scenarios are posed, to stress
test the design. The posing of questions checks the validity, naming and
long-term usefulness of the component. The posing of alternate scenarios
is “variation analysis”, sometimes called “robustness evaluation”. The
assumptions of the requirements and the implementation technology are
varied to see how much or how little of the design must change to
accommodate them. A design is considered better if the changes required
can be localized to fewer components.

In consolidation, the components that have survived the first two
activities are collected and reexamined for their names and their level.
Components from a lower level are noted and put to the side for later
use. Names are checked for meaningfulness, stability and mnemonic value.

In documentation, the reasons why a particular division of
responsibilities was created is written down, along with scenarios that
illustrate the use of the division of responsibilities. Interaction
diagrams for those key scenarios are drawn, using only the components of
the level being designed. The components that already exist are
identified; the components needing to be designed are specified.

The design uses those activities roughly in sequence. All five
activities must be used before the design is considered complete. It
does happen that the activities are used out of sequence also. That is,
often during component invention, new scenarios are invented, variation
analysis is done to make a selection between two design choices.
Consolidation may be done whenever someone notices that a set of
components are at a different level. The reason for a particular
allocation of responsibilities may be documented whenever the group
feels it necessary, so as not to forget the reason. Some people like to
document the interactions immediately, others prefer to wait until the
design has stabilized. In all cases, consolidation and documentation
have to be checked at the end, both for completeness sake and to make
sure the team is in agreement.

Terms used:
-----------

system: the system under design. This term could refer to the entire
application or major deliverable; it could refer to one of the
components created from a decomposition of the major deliverable; it
could refer to a subsystem. It could refer to an organization of people,
computer hardware, or software, or a combination. Whatever it is that is
being designed. The only requirement is that the system be composed of
communicating parts, because responsibility-driven partitioning works
with the messages and information sent between the parts of the system.

component: Whatever the system is composed of that communicates with
other parts of the system. A component could be a system in its own
right, an organization of people, a person, computer hardware or
software. It could be a type, class or object in an object-oriented
system. It could be a purchased vendor package that must be integrated
into the rest of the system. It could be a set of operating system
services or a database. It could be an program that will not be designed
using object-oriented techniques. In this text, *component* is used as
in the sentences: a system is partitioned into components; this
technique shows how to specify the components that make up the system

responsibility: a promised set of services; the role of the component in
a system. Responsibilities are a component’s contribution to a system,
as they are the services the designers and users of the system rely upon
the component to carry out. The component’s role summarizes the services
it provides in the context of the system.

capability: the possibility of providing a set of services; a
responsibility taken out of context. In the context of a functioning
system, each component has a responsibility toward carrying out the
complete function. When the component is put into the component library,
those responsibilities are taken out of context. To the next designer,
they look like the capabilities of the component. The next designer will
consider how those capabilities can act as responsibilities in the
context of the system under design. In this book, the word
“responsibilities” is used wherever possible, for consistency and
simplicity. The word capabilities is used when referring to components
in the library, out of the context of a particular design.

”*Responsibilitiy-based modeling*”. The nickname for this technique. It
is based on the “responsibility- driven design” (RDD) technique in
Wirfs-Brock’s book, updated in some ways and with simplifications and
amplifications based on additional years of experience with the
technique. The term “responsibility-driven” describes the motivating
principles, namely allocating and evaluating responsibilities assigned
to system components. The technique being described here differs from
RDD in not using “contracts”, not discussing attributes (using the
notion of “contact point” instead), and in not specifying inheritance
hierarchies (using delegation instead).

CRC cards: Component-Responsibility-Collaborator cards. 4”x6” (10cm x
15cm) blank index cards on which get written the name of a component,
its responsibilities, and the names of the components with which it must
collaborate to carry out its responsibilities. The letters CRC were
invented particularly for object-oriented design at the level of
classes, and so the literature refers to CRC as
“class-responsibility-collaborator”. We are using CRC cards at the
higher level of system decomposition, so the letters are given the
meaning, “Component-Responsibility-Collaborators”.

level: the nature of the concerns at a certain point in discussing a
design A component is visible at a level if it has responsibilities
relevant to the nature of the discussion at the moment. One of the
topics in carrying out this design technique is paying attention to the
level, tracking the components relevant to the level being designed, and
putting components from other levels to the side.

variation analysis: the stage of design in which assumptions about the
requirements and the implementation technology are varied, to see how
much or how little of the design has to change to handle the variations.

Discussion of responsibilities:
-------------------------------

There are two kinds of responsibilities, the responsibility to *do*
something, and the responsibility to act as a contact point for
information, in effect, mediating the information. In the first case,
the responsibility is described using an active form of verb and the
meaning of the responsibility is quite clear. The second needs further
explanation.

It often happens that a component is responsible for providing
information to other components and staying current on that information.
It is a valid “contact point” for the information, and its
responsibility is to remain a valid contact point for the information,
however the information evolves, and however the designers eventually
decide to store or compute it.

There are people who come to the design session thinking about the
“state data” that a component keeps, or the “attributes” an entity has.
Neither of these is appropriate for responsibility-based modeling,
because it is concerned only with the services that components provide
each other. The equivalent consideration to attribute and state data is
being a contact point.

There is no external difference between active and contact point
responsibilities. A checking account component may have the
responsibility of “knowing the account balance”. Alternatively, it may
have the responsibility of “knowing how to get the account balance”. The
second may imply to some people that it does not store a current copy,
but calculates it, while the first may imply to some people that it
stores a current copy. In fact, there is no difference, since it might
“know the balance” by computing it, or might “know how to get it” by
storing it locally. The difference corresponds to the difference between
direct properties and derived properties.

Easing the difference between “knowing” and “knowing how to” is
deliberate. The decision of which way to implement the responsibility is
a design decision to be addressed at a separate time and with other
design concerns in mind.

When the design team gets skilled with responsibilities, they may work
by writing down only the most important or summary responsibilities, and
fill in the rest when they finally document the component. However, in
getting started, a team may want to write down everything, not to
forget. It is useful then to keep the active responsibilities at the
top, since they are key to partitioning the system.

A responsibility often consists of other responsibilities, since a
service consists of other services.

From the point of view of applying the technique, either the summary or
the detailed list of responsibilities may be used in partitioning. At
the beginning, the design team may wish to work with the detailed list
of services to be sure no gaps are present. Eventually, they should work
with the summary statement, as it is much faster. The detailed list of
services will be worked out eventually.

For example, a bank account may have the responsibility of handling and
tracking all the transactions to that account. The individual services
are add a transaction, remove a transaction, create a transaction to
handle monthly charges or interest calculations, etc. Writing “handle
and track transactions to the account” is easier to write, read and work
with while the responsibilities are being partitioned. The complete list
can be created over time.

Discussion of components:
-------------------------

The creation of a component is usually an assertion of one of two
things:

\(1) The component represents something tracked and managed by the
business,

\(2) The component is a point of design variation, capturing the common
characteristics of several possible solutions.

\(1) If the business manages “customers” and “orders”, then Customer and
Order need to show up as components at some stage of the design. Their
absence would mean that the design is not complete, that they will show
up at another level of discussion, or that the term is just a nickname
for some other thing that the business really manages.

\(2) Often, components are created as a placeholders for one from a
choice of possibilities. So often, that the design will be checked to
see that there is a possible alternative implementation for each
component. One of the strengths of responsibility-based modeling and
object-oriented implementation is that a component represents a set of
services behind which various implementations may hide. Defining those
services as a component allows the designers to vary the implementation
over time, without change to the users of the services. That is, the
component serves as a *point of design variation*.

The value of using components as points of design variation cannot be
emphasized enough. A component is checked to see whether it represents a
class of implementations that are likely to appear over time. In
addition, the designers are advised to consider creating a new component
whenever they get bogged down in discussions about the possible
variations in the requirements or the implementation. The new component
will characterize the services required, and make where the decisions
can be varied, providing future safety and permitting the design session
to continue.

A final word on “component”. This technique is largely targeted toward
object-oriented designs, in which the final design is implemented with
classes and instances of those classes. Such an instance is a component,
and the class defines those components. However, not all of the
components in the system are instances of classes. Some of the
components at the lowest level may be programming, operating system or
network or database services. At the end of this technique, they must be
specified. Above the lowest level, a component may be a collection of
object types and instances that have to work together. For the purposes
here, that collection may be treated as a single “thing”, a component,
that must be decomposed further. A framework of any sort may be treated
as a component; a subsystem may be a component in a larger system. If
the project is not an application development project, none of the
components may end up being OO classes at all, but collections of people
and programs. For these reasons, the word “component” is used
throughout, until the very end, when type specifications must be
produced for those components that are types and type instances.

Creating vs. reusing components:
--------------------------------

This technique works toward the use of existing components. The
technique terminates whenever all the scenarios can be delivered using a
combination of existing and newly specified components. This is called
“design with reuse” (as contrasted with “design for reuse”, which hopes
some other project will use the results of this design). Not much of
great use can be said about finding the best components to be used or
reused except for this:

It is the responsibility of the designers using this technique to
identify the best set of existing components to use.

Real productivity gains come from using existing components. It is the
responsibility of the design team at this point to be aware of the kinds
of components that can be pressed into service. Sometimes a component
can be found that nearly does what is needed. It becomes a design issue
whether to use that component directly, create a new component that uses
it, or not use it.

An invoice object type exists for the purpose of representing a business
artifact in the system. An account journal has the purpose of recording
the transactions that occur on the account. Even an ordered collection
is named for its purpose, which is to preserve an ordering of
components. It provides services appropriate to its purpose: first,
next, last, etc. Every object is named for its purpose. In the context
of a design situation, however, a component’s name reflects either the
role it plays at that moment, or the fact that it provide some
capabilities. “Journal”, “strategy” and “broker” name roles. “Fraction”,
“ordered collection” or any of the other collections, or “window” are
likely to be used as collections of capabilities Each kind of object
type has its own value.

When a needed component name is described in terms of its role, look for
an existing component that has those capabilities already. It may turn
out that the existing component can be used, either directly or
indirectly.

A component named for capabilities can be used for multiple purposes. It
is highly productive in this way. However, its name may not correctly
match the abstraction needed, and so, while it serves quite adequately
as a data storage device, it is sensitive to changes in the requirements
on that storage. If they chnage, then not only it will have to change,
but also client components relying on it may have to change. It is,
therefore, brittle with respect to change. To compensate for that
brittleness, the designers must give some of the responsibilities the
correct abstraction would have to the object using it for data storage.
That protects the clients from seeing the change to the data structure
(example follows shortly).

The other choice is to add a component expressly for the needed role. It
will match the needed abstraction, and it will encapsulate its
implemenation choices, so that should the storage requirements change,
the clients are protected by the defined interface (it is robust with
respect to change). The new component may well have poorer reuse
characteristics, however. It is precisely named for its task, and is
less likely to fit into another situation. Also, the designers have just
introduced a new component to the system, adding system complexity. The
new component must be designed, tested, documented, maintained, and
learned by future designers.

The trade-off between reusing an existing component for its capability
and introducing a new, specific component is the trade-off that must be
managed by the partitioning team. The choice is made by sensing the cost
of changing client code versus the cost of introducing a new component
to the system. It helps to make that cost comparison explicit.

One example, two outcomes: The account needs a journal having
responsibilities to add and remove transactions, and mediate transaction
history. The team names a card, “Journal”, then decides that an existing
object type, “OrderedCollection” could be used directly.

Outcome 1: Reuse. This application is not for a bank. The account is a
relatively minor part of the system, and only a few places use the
account and its journal. All services required of the journal are made
the responsibility of the enclosing component, the account. The account
will print the journal, find entries betore or after a certain date,
make a copy of the journal, etc No new component is created for Journal.
The card for Journal is annotated with “OrderedCollection” to indicate
it already exists there.

Outcome 2: Create (with some reuse). The team decides that the concept
of a journal is important to the business, that it will be heavily used
and that the representation of the journal might need to change over
time (for performance or because new responsibilities might be added).
They create a component called Journal, enumerating its services:
present itself in various ways, find entries before or after a certain
date, etc. The object type designers eventually look at the requirements
and decide it will use an OrderedCollection to hold the data
(initially), but that is a later design issue.

\*‘

General Hints:
--------------

If the component is a major concept in the model, widely used, and is
likely to change, then create a new component, and let it be implemented
by one of the available components. The cost of introducing a new
component is likely to be less than the cost of changing the client
code. Mark the existing component as a collaborator.

If the new component needs only a subset of the capabilities of an
existing one, it may be better off as a separate component. The
additional services offered by the existing component may be a hazard to
the component needed. The new component can conceal the inappropriate
part of the existing component’s interface. Mark the existing component
as a collaborator.

If the component is not a major concept of the model, and is either not
used widely or not very likely to change, reuse the capability-named
component directly. The cost of change is likely to be small compared to
the cost of introducing the new component to the system. Consider moving
some of the responsibilities to the enclosing component.

Discussion of levels and subsystems:
------------------------------------

Since a component will often consist of other components, it is
important to control which ones are in the discussion, and which are
outside. Consider a set of components that read and interpret text typed
by the user. At one level of discussion, that set of components is a
single thing, a subsystem of lower-level components. At this level of
discussion, it is sufficient to treat the set as one component, and
discuss the responsibilities of that component in the system at large.
If there is some question as to whether such a subsystem could actually
be designed, or its performance, that component may be unfolded into its
sub-components, and examined. After that examination, it is important to
hide or fold back together the sub-components and work with the
subsystem again as a single component. Managing the number of components
under active discussion is key to working with the technique.

A subsystem is any collection of components with a unified purpose.
Different subsystems can cut across the system in different ways,
producing overlapping component groupings. The “user interface”
components, for example, form a subsystem. The “network” component do
likewise, and are probably disjoint from the user interface components.
However, the “customer” component may well turn out to have a user
interface component and a active processing component and a database
component. The customer component is a sort of subsystem. It, and other
business domain object, overlap with the user interface and the
database, and perhaps the network Depending on the level of discussion,
the “customer” may be treated as a single component, or dissected as a
set of components. It is important to keep track of the purpose of the
discussion, and keep on the table only those components, at their
appropriate levels, as is relevant to the discussion.

A consequence of working with different levels and with subsystems is
that two components sometimes appear to have the same responsibility.
The two components operate at different levels, an outer and an inner.
At the outer level, the inner component is not visible, so it cannot be
sent a message. It is not “visible” to the other components at the outer
level. So a component at the outer level acts as a sort of gatekeeper,
or contact point for that responsibility. It then just delegates the
responsibility to the other, inner component. This delegation of
responsibility is appropriate. The outer component is acting as a
subsystem, appearing as a single component at the outer level, and as a
member of a set of components at the inner level.

Consider a bank account. It has the responsibility to track its
transactions. On closer examination, the account turns out to have a
collaborator, a “journal” component, whose responsibility is do the
actual tracking of the transactions. The discussion of the journal as a
separate component may not be appropriate at the level of discussion in
which the account is a single component. In fact, the decision as to
whether the journal is a separate entity at all may be a design decision
that changes over time. To protect that decision, the account is given
the responsibility to track transactions. Whether it tracks them itself
or delegates that to the journal is its own design decision, not visible
at the outer level.

Discussion of inheritance and polymorphism:
-------------------------------------------

Inheritance

The decision whether to use inheritance is only partly made in
responsibility-based modeling. It is nominated in this technique, and
finalized later, when the component is finalized, or in framework
design. The recommendation to consider inheritance can be made from
responsibility-based modeling based upon common services required across
similar components.

A set of responsibilities shared over a variety of components may be
collected into a new component, a generic version. The new collection of
responsibilities may turn out to be a separate kind of component in its
own right, and not a generic version of the components that contributed
the responsibility. The new component must be evaluated for its
stability and contribution just as any other.

If the generic component survives, it may be cast into implementation in
one of several ways.

The specific components may send it messages asking for the common
service (delegation),

The specific components may inherit its services (inheritance).

Inhertiance is a heavyweight relationship between two components . It is
not always the best choice for implementing the relationship between
generic and specific components. Nor do all implementation technologies
support inheritance. Therefore, the decision to use inheritance,
delegation or some other implementation technique is left as an choice
for the component designers. The team may prepare suggestions on the
similarities between components that will help the designer.

Polymorphism

Polymorphism is the OO term used to express the fact that two components
provide similar services, e.g., an order line item has a value and so
does the order itself. An order may be asked to provide its value, which
it may do by asking each line item for its value, and then adding them
together and altering the sum according to tax laws, etc. The service,
“provide its value”, is polymorphic between order and order line item.
“Value”, as a verb, is particularly varied, since many different things
can have and describe their value in many ways.

Polymorphism provides a savings in conceptual complexity. The fact that
the same verb phrase is used for several components to carry the same
intention, even if the implementation of each is different, means that
fewer verb concepts have to be learned to understand the design of the
system and its implementation. The partitioning team should consider the
value of polymorphism when naming responsibilities.

The issue for the designers is to consider whether the intention of the
service is the same. A satisfactory example in the English language is
“answer”, with answer the door, answer the phone, answer the letter, and
answer the question. An example of what does not work is the slang
English term “flog”, which can be used to mean either beat with a whip
or advertise; these two have different intentions, so two different
verbs should be used, e.g., advertise and whip. Typically, it is quite
obvious whether the use of the same verb phrase is advantageous or
confusing, so common sense suffices.

Design for:
-----------

\1. purity and simplicity of the abstractions named in the components,

\2. the use of preexisting components,

\3. protection against changes in the requirements,

\4. protection against changes to the implementation technology.

Scenarios combined with responsibilities:
-----------------------------------------

Scenarios and responsibility allocation go together hand-in-hand . A
scenario is characterized by its goal, that which the primary actor
*wishes to accomplish* with the system. The system, on its side,
promises to carry out certain functions, which, if it does, allows the
actor to accomplish the intent. For example, a bank employee wishes to
“register a customer’s transaction”. That is the actor’s goal. The
requirements team also give the system the responsibility to log the
transaction by its date, and update and log the account balance. Those
responsibilities show up in the scenario statement.

Inresponsibiltiy-based modeling, the system is partitioned into
components that carry out the system’s responsibilities. The
interactions between the components are documented. To each component,
the interactions between it and its collaborators appears as a scenario!
That is, an actor requests a service or initiates some sequence of
related messages that the component must respond to. When that component
undergoes design, each of those requests and message sequences will be
treated as scenarios for the component.

This repetition of (scenario – responsibility – interactions ) repeats
itself at increasingly specific and detailed levels until one of these
things happen:

\(1) A component is found that can carry out the responsibilities. This
component may be a object type, an external service (such as an
operating system, database or network service), a complex subsystem, or
even a human organization or person.

\(2) The level of “object type” (in the object-oriented sense) is
reached.

\(3) The level is reached of a non-objected-oriented service that must
be designed and implemented. This service is designed using a suitable
design technique for the implementation technology, such as
organizational design for components consisting of people.

Thus, scenarios and responsibilities allocation go together to make a
complete manner of design, and the degrees of freedom resolved by the
design technique are the names of the components, their responsibilities
and the way they work together to deliver the required system function.

Interaction diagrams
--------------------

Functional equivalents of an interaction diagram may be written in text,
drawn as a list of horizontal arrows, or drawn with a graphics editor or
specialized tool. If drawn, it may be drawn in topological view or time
view.

An interaction diagram describes the sequence of interactions between
components in resolving a particular situation. In the textual form, the
sentences are listed in order of occurrence, one interaction per
sentence. In the time view, each interaction is represented as an arrow
going from the message sender’s column to the message receiver’s column.
The interactions are listed in order of occurrence. In the time view,
parallel or unordered activities can be shown. In the topological
(“top”) view, the components are laid out on the page however the author
wishes. An interaction is shown as an arrow gong from sender to
receiver. Each arrow must be numbered to show the sequence.

Steps in RDB
------------

\*‘

### Overview:

\1. Identify scenarios to use; bound the scope of design. Identify the
scenarios in the scope. Order the scenarios to apply. Work with the main
scenario first, using the alternate scenarios as variations.

\2. Role play the scenarios, evaluating responsibilities.

\3. Name at each point the responsibility needed to carry the scenario
toward conclusion. Name an existing component or create a new component
to carry the responsibility. Point to the business model, object
instance diagram CRC card, or whatever is holding the design discussion.

\4. Make sure that each service provider has sufficient information and
ability to carry out its responsibilities.

\5. Consider variations of the scenario to check for the stability of
the responsibility allocation. Play through the original scenario again
to verify it works.

\6. Evaluate the components with test questions and variation analysis.

\7. Ask whether each component protects against future changes or is
something the business manages directly. Check the life cycle of the
components: creation and deletion.

\8. Create variations: ways the requirements or implementation might
change over the life of the system; alternate path scenarios and error
conditions.

\9. Run through the variant scenarios to investigate the stability of
the components and responsibilities. Revise as needed to strengthen the
design.

\10. Simulate if possible.

\11. Consolidate the components by level.

\12. If a set of components are at different levels levels of
abstraction, note to which primary card they are related and their
purpose. Design that set of cards later as a subsystem. Give a mnemonic
name to the scenarios requiring those cards, for easy recall at that
later time.

\13. Document the design rationale and handling of key scenarios.
Document either at the end or just after the handling of a set of
related scenarios has become stable.

\14. Decide which scenarios to document (main, error, interesting ones)

\15. Dcument each selected scenario and why responsibilities were
allocated that way.

\16. List the components being used that already exist.

\17. Specify each new component of the design session’s level.

### Collect relevant scenarios.

Bound the scope of design in width and depth (level). Settle in advance
what is being designed, what is not, and how to know when the design is
done. Settle at what level the design is being carried out, and what
topics are relevant to the design.

Gather together and read the scenarios relating to the current scope of
design. At the outermost system level, choose scenarios developed with
users. If an internal subsystem, work from the scenarios,
responsibilities, and interaction diagrams created in the previous
design sessions. If there are no scenarios and this is entry to the
project, go through scenario design.

Review the technique “Fact Analysis” and follow the same steps for
reconciling terms, concepts and design fragments from the business model
with those in the requirements model and those suggested during this RBD
session.

Choose first a simple scenario that sets up parts of the system.
Increase to more difficult ones. The more difficult ones expose more
decision points and should be reached as soon as possible.

If you are comfortable with both the problem domain and CRC cards,
choose a scenario handling a more complex situation first. Choose next a
series of scenarios in the order they apply to the subsystem. Choose the
most complex scenario of each similar group.

The intent ion is to reveal the most decision points, and to show up the
most complex collaborations between components. More comples situations
do this faster.

Example: for an insurance company insuring houses, creating a quote for
a set of houses in different states or countries is complex and reveals
the issues quickly.

If the most complex situation proves too difficult, back up to a less
difficult situation, but get back to the difficult case again as soon as
possible.

Select the main success scenario to use first. The main scenario is the
one that delivers the primary actor’s goal in the most direct fashion.
Use the alternate scenarios as variations within a single walkthrough
and role play, as appropriate. Any that are not covered in the role
play, apply to a separate walkthrough and role play. Treat an
alternative scenario as a variation during walkthrough of the main
scenario if it reveals interesting decisions in the components being
used in the main scenario. Treat an alternative scenario separately if
requires invention of components that do not show up in the main
scenario. Apply the failure scenarios as tests to the design for the
related success scenarios; finalize the design for the failure scenarios
last.

### Identify components and their responsibilities for each scenario.

Use a combination of “active” and “contact point” responsibilities. Have
active responsibilities start with an active verb.

Examples: “compute new balance”, “find all customers with given
characteristics”, “refresh the screen”, “maintain consistency of
customer addresses.” “introduce transaction.”

State active responsibilities in a generic form, so similar
responsibilities can be identified.

Example: **Better**: “display”, or “display on screen”. **Worse**:
“display triangle on screen.” Reasoning. When the design is done, it is
likely that a number of components will say, “Display on screen.” In the
review of the responsibilities, these will be readily spotted. A review
of these similar responsibilities will result in a design decision
between:

\(1) there is a generic component that has not been identified, and to
whom these can all delegate their responsibility, Mark it as a possible
place for inheritance.

\(2) there is no generic component. Rather, there is polymorphic
behavior. The responsibilities should be reviewed again to make sure
that they carry the same intent, and that a client is able to make a
safe assumption about the behavior of the component when calling upon
that responsibility.

Identify the information the component mediates (for which it is the
contact point). Discuss contact points instead “state data” or
“attributes”. It may not yet be time to decide that a component must own
certain data or attributes. The implementation is likely to evolve over
time, invalidating those assumptions. It is possible that the properties
get separated out from the original component, i.e., the component will
get unrolled. **Example:** Knowing the balance on an account is a conact
point responsibility of the account. It may come to pass that the
balance is computed dynamically. Recording the bank account is an
contact point for the balance (a) records the necessary responsibility,
(b) leaves the decision open as to how and when the balance is computed
and where and whether the result is stored. Be alert for the opportunity
to reuse an existing component. The design team is responsible for
considering the various options of reuse versus new component creation.
Whenever a component name describes its *role* instead of its
*capabilities*, look for an existing component that already has those
capabilities. Decide whether to create a new component, protecting the
design, or reuse the existing component, saving development, based on
the number of other components that reference it and the likelihood of
change.

General Hints

\(1) If the component is a major concept in the model, widely used, and
is likely to change, then create a new component, and let it be
implemented by one of the available components. The cost of changing
components that reference it is likely to be greater than that of
introducing a new component. Mark the existing component as a
collaborator if appropriate.

\(2) If the new component needs only a subset of the capabilities of the
existing one, it may be better to introduce the new component. The
additional services offered by the existing component may be a hazard to
the component needed. The new component can conceal the inappropriate
part of the existing component’s interface. Mark the existing component
as a collaborator.

\(3) If the component is not a major concept of the model, and is either
not used widely or not very likely to change, reuse the capability-named
component directly. The cost of change is likely to be small compared to
the cost of introducing the new component to the system. Consider moving
some of the responsibilities to the enclosing component.

Here is One example, with two outcomes: The account needs a journal
having responsibilities to add and remove transactions, and mediate
transaction history. The team names a card, “Journal”, then decides that
an existing class, “OrderedCollection” could be used directly.

Outcome 1: Reuse. This application is not for a bank. The account is a
relatively minor part of the system, and only a few places use the
account and its journal. All services required of the journal are made
the responsibility of the enclosing component, the account. The account
will print the journal, find entries betore or after a certain date,
make a copy of the journal, etc No new component is created for Journal.
The is annotated with “OrderedCollection” to indicate it already exists
there.

Outcome 2: Create (with some reuse). The team decides that the concept
of a journal is important to the business, that it will be heavily used
and that the representation of the journal might need to change over
time (for performance or because new responsibilities might be added).
They create a component called Journal, enumerating its services:
present itself in various ways, find entries before or after a certain
date, etc. The designers eventually look at the requirements and decide
it will use an OrderedCollection to hold the data (initially), but that
is a later design issue.

Be alert for signs that a new component is needed.

The requirements model and the business model are full of candidate
business terms and concepts.These are not to be accepted as components
at the current level of design unless they demonstrate that they have
responsibilities essential to the scenarios at this level of discussion.
It may happen in the meantime that component shows up at a different
level. It occasionally happens that the design team decides that the
term is used ambiguously within the company, and provides different
components for its different meanings.

It often happens that there are competing nominations for a component,
or component’s name. Sometimes the team agrees that one of the two names
carries the needed responsibilities better than the other, and so the
second nominee can be dropped. On occasion, neither nomination
completely dominates the other, but rather, the two alternate in
usefulness. In this latter case, the design team needs to explore
whether there is a common abstraction lurking in the background, or
perhaps a third abstraction that can pull out common elements of the
two, or whether there is a miscommunication about the two names.

Components protecting design variations. These are the most valuable
components.

Discussion may get bogged down over whether some part of the system will
be evolve “this way” or “that way”. If the moeling of another part will
affect the design of this part, this is the moment to consider naming a
component that represents “however” the other part is designed. Often
there is a meaningful abstraction that carries responsibilities and
services that apply to all of the suggested implementation alternatives.
That abstraction becomes a key component that protects a design
decision. It protects the right to change the decision later, or even
dynamically at run time. It defines a necessary service interface that
the clients of the component need, regardless of the implementation. The
identification of such design points is critical to ensuring the
stability and robustness of the system over time, and is key to
responsibility-driven, object-based, and object-oriented systems. Later
in the session, every component nominated will be checked to see whether
it provides this kind of value.

Example: In the design of a map system, the team got embroiled in a
discussion of whether the routes are going to be precomputed,
dynamically computed, how they will be represented, etc. At this point,
the component “Routing Strategy” was introduced. The Routing Strategy
component has the responsibility to obtain a route through a list of
locations. Once this component is created, the topic of computing and
storing routes can be deferred. In fact, in an initial prototype, a
preselected list of routes can be hardcoded in the Routing Strategy
component. In initial versions, the routes can be computed on the fly.
In later versions, there can be a mix of dynamically computed routes and
precomputed routes sitting on a database. The Routing Strategy object
defined the services that are common to all implementations, and permits
the growth of the system over time.

Design Patterns

The book, Design Patterns, by Gamma, Helm, Johnson, Vlissides, contains
many ideas for protecting design decisions. The “strategy” idea just
referenced is included in the book. Familiarize yourself with the book
and learn when to introduce a component from the Design Patterns book.

Homogeneous collections.

Collections of objects of the same type show up repeatedly, at all
levels of design. Sometimes the items in the collection are relatively
uninteresting, and the interesting behavior shows up in the collection
(e.g., ledger lines are dull, collections of ledger lines are
interesting). Sometimes the collections are oriented toward the user
interface (e.g., list boxes), sometimes they are oriented toward the
database (e.g., persistent collections). Be prepared to introduce
homogeneous collections your components. Many of these collections are
already named in the essential business relations.

When working with a collection, pay attention to which component “owns”
it, creates it, initializes it, keeps knowledge of its contents
consistent (e.g., supposing there are many other components in various
stages of browsing or updating it).

Sometimes good abstractions are discovered after rather than before
design. That is, only after working with the scenarios and components
for a while does it become apparent that several component could be
viewed as variants of a generic abstraction, or that they could
fruitfully delegate to another abstraction.

If the components having common responsibilities otherwise have little
in common, consider introducing a new component to which these
components delegate their common responsibilities.

If the components seem to be variants on a common theme, or the
responsibility just cannot be delegated further, look for the
abstraction that could be the generic component. **Be aware of some
common situations.**

Delegating to a different level.

A component may delegate its responsibility to a component at a
different level. It will appear that two cards have the same
responsibility. The difference between the two components is that the
second one is not properly known to the component sending the request to
the first.

Difficulty in allocating a responsibility (too many places or no
places).

Responsibility appears to belong in too many places:

Some component has been too broadly specified. Reconsider each
component, the abstraction it represents, its purpose in the system. Try
to decide whether one of the components has been too broadly specified.
It is possible that in its new definition, it no longer answers ‘yes’ to
the question, Is it really this component’s responsibility to handle the
responsibility?

A new component needs to be named.

The reason that the responsibility appears to have many homes is that
there is an unnamed component lurking in the background that needs to be
named. Once it is brought out, it can take the common part of the
responsibility.

Example: Train engines are hooked to cars and a caboose. There is
difficulty in deciding whether hooking the engine to the caboose the
responsibility of the engine or of the caboose. **Solution:** There are
missing abstractions, that of a train configuration, and that of a
train. The configuration of engine, cars and caboose is likely to be
something that the system will want to manage, and want to vary over
time. It may be correct to introduce “train configuration” (or the
equivalent, correct term from the transportation industry). It is
correct to give the train configuration the responsibility to register
the addition of each engine, car and caboose.

A design decision must simply be made. Sometimes there is simply a
choice that must be made. There are cases where there are no further
things to be considered, and two components appear equally well suited
to the task. The design will probably survive either decision. Later
developments may reveal which was to be preferred.

Example: A warehouse contains boxes. Does the warehouse know the
location of every box, or does each box know its own location? Each way
can be made to work, each has its characteristics, neither is clearly
“better”.

Responsibility appears to belong nowhere:

Some component is too narrowly specified. Reconsider each component, the
abstraction it represents, its purpose in the system. Try to decide
whether one of the components has been too narrowly specified. It is
possible that in its new definition, it answers ‘yes’ to the question,
Is it really this component’s responsibility to handle the
responsibility?

A new component needs to be named. The reason that the responsibility
appears to belong nowhere is that there is an unnamed component that
needs to be found. Once it is found, the abstraction is represents can
be seen and named..

### Evaluate components and responsibilities.

Consider alternative assumptions and scenarios to check and improve the
design. Hypothesize additional scenarios as needed.

Check alternate scenarios for variations in outcome, creation and error
conditions.

For each scenario, walk through every variation to check that the
responsibilities named and their allocations work correctly. For the
first several, it is likely that new components will have to be named.
After a while, the scenarios will used the named components in a very
obvious way, so that the walkthrough will be brief.

Completeness criteria. It is not necessary to walk through every
variation of every data condition. It is only necessary to walk through
scenarios that reveal something new about the working of the components.
Once the walkthrough of a scenario reaches a point that has already been
discussed in depth, the facilitator may say, ”... and we have
established that that works”. If that point establishes the correct
delivery of the scenario, the scenario is ended. If the scenario
continues on later in a different way, the walkthrough picks up at the
point at which something new happens.

Consideration of initial scenarios and error causing scenarios is
important. The error condition scenarios define against what errors the
system must be able to protect itself. Initialization scenarios reveal
which components are able to create which others. Both need to be
documented.

Examples: In car rental: the client rents a car, crosses a time zone and
returns the car before it was rented. In banking: a new customer
requests an ATM card.

Check likely requirements variations.

Consider the evolution of the system. What sorts of enhancements might
be requested by the customer after using the system. Typically, the
initial requirements statement contains simplifying assumptions for the
first version, which will be changed several versions later. The
walkthroughs are well suited to discussing some of the likely future
enhancements or requirements changes. A new component can be put into
place to protect against a particular requirement change (as per
“Components protecting design variations”, above). The component will
allow the first system to be built with the simplifying assumption, but
contain a place for the enhancement.

The design team will have to decide what requirements variations to
consider within the scope of the design effort. A requirements variation
such as , “consider including everyone in the world” may not make sense
for a local office system, but may for a telephone system.

Example: In the map system example used earlier, the requirements may
say, “obtain a route between two locations from the database”. The team
is concerned (a) that a future enhancement will be to have a route go
through multiple locations (e.g., “find a route from Boston to L.A.
through Chicago and Santa Fe), (b) that a future enhancement will be to
use routes computed dynamically. The team introduces a component, “List
of locations”, instead of always assuming two locations, and a
component, “Routing Strategy”, that conceals whether routes are looked
up or computed. Initially, the routing algorithms will only work for two
locations in the list, and will always look them up in the database.
When the later enhancements are requested, the use of the list can be
expanded, and alternative classes implementing different routing
strategies may be added.

Likely implementation variations. Likely variations include looking up
answers versus computing them, and likely changes in the business.

Validate each component’s name and responsibilities.

“Is it really this component’s responsibility to handle these requests?”

Your intuition is your guide to what responsibilities go with the
abstraction the component represents. Use your intuition and your
judgment.

“Does this component already exist?”

Look into the components and design pattern catalog again to see if an
appropriate component can be found, knowing what you know now.

“Does this component have too few responsibilities?”

Be alert for a component that is just a glorified responsibility. A
component is supposed to capture an abstraction that has a purpose in
the system. It may happen that what appears at one moment as a
meaningful component is really just a single responsibility left on its
own. That responsibility could be assigned to a component.

Alternatively, the few responsibilities characterize a “role” that a
component can play. Look for a component that can play that role.

Look for another component that does similar work, see which of the two
components carries the better abstraction for the system, and see
whether one of the two components can be eliminated.

“Does this component have too many responsibilities?”

Be alert for a component that ends up as a kitchen sink full of
responsibilities. A component is supposed to capture an abstraction that
has a purpose in the system. A component with too many responsibilities
may not be a single abstraction, but several, mixed together. A complex
component is harder to reuse than a simpler one that captures an
abstraction in a purer way.

A place to allow lots of responsibilities is a large subsystem in a
large system. A preferable reason for creating a subsystem may be that
it has a single or a few key responsibilities. However, there may be
other valid reasons to create a subsystem, which leave it with a bag of
responsibilities.

“Does this component protect design decisions? future subtypeing?
implementation variations?”

Many components either deliberately protect design decisions as
described earlier, or can support multiple variants or implementations.

If a component does not do one of these: Perhaps it is a necessary item
the business has to manage and hence necessary to keep. Perhaps its
responsibilities might fit somewhere else, allowing it to be removed.
Perhaps it might be better named, so that a better abstraction will
surface.

“Does the name accurately reflect the abstraction and the capabilities?”
“How easy will it be to find and use the component by its name when it
is viewed out of the context of this system, during later reuse?”

Names are terribly important . They are what people focus on when
understanding the system and looking for existing components to use.

“You have to be able to make assumptions about a component based on its
name.” (Ward Cunningham).

“If your teammate can’t make assumptions about your code, you are just
laying grass over quicksand.” (Hayden Lindsay).

Names and naming habits to use: Name according to the abstraction
represented, **e.g.,** bankingTransaction. Name according to its
capabilities, not its role in the system.

Names and naming habits to avoid:

“manager”. Consider “broker”, “librarian”, or similar. Example: The
responsibility is to obtain the correct table for use. Try using “Table
Librarian” in place of “Table Manager”.

”-er” suffix when applied to a formula. Consider “policy” or “strategy”.
Example: Responsibility is to obtain a formula for a rate. Try “Rating
Policy” or “Rating Strategy” instead of “Rater”.

“data”. Try to find the abstraction it represents.

“What other component(s) control the life cycle of the component?”

How, when, by whom is it created?

How, when, by whom is it destroyed or deleted?

Make sure these questions have answers available in the partitioning,
otherwise go back and handle them.

“What changes in available behavior does it go through and how are those
handled?”

Example: Credit card corporation: A customer goes from being a prospect
to a plain cardholder to a preferred cardholder, possibly to a
delinquent cardholder, to a former cardholder. Each of these “states” of
being a customer of the credit card corporation has different behavior
associated with it. The design must account for migration between states
and the different capabilities that come with it.

Entities that change behavior over time are common in business systems.
Be alert for them. The changes in behavior that come with changes in
states are not handled easily by current technology. They must be
designed deliberately and carefully.

“Are the responsibilities phrased in active terms?”

Question any component that simply acts as a contact point for
information. Some of these are needed (**e.g.**, a Banking Transaction
may only be used to hold the transaction data together), but sometimes
they can be given greater responsibilities.

“It takes fewer magic carpets to cover an application than it does
rugs.” (Rebecca Wirfs-Brock). A component with active responsibilities
is like a magic carpet. A component with no active responsibilities is
like a rug.

use words like:

“Obtain…”

“Add…”, “Remove…”, “Introduce…”

“Sort…”

Try to avoid words coming from the computer profession terms and words
like:

“Hold…”

“Manage…” (this word is occasionally necessary)

“Know…” (there is a separate place for “contact point” information)

“Is this component implementable?”

Do check down a level to make sure a component is implementable. The
design team declares, with the design, “If we had these components, we
could deliver the needed function in this fashion.” With that
declaration comes the assertion that the components are available or can
be built.

Check the pattern of communications.

Are the communications intensive around one component?

If one component dominates the communication pattern, it is possible
that it has too many responsibilities and knows too much about too many
parts of the system (it is a “manager”). This could become a fragile
part of the system: if any of the parts it knows about changes, it may
have to change. If it is a large and complex component, then the chances
of introducing an error or propagating changes is higher. Consider
distributing its responsibilities.

Are the communications intensive between two components?

Two components communicating with each other intensively evidently need
to know a lot about each other.

Perhaps they ought to be combined into one component. **Example:** In
Smalltalk/V, the Model-View-Controller separation had up with intense
communications between the View and the Controller for GUIs. By popular
demand, the View and Controller were combined to make an Interactor. The
new abstraction was considered by many easier to use.

Perhaps there is a third abstraction waiting to be found. Sometimes the
communications represent the information and responsibilities of another
component, which has not been named and is split across the two
components.

At this point you should have an improved stack of cards, labeled with
responsibilities, that carry out the required design better or requiring
less new design.

At the end of the design session, when the most complex scenario has
been designed to satisfaction, prototype the design to check the flow
and improve the evaluation of the design.

Often, implementing the scenario will reveal that the hand-off of
responsibilities is not perfect, or that information is not available at
a point where it is needed. Finding such a situation during the design
period pays off. Consider the computer another member of the design
team, able to offer feedback on the design.

Implement just the components needed, running from the most available
user interface (e.g., direct program control, Transcript Window, or
equivalent).

Walk through the execution of the system to check that all the
information and responsibilities flow correctly.

Use the implementation to validate or even create the documentation for
the scenario. The implementation is unambiguous and guaranteed to show
all the information that has to pass from one component to another. Some
tools support the creation of interaction diagrams from the execution
trace.

### Document the design rationale and key scenarios.

Keep the main scenario of each scenario. Keep the error scenarios of
each scenario. Keep any other scenario that has an interesting
rationale, or shows non-obvious communication between components. This
is a matter of judgment on the part of the design team and the
documentation requirements of the project (traceability). Too much
documentation is burdensome without commensurate value. Too little
documentation causes confusion.

Document each selected scenario. Create an interaction or object
instance diagram using the components at the declared level. Give each
scenario and interaction diagram a name. If several scenarios have a set
of interactions in common, consider making a sub-scenario with
interaction diagram(s) to describe the common part. Then reference the
sub-scenario in the interaction diagrams having those interactions in
common. The sub-scenario acts is a scenario at a level too detailed to
have been mentioned earlier. The use of sub-scenarios shortens the
documentation considerably without loss of detail.

The interaction diagram must show the scenario from its beginning to the
completion of the scenario. The purpose of the diagram is the declare
how the components cooperate to deliver the required function (even if
the function is only returning an error condition). Therefore, the
diagram must start with the initial message that starts the scenario,
and end with the final resolution of the scenario.

Describe why the responsibilities are partitioned they way they are, if
there is a business or non-obvious reason. The partitioning of the
responsibilities may reflect some basic business process or assumption.
This information is easy to lose and useful to come back to later. Write
it down at the top of the interaction diagram and eventually as a
comment in the program code.

Example: “The computation of the insurance of three houses in different
zones is based upon primary house. The rate for the insurance is based
on the rate for the primary house modified by the rates for the
secondary houses. Responsibility for computing a base rate is given to
the primary house. Responsibility for modifying a rate is given to a
secondary house, which returns the new rate for the previous houses plus
itself.”

Sometimes a lot of work went into allocating the responsibilities. The
thinking behind the allocation should not be lost, as it is likely not
to be obvious to other people.

Example: “The routing strategy component exists to preserve the freedom
to choose between stored and computed routes. It has the responsibility
to obtain a route, however that route might be stored or computed.”

Sometimes the names of the components makes the allocation of
responsibilities obvious. These need not be documented.

\*\*

CRC Card Exercises
------------------

A CRC card is an informal work space intended to capture rapidly
changing information. Different sizes may be used as available (common
sizes are 3”x5” and 4”x6”, with advocates for each). The card describes
the information used by instance of the component. In the
responsibility-based modeling activity, the card is treated as an
instance. Should it become necessary to create a card describing the
class as an object itself, have the name on the card end in the word
“class” (e.g., Checking Accounts class).

The component name is written across the top. The responsibilities are
written in three groups.

First is a brief summary, or synopsis, of the responsibilities of the
component, its role in the system. This should be a short phrase, or
perhaps two (see example).

Next, in a list down the left side of the card are the active
responsibilities, with a line or arrow to the right, ending in the name
of a required collaborator for that responsibility. An active
responsibility starts with an active verb, such as “track”, “compute” or
“find”. Avoid the word “manage” where possible, and the passive verb,
“hold”.

Last are the contact point responsibilities, the information the
component mediates. Often these will come from the attributes in a data
or business model. If there is some question whether a service belongs
in the active or contact point responsibility section, choose
arbitrarily with a slight inclination toward the the contact point
section. It really does not matter a great deal. In the end, all
responsibilities will be treated equally. The purpose in having the
sections is so that attention can be focused on the summary and active
responsibilities, which are the primary vehicle for partitioning the
system. The contact point responsibilities are needed for component
specification, and to demonstrate how the components deliver the
required function in a documented scenario.

### Set up the activity.

Use a centrally visible and accessible table.

Have available a stack of blank CRC cards (see Figure, “CRC Card”).
Place them on the table within reach of anyone or give everyone a set
for themselves.

Ideally 2-4 people. CRC works best when there is a discussion partner.
More than 4 people results in people sitting idle and bored or diverting
the discussion.

Walk through and role play a scenario, inventing and identifying
components and responsibilities. Start by stating the message and
information that starts the scenario, and the intended outcome. Pretend
the design participants are the individual components, and have to
deliver the function in the way the scenario says. The people role play
the components.

On feeling embarassed. It feels odd to begin with, pretending to be a
component and not knowing what the component should do. Although it may
feel odd, it is by pretending to be the component that a person can best
address whether a responsibility is correct or not.

Ask what kind of component should handle the entry. Pick up the card for
that component. Hypothesize the responsibility and the component,
inventing new ones if necessary.

; \_Note:\_Here is your big opportunity for reuse. Use things that
exist, if possible.

Identify what the component would need to get its job done. Look into
the catalog of existing components for a component that already does it.
If none does, carry on asking what kind of component should have the
needed responsibility.

Continue in this way until the scenario reaches its conclusion, using
the responsibility-based modeling technique.

\*‘

Tip: When things get moving rapidly, sometimes there is no time to write
down the name of the responsibility or the name of the component. At
those times, just point to an existing card or even to a blank spot on
the table, either naming the component or just saying, “this one”. If
the design works, the component will show up consistently, and a good
name can be discovered for it and its responsibilities. A good name is
so important that it is worth delaying the naming of a component until
its purpose is clear and agreed upon.

\*‘

Tip: Pay attention to the level of the discussion. As mentioned above,
it is fine to go deeper than the level of the design session
periodically. The components nominated at other levels may become
elements of subsystems that will eventually be designed. Note the
components that belong to a different level, and either stack them under
the card that is calling for their use, or set them to the side, so that
they can be pointed to or reintroduced when there is a question.

Tip: Only use one pen. That way, it does not happen that one person
changes the name, responsibilities or collaborators without the rest of
the team noticing. The pen acts as a synchronization mechanism for the
group.

The role play is an act of creation, in which design points are
discovered, components and responsibilities are nominated, and design
decisions are made. A choice between two names, between the need for a
component or not, between two places to allocate a responsibility, is
made is made by comparing the two choices against a set of scenarios.
That choice is preferred which responds best to the scenarios. The
choice is made on the basis of:

\(1) the responsibilities allocate in a more natural way,

\(2) the communication pattern between components is simpler,

\(3) the locus of change for varied assumptions is smaller.

\(4) (Occasionally, there appears no discernible difference between two
choices. In this case, just choose one and proceed. See “Common
Situations”, below.)

It is therefore often appropriate in making a well-considered decision,
to interrupt a scenario on occasion and explore some variations. The
variations may try alternative assumptions about future requirements or
implementations, or of usage.

### Manage the cards.

Typically, name a card immediately, but no great need to.

Sometimes people want to nominate a component. Fine. Put the card on the
table. Ask what its responsibility is. If there appears to be a
responsibility, write it down, either as an active responsibility or as
a contact point. Let the card survive on its own merits.

Sometimes people can tell that a card needs to be there, but do not know
what its name or exact function is. Fine. Put a blank card there. Let
its personality grow over time until its name and responsibilities
become clear. Often the responsibilities will become clear first, and
from the responsibilities a name will be formed.

Sometimes a card is named, but its responsibilities evolve to a point
where the name no longer matches. Draw a line through the old name and
write the new. Or, get a new card, put the new name and the
responsibilities on it. Put the old card to the side.

Collapse cards for subsystems out of scope.

Frequently, the discussion goes to a different level of design. Cards
are created that do not apply to the current level of design, but are
useful for demonstrating the consequences of a design choice or for
showing how a component would likely carry out its responsibilities.
Rather than let the cards clutter up the table and the discussion,
collect the cards that help implement a responsibility. Place them
behind the component they help that is at the correct level of
discussion. Then they can be brought out for examination when they are
needed, and kept out of sight otherwise.

Similarly for generic components and variants. Occasionally, the
discussion will center around the generic component. The variants will
be of minor importance, but are present to establish their presence.
Place the variants under the generic component, so the generic component
can carry the conversation.. The variants can be brought out again as
they are needed.

Ways to collect and arrange the components:

By level of implementation. That is what has been discussed so far.

By privacy. Arrange the components differently if they can be publicly
know at this level of discussion, or if they are private in some way.
Chances are the private components are at a different level.

By lifetime. Look for components that are significantly shorter or
longer lived than others. Consider whether they belong at the same
level. Collecting the components by their lifetimes occasionally reveals
something of interest about the system, the components, or their
communications.

Let unused cards drift out.

Of the many cards that get nominated, some do not survive through the
design session. If it appears that one or more cards are not likely to
see action, they may be allowed to drift to the side or back of the
working area. If they develop an importance, they can be brought back
into play.

At the end of the session, if there are cards that were nominated but
not used, bring them forward again for review. It should be clear that
they did not manage to keep any responsibilities and so will not reach
implementation. If there is disagreement on this, the person wanting to
keep them must find a scenario in which they carry responsibilities.

Use interaction diagrams with or even instead of cards.

A design group comfortable interaction diagrams may decide to let the
interaction diagram carry the discussion instead of the CRC cards. This
is a matter of personal preference, since some people need to see the
message flows to visualize the interactions. The time view form of the
interaction diagrams carries exploratory discussion better than the top
view. CRC cards still offer greater flexibility and mobility in an
active design session.

If interaction diagrams are used instead of cards, write the key
responsibility of each component by it on the diagram.

At a design review, the interaction diagrams are already available as a
result of the design session. The interaction diagrams may be used to
illustrate how responsibilities are passed along and invoked. A listing
of the responsibilities of the components must be available during the
review, either as a list, or on the CRC cards, or as annotations on the
interaction diagrams.

At this point you should have a stack of cards with responsibilities,
and a stack of interaction diagrams showing how the components deliver
the scenarios.

### Consolidate components by level.

Identify the components that are appropriate for the level of design
declared at the beginning of the design seesion.

The design of the system will be presented to readers at different
levels. To simplify the understanding of the design, and to isolate
changes in the future, the design of the system should be documented at
a consistent level. Subsystems or components that carry out the
responsibilities on behalf of a component on the declared level are to
be collected separately and not used in the discussion of the system at
the declared level.

For a business application, the first level should consist only of those
components meaningful to a business person concerned with verifying that
the workings of the system are consistent with the workings of the
business. Each scenario must have a complete description and fully
connected walkthrough using only the components at this level. A
connected walkthrough is one in which all the responsibilities and
needed information are visibly available using the selected components.

At any subsequent level, the scenarios for a subsystem must have a
complete description and fully connected walkthrough using only the
components that are appropriate for the declared level. It is up to the
design team to evaluate which components are appropriate for the level
and which belong to the implementation of a component at the declared
level.

The intuition, business knowledge and common sense of the design team is
the guide for what belongs at a level.

Collect separately the components and subsystems at deeper levels.

Keep the cards for later use.

The components outside the scope of the design are still useful.
Probably, one of the design team members will be involved in the design
of the subsystem using those deeper components, and will be able to use
those cards to start the design.

It is not necessary to document the use of the components at a deeper
level. Someone in the room may want to document their use to help with
future design or future reference..

### Discussion

[Edit](edit/3016)

Typo early on: “is essentially the same as Responsibility-based modeling
(RDD)” should be ”..Responsibility-driven design (RDD)”?

-by Bob Corrick on 5/20/2010 at 4:20 AM

*(nice catch, Bob, thank you. corrected)*

Display Name

Email (not displayed)

Comment

**NOTE:** Comments containing html hyperlinks will not be saved.

Verification

![CAPTCHA Code
Image](LanapCaptcha.aspx?get=image&c=default_ctl00_cphbody_ucform_captverify&t=ee582ef4a674447fa171ee78f8dd7c87&s=s0lmiffi5hovvu55lq4tjb55)

[![Speak the
code](/WebResource.axd?d=GRXMzSLvATRZcnyXM9MRpOBiWOLFVGal7QJ3K7Gp83Vr6IZEuw-Tfvo73sTru1GMfdsV36X4xfo9LmTe_Gn_uQ2&t=633783207159687500)](LanapCaptcha.aspx?get=sound&c=default_ctl00_cphbody_ucform_captverify&t=ee582ef4a674447fa171ee78f8dd7c87&s=s0lmiffi5hovvu55lq4tjb55)

Remember Me

[Post
Comment](javascript:WebForm_DoPostBackWithOptions(new%20WebForm_PostBackOptions("ctl00$cphBody$ucForm$lbSubmitComment",%20"",%20true,%20"discussion",%20"",%20false,%20true)))

[Digg
It](http://digg.com/submit?phase=2&url=http://alistair.cockburn.us/Responsibility-based+modeling&title=Responsibility-based+modeling "Submit to Digg")
[Stumble
it!](http://www.stumbleupon.com/submit?url=http://alistair.cockburn.us/Responsibility-based+modeling&title=Responsibility-based+modeling "Stumble it!")
[Del.icio.us](http://del.icio.us/post?url=http://alistair.cockburn.us/Responsibility-based+modeling&title=Responsibility-based+modeling "Submit to Del.icio.us")
[Technorati](http://technorati.com/faves?add=http://alistair.cockburn.us/Responsibility-based+modeling "Add to Technorati Favorites")
[RSS](feed://alistair.cockburn.us/articles-blog/new/rss "Site RSS")

Short URL for Page:\
http://a.cockburn.us/2047

Top Recommendations

-   [Constructive deconstruction of
    subtyping](/Constructive+deconstruction+of+subtyping)

-   [Using CRC cards](/Using+CRC+cards)

-   [Coffee machine design problem, part
    2](/Coffee+machine+design+problem%2c+part+2)

-   [Video of Alistairs hexagonal architecture CQRS lightning talk
    Mountain West Ruby Conference
    2010](/Video+of+Alistairs+hexagonal+architecture+CQRS+lightning+talk+Mountain+West+Ruby+Conference+2010)

-   [A sketch of project life from swamp to
    deliveries](/A+sketch+of+project+life+from+swamp+to+deliveries)

Tags

-   [Articles](/Articles)

-   [OO design](/OO+design)

Other

-   [What Links Here](/WhatLinksHere?for=2047)

-   Posted by: **Alistair** on **6/19/2008 1:07:04 PM**
-   Last modified by: **Alistair** on **5/20/2010 11:44:17 AM**
-   Visits: **12387**

© 1970-2014 Alistair Cockburn | [Full
Rss](feed://alistair.cockburn.us/rss) or [New Articles and Blogs
Rss](feed://alistair.cockburn.us/articles-blog/new/rss)another
[skybend](http://skybend.com) creation

Sign Up:

[close](#)

First Name:

Last Name:

Display Name:

Email:

Password:

Confirm:

Remember me

[Sign
Up](javascript:WebForm_DoPostBackWithOptions(new%20WebForm_PostBackOptions("ctl00$lbRegister",%20"",%20true,%20"SignUp",%20"",%20false,%20true)))

![image](/images/side-nav.png) ![image](/images/side-nav-green.png)
![image](/images/side-nav-yellow.png) ![image](/images/side-nav-red.png)

[![free hit
counter](http://c.statcounter.com/5257299/0/e4697bb2/1/)](http://www.statcounter.com/free_hit_counter.html "free hit counter")

This markdown document has been converted from the html document located at:
http://alistair.cockburn.us/Responsibility-based+modeling
