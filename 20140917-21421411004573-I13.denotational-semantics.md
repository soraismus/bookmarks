Haskell/Denotational semantics
==============================

From Wikibooks, open books for an open world

< [Haskell](/wiki/Haskell "Haskell")

Jump to: [navigation](#mw-navigation), [search](#p-search)

![Information](//upload.wikimedia.org/wikipedia/commons/thumb/3/35/Information_icon.svg/32px-Information_icon.svg.png)

**New readers: Please report stumbling blocks!** While the material on
this page is intended to explain clearly, there are always mental traps
that innocent readers new to the subject fall in but that the authors
are not aware of. Please report any tricky passages to the
[Talk](/wiki/Talk:Haskell/Denotational_semantics "Talk:Haskell/Denotational semantics")
page or the \#haskell IRC channel so that the style of exposition can be
improved.

**Denotational semantics**
([Solutions](/wiki/Haskell/Solutions/Denotational_semantics "Haskell/Solutions/Denotational semantics"))

Contents
--------

-   [1 Introduction](#Introduction)
    -   [1.1 What are Denotational Semantics and what are they
        for?](#What_are_Denotational_Semantics_and_what_are_they_for.3F)
    -   [1.2 What to choose as Semantic
        Domain?](#What_to_choose_as_Semantic_Domain.3F)

-   [2 Bottom and Partial Functions](#Bottom_and_Partial_Functions)
    -   [2.1 ⊥ Bottom](#.E2.8A.A5_Bottom)
    -   [2.2 Partial Functions and the Semantic Approximation
        Order](#Partial_Functions_and_the_Semantic_Approximation_Order)
    -   [2.3 Monotonicity](#Monotonicity)

-   [3 Recursive Definitions as Fixed Point
    Iterations](#Recursive_Definitions_as_Fixed_Point_Iterations)
    -   [3.1 Approximations of the Factorial
        Function](#Approximations_of_the_Factorial_Function)
    -   [3.2 Convergence](#Convergence)
    -   [3.3 Bottom includes
        Non-Termination](#Bottom_includes_Non-Termination)
    -   [3.4 Interpretation as Least Fixed
        Point](#Interpretation_as_Least_Fixed_Point)

-   [4 Strict and Non-Strict
    Semantics](#Strict_and_Non-Strict_Semantics)
    -   [4.1 Strict Functions](#Strict_Functions)
    -   [4.2 Non-Strict and Strict
        Languages](#Non-Strict_and_Strict_Languages)
    -   [4.3 Functions with several
        Arguments](#Functions_with_several_Arguments)

-   [5 Algebraic Data Types](#Algebraic_Data_Types)
    -   [5.1 Constructors](#Constructors)
    -   [5.2 Pattern Matching](#Pattern_Matching)
    -   [5.3 Recursive Data Types and Infinite
        Lists](#Recursive_Data_Types_and_Infinite_Lists)
    -   [5.4 Haskell specialities: Strictness Annotations and
        Newtypes](#Haskell_specialities:_Strictness_Annotations_and_Newtypes)

-   [6 Other Selected Topics](#Other_Selected_Topics)
    -   [6.1 Abstract Interpretation and Strictness
        Analysis](#Abstract_Interpretation_and_Strictness_Analysis)
    -   [6.2 Interpretation as Powersets](#Interpretation_as_Powersets)
    -   [6.3 Naïve Sets are unsuited for Recursive Data
        Types](#Na.C3.AFve_Sets_are_unsuited_for_Recursive_Data_Types)

-   [7 Notes](#Notes)
-   [8 External Links](#External_Links)

**Wider Theory**

**Denotational semantics** [![75%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/6/62/75_percent.svg/9px-75_percent.svg.png)](/wiki/Help:Development_stages "75% developed")\
 [Equational
reasoning](/w/index.php?title=Haskell/Equational_reasoning&action=edit&redlink=1 "Haskell/Equational reasoning (does not exist)")\
 [Program
derivation](/w/index.php?title=Haskell/Program_derivation&action=edit&redlink=1 "Haskell/Program derivation (does not exist)")\
 [Category
theory](/wiki/Haskell/Category_theory "Haskell/Category theory")\
 [The Curry-Howard
isomorphism](/wiki/Haskell/The_Curry-Howard_isomorphism "Haskell/The Curry-Howard isomorphism")\
 [fix and
recursion](/wiki/Haskell/Fix_and_recursion "Haskell/Fix and recursion")

[edit this
chapter](//en.wikibooks.org/w/index.php?title=Template:Haskell_chapter/Wider_Theory&action=edit)

Introduction[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=1 "Edit section: Introduction")]
--------------------------------------------------------------------------------------------------------------------------

This chapter explains how to formalize the meaning of Haskell programs,
the **denotational semantics**. It may seem to be nit-picking to
formally specify that the program `square x = x*x` means the same as the
mathematical square function that maps each number to its square, but
what about the meaning of a program like `f x = f (x+1)` that loops
forever? In the following, we will exemplify the approach first taken by
Scott and Strachey to this question and obtain a foundation to reason
about the correctness of functional programs in general and recursive
definitions in particular. Of course, we will concentrate on those
topics needed to understand Haskell programs.^[[1]](#cite_note-1)^

Another aim of this chapter is to illustrate the notions **strict** and
**lazy** that capture the idea that a function needs or needs not to
evaluate its argument. This is a basic ingredient to predict the course
of evaluation of Haskell programs and hence of primary interest to the
programmer. Interestingly, these notions can be formulated concisely
with denotational semantics alone, no reference to an execution model is
necessary. They will be put to good use in [Graph
Reduction](/wiki/Haskell/Graph_reduction "Haskell/Graph reduction"), but
it is this chapter that will familiarize the reader with the
denotational definition and involved notions such as ⊥ ("Bottom"). The
reader only interested in strictness may wish to poke around in section
[Bottom and Partial Functions](#Bottom_and_Partial_Functions) and
quickly head over to [Strict and Non-Strict
Semantics](#Strict_and_Non-Strict_Semantics).

### What are Denotational Semantics and what are they for?[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=2 "Edit section: What are Denotational Semantics and what are they for?")]

What does a Haskell program mean? This question is answered by the
**denotational semantics** of Haskell. In general, the denotational
semantics of a programming language map each of its programs to a
mathematical object (denotation), that represents the *meaning* of the
program in question. As an example, the mathematical object for the
Haskell programs `10`, `9+1`, `2*5` and `sum [1..4]` can be represented
by the integer *10*. We say that all those programs **denote** the
integer *10*. The collection of such mathematical objects is called the
**semantic domain**.

The mapping from program code to a semantic domain is commonly written
down with double square brackets ("Oxford brackets") around program
code. For example,

![[\\![\\texttt{2\*5}]\\!] =
10.](//upload.wikimedia.org/math/9/3/9/9398062a055bff2442cc4a24d9ca64de.png)

Denotations are *compositional*, i.e. the meaning of a program like
`1+9` only depends on the meaning of its constituents:

![[\\![\\texttt{a+b}]\\!] =
[\\![\\texttt{a}]\\!]+[\\![\\texttt{b}]\\!].](//upload.wikimedia.org/math/4/c/a/4cab0d263804feba8a19f7605c9d1f2f.png)

The same notation is used for types, i.e.

![[\\![\\texttt{Integer}]\\!]=\\mathbb{Z}.](//upload.wikimedia.org/math/6/8/e/68e3a6435ad7c284f1cbbff1095c0e9d.png)

For simplicity however, we will silently identify expressions with their
semantic objects in subsequent chapters and use this notation only when
clarification is needed.

It is one of the key properties of *purely functional* languages like
Haskell that a direct mathematical interpretation like "`1+9` denotes
*10*" carries over to functions, too: in essence, the denotation of a
program of type `Integer -> Integer` is a mathematical function
![\\mathbb{Z}\\to\\mathbb{Z}](//upload.wikimedia.org/math/7/7/c/77c6dc050dc18efea3170daf87521d3e.png)
between integers. While we will see that this expression needs
refinement generally, to include non-termination, the situation for
*imperative languages* is clearly worse: a procedure with that type
denotes something that changes the state of a machine in possibly
unintended ways. Imperative languages are tightly tied to **operational
semantics** which describes their way of execution on a machine. It is
possible to define a denotational semantics for imperative programs and
to use it to reason about such programs, but the semantics often has
operational nature and sometimes must be extended in comparison to the
denotational semantics for functional languages.^[[2]](#cite_note-2)^ In
contrast, the meaning of purely functional languages is *by default*
completely independent from their way of execution. The Haskell98
standard even goes as far as to specify only Haskell's non-strict
denotational semantics, leaving open how to implement them.

In the end, denotational semantics enables us to develop formal proofs
that programs indeed do what we want them to do mathematically.
Ironically, for proving program properties in day-to-day Haskell, one
can use [Equational
reasoning](/w/index.php?title=Haskell/Equational_reasoning&action=edit&redlink=1 "Haskell/Equational reasoning (does not exist)"),
which transforms programs into equivalent ones without seeing much of
the underlying mathematical objects we are concentrating on in this
chapter. But the denotational semantics actually show up whenever we
have to reason about non-terminating programs, for instance in [Infinite
Lists](#Recursive_Data_Types_and_Infinite_Lists).

Of course, because they only state what a program is, denotational
semantics cannot answer questions about how long a program takes or how
much memory it eats; this is governed by the *evaluation strategy* which
dictates how the computer calculates the normal form of an expression.
On the other hand, the implementation has to respect the semantics, and
to a certain extent, it is the semantics that determine how Haskell
programs must be evaluated on a machine. We will elaborate on this in
[Strict and Non-Strict Semantics](#Strict_and_Non-Strict_Semantics).

### What to choose as Semantic Domain?[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=3 "Edit section: What to choose as Semantic Domain?")]

We are now looking for suitable mathematical objects that we can
attribute to every Haskell program. In case of the example `10`, `2*5`
and `sum [1..4]`, it is clear that all expressions should denote the
integer *10*. Generalizing, every value `x` of type `Integer` is likely
to be an element of the set
![\\mathbb{Z}](//upload.wikimedia.org/math/0/b/1/0b100eeff3848a15dbb46291e7fe52ad.png).
The same can be done with values of type `Bool`. For functions like
`f :: Integer -> Integer`, we can appeal to the mathematical definition
of "function" as a set of (argument,value)-pairs, its *graph*.

But interpreting functions as their graph was too quick, because it does
not work well with recursive definitions. Consider the definition

    shaves :: Integer -> Integer -> Bool
    1 `shaves` 1 = True
    2 `shaves` 2 = False
    0 `shaves` x = not (x `shaves` x)
    _ `shaves` _ = False

We can think of `0`,`1` and `2` as being male persons with long beards
and the question is who shaves whom. Person `1` shaves himself, but `2`
gets shaved by the barber `0` because evaluating the third equation
yields `` 0 `shaves` 2 == True ``. In general, the third line says that
the barber `0` shaves all persons that do not shave themselves.

What about the barber himself, is `` 0 `shaves` 0 `` true or not? If it
is, then the third equation says that it is not. If it is not, then the
third equation says that it is. Puzzled, we see that we just cannot
attribute `True` or `False` to `` 0 `shaves` 0 ``, the graph we use as
interpretation for the function `shaves` must have an empty spot. We
realize that our semantic objects must be able to incorporate **partial
functions**, functions that are undefined for some arguments.

It is well known that this famous example gave rise to serious
foundational problems in set theory. It's an example of an
**impredicative** definition, a definition which uses itself, a logical
circle. Unfortunately for recursive definitions, the circle is not the
problem but the feature.

Bottom and Partial Functions[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=4 "Edit section: Bottom and Partial Functions")]
----------------------------------------------------------------------------------------------------------------------------------------------------------

### ⊥ Bottom[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=5 "Edit section: ⊥ Bottom")]

To define partial functions, we introduce a special value ⊥, named
**[bottom](//en.wikipedia.org/wiki/Bottom_type "w:Bottom type")** and
commonly written `_|_` in typewriter font. We say that ⊥ is the
completely **"undefined" value** or function. Every basic data type like
`Integer` or `()` contains one ⊥ besides their usual elements. So the
possible values of type `Integer` are

![\\bot, 0, \\pm 1, \\pm 2, \\pm 3,
\\dots](//upload.wikimedia.org/math/9/0/f/90f6995914f2b41ece5bf68535773cf5.png)

*(Note that the symbol to the left to the numbers above is actually the
"positive or negative" indicator
![\\pm](//upload.wikimedia.org/math/5/7/2/5722e2f6169308b8be3542900c6d6553.png),
which has an irrelevant similarity to bottom in most mathematical
formatting. So the list above is actually just:
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png),
0, +1, -1, +2, -2, +3, -3, ...)*

Adding ⊥ to the set of values is also called **lifting**. This is often
depicted by a subscript like in
![\\mathbb{Z}\_\\bot](//upload.wikimedia.org/math/e/9/f/e9f42887d201f52dc40f34e85e91bf86.png).
While this is the correct notation for the mathematical set "lifted
integers", we prefer to talk about "values of type `Integer`". We do
this because
![\\mathbb{Z}\_\\bot](//upload.wikimedia.org/math/e/9/f/e9f42887d201f52dc40f34e85e91bf86.png)
suggests that there are "real" integers
![\\mathbb{Z}](//upload.wikimedia.org/math/0/b/1/0b100eeff3848a15dbb46291e7fe52ad.png),
but inside Haskell, the "integers" are `Integer`.

As another example, the type `()` with only one element actually has two
inhabitants:

![\\bot,
()](//upload.wikimedia.org/math/d/a/f/daf1e91bc9861cb2a48a2a270c4f5ace.png)

For now, we will stick to programming with `Integer`s. Arbitrary
algebraic data types will be treated in section [Algebraic Data
Types](#Algebraic_Data_Types) as strict and non-strict languages diverge
on how these include ⊥.

In Haskell, the expression `undefined` denotes ⊥. With its help, one can
indeed verify some semantic properties of actual Haskell programs.
`undefined` has the polymorphic type `forall a . a` which of course can
be specialized to `undefined :: Integer`, `undefined :: ()`,
`undefined :: Integer -> Integer` and so on. In the Haskell Prelude, it
is defined as

`undefined = error "Prelude.undefined"`

As a side note, it follows from [the Curry-Howard
isomorphism](/wiki/Haskell/The_Curry-Howard_isomorphism "Haskell/The Curry-Howard isomorphism")
that any value of the polymorphic type `forall a . a` must denote ⊥.

### Partial Functions and the Semantic Approximation Order[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=6 "Edit section: Partial Functions and the Semantic Approximation Order")]

Now,
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
(*bottom type*) gives us the possibility to denote partial functions:

![f(n) = \\begin{cases} 1 & \\mbox{ if } n \\mbox{ is } 0 \\\\ -2 &
\\mbox{ if } n \\mbox{ is } 1 \\\\ \\bot & \\mbox{ else } \\end{cases}
](//upload.wikimedia.org/math/d/7/a/d7acc1e5beb78a8fb766320cbe6e70af.png)

Here,
![f(n)](//upload.wikimedia.org/math/a/8/9/a8988ce0f88f5292aa28b6e49f114d45.png)
yields well defined values for
![n=0](//upload.wikimedia.org/math/0/e/1/0e1176caf07d2ed21c19fc899be7e7df.png)
and
![n=1](//upload.wikimedia.org/math/6/d/2/6d24e2bc97c5e4283dd8e34674afe7ea.png)
but gives
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
for all other
![n](//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png).
Note that the type
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
is universal, as
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
has no value: the function
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)`:: Integer -> Integer`
is given by

![\\bot(n) =
\\bot](//upload.wikimedia.org/math/8/c/b/8cb96d626bc2931c3d2afa710a7085a7.png)
for all
![n](//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png)

where the
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
on the right hand side denotes a value of type `Integer`.

To formalize, **partial functions** say, of type `Integer -> Integer`
are at least mathematical mappings from the lifted integers
![\\mathbb{Z}\_\\bot=\\{\\bot, 0, \\pm 1, \\pm 2, \\pm 3,
\\dots\\}](//upload.wikimedia.org/math/6/5/7/65704a13ad69acfc7dccb6a2dcd571ae.png)
to the lifted integers. But this is not enough, since it does not
acknowledge the special role of
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png).
For example, the definition

![g(n) = \\begin{cases} 1 & \\mbox{ if } n \\mbox{ is } \\bot \\\\ \\bot
& \\mbox{ else } \\end{cases}
](//upload.wikimedia.org/math/6/6/0/660477d6c6149a414d83b49e5b934ed9.png)

looks counterintuitive, and, in fact, is wrong. Why does
![g(\\bot)](//upload.wikimedia.org/math/2/8/1/281686657c123b9d8588abf9dced55b3.png)
yield a defined value whereas
![g(1)](//upload.wikimedia.org/math/4/4/1/441e41b9fca9003a19e7d6a9bf469239.png)
is undefined? The intuition is that every partial function
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png)
should yield more defined answers for more defined arguments. To
formalize, we can say that every concrete number is **more defined**
than
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png):

![\\bot\\sqsubset 1\\ ,\\ \\bot\\sqsubset 2\\ ,
\\dots](//upload.wikimedia.org/math/e/7/2/e72a1007773ee9e2aacb7dd6c0fd0c55.png)

Here, ![a\\sqsubset
b](//upload.wikimedia.org/math/a/9/5/a95552027dfdf4056451e489cff2c202.png)
denotes that
![b](//upload.wikimedia.org/math/9/2/e/92eb5ffee6ae2fec3ad71c777531578f.png)
is more defined than
![a](//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png).
Likewise, ![a\\sqsubseteq
b](//upload.wikimedia.org/math/8/2/4/824bdcbb83f5ce26dfbce9ef50bcd3df.png)
will denote that either
![b](//upload.wikimedia.org/math/9/2/e/92eb5ffee6ae2fec3ad71c777531578f.png)
is more defined than
![a](//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png)
or both are equal (and so have the same definedness).
![\\sqsubset](//upload.wikimedia.org/math/f/2/2/f22614b2c39be672bfda11afddd15c18.png)
is also called the **semantic approximation order** because we can
approximate defined values by less defined ones thus interpreting "more
defined" as "approximating better". Of course,
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
is designed to be the least element of a data type, we always have that
![\\bot\\sqsubset
x](//upload.wikimedia.org/math/b/7/f/b7f3a891e0f732fea640547cf24d54f3.png)
for all
![x](//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png),
except the case when
![x](//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png)
happens to denote
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
itself:

![\\forall x\\neq\\bot\\ \\ \\ \\bot\\sqsubset x
](//upload.wikimedia.org/math/d/0/9/d0954524d2a5d01043d0cd86be9fdc95.png)

As no number is *more defined* than another, the mathematical relation
![\\sqsubset](//upload.wikimedia.org/math/f/2/2/f22614b2c39be672bfda11afddd15c18.png)
is false for any pair of numbers:

![ 1 \\sqsubset 1
](//upload.wikimedia.org/math/f/4/1/f41eee36ed98dd5ad1f80165614930c0.png)
does not hold.

neither ![1 \\sqsubset
2](//upload.wikimedia.org/math/6/6/3/663f8bfd55d8399184bf20e3ba3c7900.png)
nor ![2 \\sqsubset
1](//upload.wikimedia.org/math/c/2/1/c2160019d098df7aee140c4bd2309b44.png)
hold.

This is contrasted to ordinary order predicate
![\\le](//upload.wikimedia.org/math/4/9/d/49dc1443f33cf63082d6e193dd2af78f.png),
which can compare any two numbers. A quick way to remember this is the
sentence:
"![1](//upload.wikimedia.org/math/c/4/c/c4ca4238a0b923820dcc509a6f75849b.png)
and
![2](//upload.wikimedia.org/math/c/8/1/c81e728d9d4c2f636f067f89cc14862c.png)
are different in terms of *information content* but are equal in terms
of *information quantity*". That's another reason why we use a different
symbol:
![\\sqsubseteq](//upload.wikimedia.org/math/b/1/b/b1be6c28d38e18390ea808e56c4e1d93.png).

neither ![1 \\sqsubseteq
2](//upload.wikimedia.org/math/9/f/5/9f555b313e438e5e34cb7b8c6dac83d5.png)
nor ![2 \\sqsubseteq
1](//upload.wikimedia.org/math/e/1/b/e1b1b71058eb26ab199b6ef1298aa349.png)
hold,

but ![1 \\sqsubseteq
1](//upload.wikimedia.org/math/6/5/2/652534682a8c043f47833c11632b1ab1.png)
holds.

One says that
![\\sqsubseteq](//upload.wikimedia.org/math/b/1/b/b1be6c28d38e18390ea808e56c4e1d93.png)
specifies a **partial order** and that the values of type `Integer` form
a **partially ordered set** (**poset** for short). A partial order is
characterized by the following three laws

-   *Reflexivity*, everything is just as defined as itself: ![x
    \\sqsubseteq
    x](//upload.wikimedia.org/math/b/c/1/bc13e3576337ac0cd07ce6eb4b9cf976.png)
    for all
    ![x](//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png)
-   *Transitivity*: if ![x \\sqsubseteq
    y](//upload.wikimedia.org/math/f/5/1/f51511e680d28dcaa1ffc34084944903.png)
    and ![y \\sqsubseteq
    z](//upload.wikimedia.org/math/6/f/f/6ff5913b7fd874f633de3c16f9ca969e.png),
    then ![x \\sqsubseteq
    z](//upload.wikimedia.org/math/f/0/8/f087b1897934d60e940232cddf952129.png)
-   *Antisymmetry*: if both ![x \\sqsubseteq
    y](//upload.wikimedia.org/math/f/5/1/f51511e680d28dcaa1ffc34084944903.png)
    and ![y \\sqsubseteq
    x](//upload.wikimedia.org/math/8/0/5/805b4fe66a8f4502baf27a5916a6ab24.png)
    hold, then
    ![x](//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png)
    and
    ![y](//upload.wikimedia.org/math/4/1/5/415290769594460e2e485922904f345d.png)
    must be equal:
    ![x=y](//upload.wikimedia.org/math/9/1/9/919860b52317a584e5de6f3257631d16.png).

  Exercises
  -----------------------------------------------------------------------------------------------------------------------------------------
  Do the integers form a poset with respect to the order ![\\le](//upload.wikimedia.org/math/4/9/d/49dc1443f33cf63082d6e193dd2af78f.png)?

We can depict the order
![\\sqsubseteq](//upload.wikimedia.org/math/b/1/b/b1be6c28d38e18390ea808e56c4e1d93.png)
on the values of type `Integer` by the following graph

[![Int-graph.png](//upload.wikimedia.org/wikibooks/en/d/d0/Int-graph.png)](/wiki/File:Int-graph.png)

where every link between two nodes specifies that the one above is more
defined than the one below. Because there is only one level (excluding
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)),
one says that `Integer` is a *flat domain*. The picture also explains
the name of
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png):
it's called *bottom* because it always sits at the bottom.

### Monotonicity[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=7 "Edit section: Monotonicity")]

Our intuition about partial functions now can be formulated as
following: every partial function
![f](//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png)
is a **monotone** mapping between partially ordered sets. More defined
arguments will yield more defined values:

![ x\\sqsubseteq y \\Longrightarrow f(x)\\sqsubseteq f(y)
](//upload.wikimedia.org/math/a/6/d/a6d4b5af837b404a32118e4a4079e0ef.png)

In particular, a function
![h](//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png)
with
![h(\\bot)=1](//upload.wikimedia.org/math/1/2/5/1254e2ca284d61df35b7a143817ee597.png)
is constant:
![h(n)=1](//upload.wikimedia.org/math/3/f/7/3f7c1c4bb843e4f31d6dd03ad895f2b0.png)
for all
![n](//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png).
Note that here it is crucial that ![1 \\sqsubseteq
2](//upload.wikimedia.org/math/9/f/5/9f555b313e438e5e34cb7b8c6dac83d5.png)
etc. don't hold.

Translated to Haskell, monotonicity means that we cannot use
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
as a condition, i.e. we cannot pattern match on
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png),
or its equivalent `undefined`. Otherwise, the example
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png)
from above could be expressed as a Haskell program. As we shall see
later,
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
also denotes non-terminating programs, so that the inability to observe
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
inside Haskell is related to the halting problem.

Of course, the notion of *more defined than* can be extended to partial
functions by saying that a function is more defined than another if it
is so at every possible argument:

![f \\sqsubseteq g \\mbox{ if } \\forall x. f(x) \\sqsubseteq
g(x)](//upload.wikimedia.org/math/2/2/1/2216f08c247b46a91f407decbdfb135d.png)

Thus, the partial functions also form a poset, with the undefined
function
![\\bot(x)=\\bot](//upload.wikimedia.org/math/0/0/5/00592dbe274ff353b7dc02c8c74a29fa.png)
being the least element.

Recursive Definitions as Fixed Point Iterations[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=8 "Edit section: Recursive Definitions as Fixed Point Iterations")]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Approximations of the Factorial Function[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=9 "Edit section: Approximations of the Factorial Function")]

Now that we have a means to describe partial functions, we can give an
interpretation to recursive definitions. Lets take the prominent example
of the factorial function
![f(n)=n!](//upload.wikimedia.org/math/8/b/3/8b3926fe6200a0b2ec249b994541129f.png)
whose recursive definition is

![f(n) = \\mbox{ if } n == 0 \\mbox{ then } 1 \\mbox{ else } n \\cdot
f(n-1)](//upload.wikimedia.org/math/1/c/a/1ca3027447ba856089f1d15f73fbc477.png)

Although we saw that interpreting this recursive function directly as a
set description may lead to problems, we intuitively know that in order
to calculate
![f(n)](//upload.wikimedia.org/math/a/8/9/a8988ce0f88f5292aa28b6e49f114d45.png)
for every given
![n](//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png)
we have to iterate the right hand side. This iteration can be formalized
as follows: we calculate a sequence of functions
![f\_k](//upload.wikimedia.org/math/8/d/3/8d38e7b14d32d7148917b87fab46f49d.png)
with the property that each one consists of the right hand side applied
to the previous one, that is

![f\_{k+1}(n) = \\mbox{ if } n == 0 \\mbox{ then } 1 \\mbox{ else } n
\\cdot
f\_k(n-1)](//upload.wikimedia.org/math/7/b/2/7b283030d76d4a8cb5032b3aa98e022d.png)

We start with the undefined function ![f\_0(n) =
\\bot](//upload.wikimedia.org/math/6/2/c/62ca53ca5e0abb4bd0285a0ec612f2c6.png),
and the resulting sequence of partial functions reads:

![f\_1(n) = \\begin{cases} 1 & \\mbox{ if } n \\mbox{ is } 0 \\\\ \\bot
& \\mbox{ else } \\end{cases} \\ ,\\ f\_2(n) = \\begin{cases} 1 &
\\mbox{ if } n \\mbox{ is } 0 \\\\ 1 & \\mbox{ if } n \\mbox{ is } 1
\\\\ \\bot & \\mbox{ else } \\end{cases} \\ ,\\ f\_3(n) = \\begin{cases}
1 & \\mbox{ if } n \\mbox{ is } 0 \\\\ 1 & \\mbox{ if } n \\mbox{ is } 1
\\\\ 2 & \\mbox{ if } n \\mbox{ is } 2 \\\\ \\bot & \\mbox{ else }
\\end{cases}
](//upload.wikimedia.org/math/b/c/8/bc881506beca35c4eb4ca122f3b9eb05.png)

and so on. Clearly,

![\\bot=f\_0 \\sqsubseteq f\_1 \\sqsubseteq f\_2 \\sqsubseteq \\dots
](//upload.wikimedia.org/math/9/5/d/95df44b1be7e25a03f81c94571cffe6e.png)

and we expect that the sequence converges to the factorial function.

The iteration follows the well known scheme of a fixed point iteration

![ x\_0, g(x\_0), g(g(x\_0)), g(g(g(x\_0))), \\dots
](//upload.wikimedia.org/math/f/2/e/f2e292cfa4feb1c86c1cbf821ba8b850.png)

In our case,
![x\_0](//upload.wikimedia.org/math/0/b/2/0b21a666a81629962ade8afd967826ed.png)
is a function and
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png)
is a *functional*, a mapping between functions. We have

![ x\_0 =
\\bot](//upload.wikimedia.org/math/f/8/5/f855a0cfc691e17ed0aef43de40d0e51.png)
and

![ g(x) = n\\mapsto\\mbox{ if } n == 0 \\mbox{ then } 1 \\mbox{ else }
n\*x(n-1)
\\,](//upload.wikimedia.org/math/e/1/6/e16440900b08bd89874d106ab9282e1d.png)

If we start with ![x\_0 =
\\bot](//upload.wikimedia.org/math/f/8/5/f855a0cfc691e17ed0aef43de40d0e51.png),
the iteration will yield increasingly defined approximations to the
factorial function

![ \\bot\\sqsubseteq g(\\bot)\\sqsubseteq g(g(\\bot))\\sqsubseteq
g(g(g(\\bot)))\\sqsubseteq \\dots
](//upload.wikimedia.org/math/9/0/5/905b6097bed58dbf549b1b227e8241d7.png)

(Proof that the sequence increases: The first inequality
![\\bot\\sqsubseteq
g(\\bot)](//upload.wikimedia.org/math/2/f/1/2f1cd1f9fd65625749387acceb7651ca.png)
follows from the fact that
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
is less defined than anything else. The second inequality follows from
the first one by applying
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png)
to both sides and noting that
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png)
is monotone. The third follows from the second in the same fashion and
so on.)

\
 It is very illustrative to formulate this iteration scheme in Haskell.
As functionals are just ordinary higher order functions, we have

    g :: (Integer -> Integer) -> (Integer -> Integer)
    g x = \n -> if n == 0 then 1 else n * x (n-1)

    x0 :: Integer -> Integer
    x0 = undefined

    (f0:f1:f2:f3:f4:fs) = iterate g x0

We can now evaluate the functions `f0,f1,...` at sample arguments and
see whether they yield `undefined` or not:

     > f3 0
     1
     > f3 1
     1
     > f3 2
     2
     > f3 5
     *** Exception: Prelude.undefined
     > map f3 [0..]
     [1,1,2,*** Exception: Prelude.undefined
     > map f4 [0..]
     [1,1,2,6,*** Exception: Prelude.undefined
     > map f1 [0..]
     [1,*** Exception: Prelude.undefined

Of course, we cannot use this to check whether f4 is really undefined
for all arguments.

### Convergence[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=10 "Edit section: Convergence")]

To the mathematician, the question whether this sequence of
approximations converges is still to be answered. For that, we say that
a poset is a **directed complete partial order** (**dcpo**) iff every
monotone sequence ![x\_0\\sqsubseteq x\_1\\sqsubseteq
\\dots](//upload.wikimedia.org/math/6/a/0/6a0d9f5eac98c3949bd266d6b41e6cce.png)
(also called *chain*) has a least upper bound (supremum)

![\\sup\_{\\sqsubseteq} \\{x\_0\\sqsubseteq x\_1\\sqsubseteq \\dots\\} =
x](//upload.wikimedia.org/math/b/b/b/bbbfd524fa39955029c8913e2e97396d.png).

If that's the case for the semantic approximation order, we clearly can
be sure that monotone sequence of functions approximating the factorial
function indeed has a limit. For our denotational semantics, we will
only meet dcpos which have a least element
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
which are called **complete partial order**s (**cpo**).

The `Integer`s clearly form a (d)cpo, because the monotone sequences
consisting of more than one element must be of the form

![\\bot\\sqsubseteq\\dots\\sqsubseteq\\ \\bot\\sqsubseteq n\\sqsubseteq
n\\sqsubseteq \\dots\\sqsubseteq
n](//upload.wikimedia.org/math/d/7/f/d7f727c236dff339fa6a38767b4eec79.png)

where
![n](//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png)
is an ordinary number. Thus,
![n](//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png)
is already the least upper bound.

For functions `Integer -> Integer`, this argument fails because monotone
sequences may be of infinite length. But because `Integer` is a (d)cpo,
we know that for every point
![n](//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png),
there is a least upper bound

![\\sup\_{\\sqsubseteq} \\{\\bot=f\_0(n) \\sqsubseteq f\_1(n)
\\sqsubseteq f\_2(n) \\sqsubseteq \\dots\\} =:
f(n)](//upload.wikimedia.org/math/e/d/4/ed46236b1eaaec8d00c736dd91b03ec9.png).

As the semantic approximation order is defined point-wise, the function
![f](//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png)
is the supremum we looked for.

These have been the last touches for our aim to transform the
impredicative definition of the factorial function into a well defined
construction. Of course, it remains to be shown that
![f(n)](//upload.wikimedia.org/math/a/8/9/a8988ce0f88f5292aa28b6e49f114d45.png)
actually yields a defined value for every
![n](//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png),
but this is not hard and far more reasonable than a completely
ill-formed definition.

### Bottom includes Non-Termination[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=11 "Edit section: Bottom includes Non-Termination")]

It is instructive to try our newly gained insight into recursive
definitions on an example that does not terminate:

![f(n) =
f(n+1)](//upload.wikimedia.org/math/a/8/5/a8562173c11ef6507635f44451cc6523.png)

The approximating sequence reads

![f\_0 = \\bot, f\_1 = \\bot,
\\dots](//upload.wikimedia.org/math/b/c/d/bcd891e0183748f0cf19fa3f5452f713.png)

and consists only of
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png).
Clearly, the resulting limit is
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
again. From an operational point of view, a machine executing this
program will loop indefinitely. We thus see that
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
may also denote a **non-terminating** function or value. Hence, given
the halting problem, pattern matching on
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
in Haskell is impossible.

### Interpretation as Least Fixed Point[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=12 "Edit section: Interpretation as Least Fixed Point")]

Earlier, we called the approximating sequence an example of the well
known "fixed point iteration" scheme. And of course, the definition of
the factorial function
![f](//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png)
can also be thought as the specification of a fixed point of the
functional
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png):

![f = g(f) = n\\mapsto\\mbox{ if } n == 0 \\mbox{ then } 1 \\mbox{ else
} n\\cdot
f(n-1)](//upload.wikimedia.org/math/9/d/7/9d767770a5813fd4292965450c4b3092.png)

However, there might be multiple fixed points. For instance, there are
several
![f](//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png)
which fulfill the specification

![f = n\\mapsto\\mbox{ if } n == 0 \\mbox{ then } 1 \\mbox{ else }
f(n+1)](//upload.wikimedia.org/math/4/c/5/4c53ab02fefc8c8e7be8f90670a5a715.png),

Of course, when executing such a program, the machine will loop forever
on
![f(1)](//upload.wikimedia.org/math/4/4/f/44f2886de47a6ed1bd8d3b95c3125295.png)
or
![f(2)](//upload.wikimedia.org/math/8/0/4/804c00b3d22f9440a6e493617abf01fe.png)
and thus not produce any valuable information about the value of
![f(1)](//upload.wikimedia.org/math/4/4/f/44f2886de47a6ed1bd8d3b95c3125295.png).
This corresponds to choosing the *least defined* fixed point as semantic
object
![f](//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png)
and this is indeed a canonical choice. Thus, we say that

![f=g(f)](//upload.wikimedia.org/math/2/a/e/2ae2dc31761918df880869605b678f26.png),

defines the **least fixed point**
![f](//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png)
of
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png).
Clearly, *least* is with respect to our semantic approximation order
![\\sqsubseteq](//upload.wikimedia.org/math/b/1/b/b1be6c28d38e18390ea808e56c4e1d93.png).

The existence of a least fixed point is guaranteed by our iterative
construction if we add the condition that
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png)
must be **continuous** (sometimes also called "chain continuous"). That
simply means that
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png)
respects suprema of monotone sequences:

![\\sup\_{\\sqsubseteq}\\{g(x\_0)\\sqsubseteq g(x\_1)
\\sqsubseteq\\dots\\} = g\\left(\\sup\_{\\sqsubseteq}\\{x\_0\\sqsubseteq
x\_1\\sqsubseteq\\dots\\}\\right)](//upload.wikimedia.org/math/2/f/5/2f580803e117b7b617cd5dd00af98b9e.png)

We can then argue that with

![f=\\sup\_{\\sqsubseteq}\\{x\_0\\sqsubseteq g(x\_0)\\sqsubseteq
g(g(x\_0))\\sqsubseteq\\dots\\}](//upload.wikimedia.org/math/d/4/f/d4f150f23c5d395d21fa4367b5b83b6e.png)

we have

![\\begin{array}{lcl} g(f) &=&
g\\left(\\sup\_{\\sqsubseteq}\\{x\_0\\sqsubseteq g(x\_0)\\sqsubseteq
g(g(x\_0))\\sqsubseteq\\dots\\}\\right)\\\\ &=&
\\sup\_{\\sqsubseteq}\\{g(x\_0)\\sqsubseteq
g(g(x\_0))\\sqsubseteq\\dots\\}\\\\ &=& \\sup\_{\\sqsubseteq}\\{x\_0
\\sqsubseteq g(x\_0)\\sqsubseteq g(g(x\_0))\\sqsubseteq\\dots\\}\\\\ &=&
f
\\end{array}](//upload.wikimedia.org/math/8/2/3/8236f0763999eeea3f3de53d2dd185db.png)

and the iteration limit is indeed a fixed point of
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png).
You may also want to convince yourself that the fixed point iteration
yields the *least* fixed point possible.

  Exercises
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Prove that the fixed point obtained by fixed point iteration starting with ![x\_0=\\bot](//upload.wikimedia.org/math/f/8/5/f855a0cfc691e17ed0aef43de40d0e51.png) is also the least one, that it is smaller than any other fixed point. (Hint: ![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png) is the least element of our cpo and ![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png) is monotone)

\
 By the way, how do we know that each Haskell function we write down
indeed is continuous? Just as with monotonicity, this has to be enforced
by the programming language. Admittedly, these properties can somewhat
be enforced or broken at will, so the question feels a bit void. But
intuitively, monotonicity is guaranteed by not allowing pattern matches
on
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png).
For continuity, we note that for an arbitrary type `a`, every simple
function `a -> Integer` is automatically continuous because the monotone
sequences of `Integer`s are of finite length. Any infinite chain of
values of type `a` gets mapped to a finite chain of `Integer`s and
respect for suprema becomes a consequence of monotonicity. Thus, all
functions of the special case `Integer -> Integer` must be continuous.
For functionals like
![g](//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png)`::(Integer -> Integer) -> (Integer -> Integer)`,
the continuity then materializes due to currying, as the type is
isomorphic to `::((Integer -> Integer), Integer) -> Integer` and we can
take `a=((Integer -> Integer), Integer)`.

In Haskell, the fixed interpretation of the factorial function can be
coded as

`factorial = fix g`

with the help of the fixed point combinator

`fix :: (a -> a) -> a`.

We can define it by

`fix f = let x = f x in x`

which leaves us somewhat puzzled because when expanding
![factorial](//upload.wikimedia.org/math/c/b/8/cb89593d1f9fe3ecdb2178215eee80ae.png),
the result is not anything different from how we would have defined the
factorial function in Haskell in the first place. But of course, the
construction this whole section was about is not at all present when
running a real Haskell program. It's just a means to put the
mathematical interpretation of Haskell programs on a firm ground. Yet it
is very nice that we can explore these semantics in Haskell itself with
the help of `undefined`.

Strict and Non-Strict Semantics[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=13 "Edit section: Strict and Non-Strict Semantics")]
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

After having elaborated on the denotational semantics of Haskell
programs, we will drop the mathematical function notation
![f(n)](//upload.wikimedia.org/math/a/8/9/a8988ce0f88f5292aa28b6e49f114d45.png)
for semantic objects in favor of their now equivalent Haskell notation
`f n`.

### Strict Functions[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=14 "Edit section: Strict Functions")]

A function `f` with one argument is called **strict**, if and only if

`f ⊥ = ⊥`.

Here are some examples of strict functions

    id     x = x
    succ   x = x + 1
    power2 0 = 1
    power2 n = 2 * power2 (n-1)

and there is nothing unexpected about them. But why are they strict? It
is instructive to prove that these functions are indeed strict. For
`id`, this follows from the definition. For `succ`, we have to ponder
whether `⊥ + 1` is `⊥` or not. If it was not, then we should for example
have `⊥ + 1 = 2` or more general `⊥ + 1 = k` for some concrete number
*k*. We remember that every function is *monotone*, so we should have
for example

`2 = ⊥ + 1 ⊑ 4 + 1 = 5`

as `⊥ ⊑ 4`. But neither of `2 ⊑ 5`, `2 = 5` nor `2 ⊒ 5` is valid so that
*k* cannot be 2. In general, we obtain the contradiction

`k = ⊥ + 1 ⊑ k + 1 = k + 1`.

and thus the only possible choice is

`succ ⊥ = ⊥ + 1 = ⊥`

and `succ` is strict.

  Exercises
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Prove that `power2` is strict. While one can base the proof on the "obvious" fact that `power2 n` is ![2\^n](//upload.wikimedia.org/math/9/a/a/9aa0ec0374c89d2f7f3d9cd2e05a4bc5.png), the latter is preferably proven using fixed point iteration.

### Non-Strict and Strict Languages[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=15 "Edit section: Non-Strict and Strict Languages")]

Searching for **non-strict** functions, it happens that there is only
one prototype of a non-strict function of type `Integer -> Integer`:

    one x = 1

Its variants are `constk x = k` for every concrete number `k`. Why are
these the only ones possible? Remember that `one n` can be no less
defined than `one ⊥`. As `Integer` is a flat domain, both must be equal.

Why is `one` non-strict? To see that it is, we use a Haskell interpreter
and try

    > one (undefined :: Integer)
    1

which is not ⊥. This is reasonable as `one` completely ignores its
argument. When interpreting ⊥ in an operational sense as
"non-termination", one may say that the non-strictness of `one` means
that it does not force its argument to be evaluated and therefore avoids
the infinite loop when evaluating the argument ⊥. But one might as well
say that every function must evaluate its arguments before computing the
result which means that `one ⊥` should be ⊥, too. That is, if the
program computing the argument does not halt, `one` should not halt as
well.^[[3]](#cite_note-3)^ It shows up that one can *choose freely* this
or the other design for a functional programming language. One says that
the language is *strict* or *non-strict* depending on whether functions
are strict or non-strict by default. The choice for Haskell is
non-strict. In contrast, the functional languages ML and Lisp choose
strict semantics.

### Functions with several Arguments[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=16 "Edit section: Functions with several Arguments")]

The notion of strictness extends to functions with several variables.
For example, a function `f` of two arguments is *strict in the second
argument* if and only if

`f x ⊥ = ⊥`

for every `x`. But for multiple arguments, mixed forms where the
strictness depends on the given value of the other arguments, are much
more common. An example is the conditional

    cond b x y = if b then x else y

We see that it is strict in `y` depending on whether the test `b` is
`True` or `False`:

    cond True  x ⊥ = x
    cond False x ⊥ = ⊥

and likewise for `x`. Apparently, `cond` is certainly ⊥ if both `x` and
`y` are, but not necessarily when at least one of them is defined. This
behavior is called **joint strictness**.

Clearly, `cond` behaves like the if-then-else statement where it is
crucial not to evaluate both the `then` and the `else` branches:

    if null xs then 'a' else head xs
    if n == 0  then  1  else 5 / n

Here, the else part is ⊥ when the condition is met. Thus, in a
non-strict language, we have the possibility to wrap primitive control
statements such as if-then-else into functions like `cond`. This way, we
can define our own control operators. In a strict language, this is not
possible as both branches will be evaluated when calling `cond` which
makes it rather useless. This is a glimpse of the general observation
that non-strictness offers more flexibility for code reuse than
strictness. See the chapter
[Laziness](/wiki/Haskell/Laziness "Haskell/Laziness")^[[4]](#cite_note-4)^
for more on this subject.

Algebraic Data Types[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=17 "Edit section: Algebraic Data Types")]
-------------------------------------------------------------------------------------------------------------------------------------------

After treating the motivation case of partial functions between
`Integer`s, we now want to extend the scope of denotational semantics to
arbitrary algebraic data types in Haskell.

A word about nomenclature: the collection of semantic objects for a
particular type is usually called a **domain**. This term is more a
generic name than a particular definition and we decide that our domains
are cpos (complete partial orders), that is sets of values together with
a relation *more defined* that obeys some conditions to allow fixed
point iteration. Usually, one adds additional conditions to the cpos
that ensure that the values of our domains can be represented in some
finite way on a computer and thereby avoiding to ponder the twisted ways
of uncountable infinite sets. But as we are not going to prove general
domain theoretic theorems, the conditions will just happen to hold by
construction.

### Constructors[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=18 "Edit section: Constructors")]

Let's take the example types

    data Bool    = True | False
    data Maybe a = Just a | Nothing

Here, `True`, `False` and `Nothing` are nullary constructors whereas
`Just` is a unary constructor. The inhabitants of `Bool` form the
following domain:

[![Bool-graph.png](//upload.wikimedia.org/wikibooks/en/7/7d/Bool-graph.png)](/wiki/File:Bool-graph.png)

Remember that ⊥ is added as least element to the set of values `True`
and `False`, we say that the type is **lifted**^[[5]](#cite_note-5)^. A
domain whose poset diagram consists of only one level is called a **flat
domain**. We already know that
![Integer](//upload.wikimedia.org/math/a/0/f/a0faef0851b4294c06f2b94bb1cb2044.png)
is a flat domain as well, it's just that the level above ⊥ has an
infinite number of elements.

What are the possible inhabitants of `Maybe Bool`? They are

    ⊥, Nothing, Just ⊥, Just True, Just False

So the general rule is to insert all possible values into the unary
(binary, ternary, ...) constructors as usual but without forgetting ⊥.
Concerning the partial order, we remember the condition that the
constructors should be monotone just as any other functions. Hence, the
partial order looks as follows

[![Maybe-graph.png](//upload.wikimedia.org/wikibooks/en/1/16/Maybe-graph.png)](/wiki/File:Maybe-graph.png)

But there is something to ponder: why isn't `Just ⊥ = ⊥`? I mean "Just
undefined" is as undefined as "undefined"! The answer is that this
depends on whether the language is strict or non-strict. In a strict
language, all constructors are strict by default, i.e. `Just ⊥ = ⊥` and
the diagram would reduce to

[![Maybe-graph-strict.png](//upload.wikimedia.org/wikibooks/en/5/57/Maybe-graph-strict.png)](/wiki/File:Maybe-graph-strict.png)

As a consequence, all domains of a strict language are flat.

But in a non-strict language like Haskell, constructors are non-strict
by default and `Just ⊥` is a new element different from ⊥, because we
can write a function that reacts differently to them:

    f (Just _) = 4
    f Nothing  = 7

As `f` ignores the contents of the `Just` constructor, `f (Just ⊥)` is
`4` but `f ⊥` is `⊥` (intuitively, if `f` is passed ⊥, it will not be
possible to tell whether to take the Just branch or the Nothing branch,
and so ⊥ will be returned).

This gives rise to **non-flat domains** as depicted in the former graph.
What should these be of use for? In the context of [Graph
Reduction](/wiki/Haskell/Graph_reduction "Haskell/Graph reduction"), we
may also think of ⊥ as an unevaluated expression. Thus, a value
`x = Just ⊥` may tell us that a computation (say a lookup) succeeded and
is not `Nothing`, but that the true value has not been evaluated yet. If
we are only interested in whether `x` succeeded or not, this actually
saves us from the unnecessary work to calculate whether `x` is
`Just True` or `Just False` as would be the case in a flat domain. The
full impact of non-flat domains will be explored in the chapter
[Laziness](/wiki/Haskell/Laziness "Haskell/Laziness"), but one prominent
example are infinite lists treated in section [Recursive Data Types and
Infinite Lists](#Recursive_Data_Types_and_Infinite_Lists).

### Pattern Matching[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=19 "Edit section: Pattern Matching")]

In the section [Strict Functions](#Strict_Functions), we proved that
some functions are strict by inspecting their results on different
inputs and insisting on monotonicity. However, in the light of algebraic
data types, there can only be one source of strictness in real life
Haskell: pattern matching, i.e. `case` expressions. The general rule is
that pattern matching on a constructor of a `data`-type will force the
function to be strict, i.e. matching ⊥ against a constructor always
gives ⊥. For illustration, consider

    const1 _ = 1

    const1' True  = 1
    const1' False = 1

The first function `const1` is non-strict whereas the `const1'` is
strict because it decides whether the argument is `True` or `False`
although its result doesn't depend on that. Pattern matching in function
arguments is equivalent to `case`-expressions

    const1' x = case x of
       True  -> 1
       False -> 1

which similarly impose strictness on `x`: if the argument to the `case`
expression denotes ⊥ the whole `case` will denote ⊥, too. However, the
argument for case expressions may be more involved as in

    foo k table = case lookup ("Foo." ++ k) table of
      Nothing -> ...
      Just x  -> ...

and it can be difficult to track what this means for the strictness of
`foo`.

An example for multiple pattern matches in the equational style is the
logical `or`:

    or True _ = True
    or _ True = True
    or _ _    = False

Note that equations are matched from top to bottom. The first equation
for `or` matches the first argument against `True`, so `or` is strict in
its first argument. The same equation also tells us that `or True x` is
non-strict in `x`. If the first argument is `False`, then the second
will be matched against `True` and `or False x` is strict in `x`. Note
that while wildcards are a general sign of non-strictness, this depends
on their position with respect to the pattern matches against
constructors.

Exercises

1.  Give an equivalent discussion for the logical `and`
2.  Can the logical "excluded or" (`xor`) be non-strict in one of its
    arguments if we know the other?

There is another form of pattern matching, namely **irrefutable
patterns** marked with a tilde `~`. Their use is demonstrated by

    f ~(Just x) = 1
    f Nothing   = 2

An irrefutable pattern always succeeds (hence the name) resulting in
`f ⊥ = 1`. But when changing the definition of `f` to

    f ~(Just x) = x + 1
    f Nothing   = 2      -- this line may as well be left away

we have

    f ⊥       = ⊥ + 1 = ⊥
    f (Just 1) = 1 + 1 = 2

If the argument matches the pattern, `x` will be bound to the
corresponding value. Otherwise, any variable like `x` will be bound to
⊥.

By default, `let` and `where` bindings are non-strict, too:

    foo key map = let Just x = lookup key map in ...

is equivalent to

    foo key map = case (lookup key map) of ~(Just x) -> ...

\

Exercises

1.  The [Haskell language
    definition](http://www.haskell.org/onlinereport/) gives the detailed
    [semantics of pattern
    matching](http://www.haskell.org/onlinereport/exps.html#case-semantics)
    and you should now be able to understand it. So go on and have a
    look!
2.  Consider a function `or` of two `Bool`ean arguments with the
    following properties:

        or ⊥     ⊥    = ⊥
        or True  ⊥    = True
        or ⊥     True = True

        or False y     = y
        or x False     = x

    This function is another example of joint strictness, but a much
    sharper one: the result is only ⊥ if both arguments are (at least
    when we restrict the arguments to `True` and ⊥). Can such a function
    be implemented in Haskell?

### Recursive Data Types and Infinite Lists[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=20 "Edit section: Recursive Data Types and Infinite Lists")]

The case of recursive data structures is not very different from the
base case. Consider a list of unit values

    data List = [] | () : List

Though this seems like a simple type, there is a surprisingly
complicated number of ways you can fit
![\\bot](//upload.wikimedia.org/math/2/4/6/2462ef886428ee7d949936d41281f003.png)
in here and there, and therefore the corresponding graph is complicated.
The bottom of this graph is shown below. An ellipsis indicates that the
graph continues along this direction. A red ellipse behind an element
indicates that this is the end of a chain; the element is in normal
form.

[![List domain
graph.svg](//upload.wikimedia.org/wikipedia/commons/thumb/5/55/List_domain_graph.svg/505px-List_domain_graph.svg.png)](/wiki/File:List_domain_graph.svg)

and so on. But now, there are also chains of infinite length like

`⊥  ():⊥  ():():⊥  ...`

This causes us some trouble as we noted in section
[Convergence](#Convergence) that every monotone sequence must have a
least upper bound. This is only possible if we allow for **infinite
lists**. Infinite lists (sometimes also called *streams*) turn out to be
very useful and their manifold use cases are treated in full detail in
chapter [Laziness](/wiki/Haskell/Laziness "Haskell/Laziness"). Here, we
will show what their denotational semantics should be and how to reason
about them. Note that while the following discussion is restricted to
lists only, it easily generalizes to arbitrary recursive data structures
like trees.

In the following, we will switch back to the standard list type

    data [a] = [] | a : [a]

to close the syntactic gap to practical programming with infinite lists
in Haskell.

Exercises

1.  Draw the non-flat domain corresponding `[Bool]`.
2.  How is the graphic to be changed for `[Integer]`?

Calculating with infinite lists is best shown by example. For that, we
need an infinite list

    ones :: [Integer]
    ones = 1 : ones

When applying the fixed point iteration to this recursive definition, we
see that `ones` ought to be the supremum of

`⊥  1:⊥  1:1:⊥  1:1:1:⊥ ...`,

that is an infinite list of `1`. Let's try to understand what
`take 2 ones` should be. With the definition of `take`

    take 0 _      = []
    take n (x:xs) = x : take (n-1) xs
    take n []     = []

we can apply `take` to elements of the approximating sequence of `ones`:

    take 2 ⊥       ==>  ⊥
    take 2 (1:⊥)   ==>  1 : take 1 ⊥      ==>  1 : ⊥
    take 2 (1:1:⊥) ==>  1 : take 1 (1:⊥)  ==>  1 : 1 : take 0 ⊥
                   ==>  1 : 1 : []

We see that `take 2 (1:1:1:⊥)` and so on must be the same as
`take 2 (1:1:⊥) = 1:1:[]` because `1:1:[]` is fully defined. Taking the
supremum on both the sequence of input lists and the resulting sequence
of output lists, we can conclude

    take 2 ones = 1:1:[]

Thus, taking the first two elements of `ones` behaves exactly as
expected.

Generalizing from the example, we see that reasoning about infinite
lists involves considering the approximating sequence and passing to the
supremum, the truly infinite list. Still, we did not give it a firm
ground. The solution is to identify the infinite list with the whole
chain itself and to formally add it as a new element to our domain: the
infinite list *is* the sequence of its approximations. Of course, any
infinite list like `ones` can be compactly depicted as

    ones = 1 : 1 : 1 : 1 : ...

what simply means that

    ones = (⊥  1:⊥  1:1:⊥  ...)

Exercises

1.  Of course, there are more interesting infinite lists than `ones`.
    Can you write recursive definition in Haskell for
    1.  the natural numbers `nats = 1:2:3:4:...`
    2.  a cycle like `cycle123 = 1:2:3: 1:2:3 : ...`

2.  Look at the Prelude functions `repeat` and `iterate` and try to
    solve the previous exercise with their help.
3.  Use the example from the text to find the value the expression
    `drop 3 nats` denotes.
4.  Assume that the work in a strict setting, i.e. that the domain of
    `[Integer]` is flat. What does the domain look like? What about
    infinite lists? What value does `ones` denote?

What about the puzzle of how a computer can calculate with infinite
lists? It takes an infinite amount of time, after all? Well, this is
true. But the trick is that the computer may well finish in a finite
amount of time if it only considers a finite part of the infinite list.
So, infinite lists should be thought of as *potentially* infinite lists.
In general, intermediate results take the form of infinite lists whereas
the final value is finite. It is one of the benefits of denotational
semantics that one treat the intermediate infinite data structures as
truly infinite when reasoning about program correctness.

Exercises

1.  To demonstrate the use of infinite lists as intermediate results,
    show that

        take 3 (map (+1) nats) = take 3 (tail nats)

    by first calculating the infinite sequence corresponding to
    `map (+1) nats`.

2.  Of course, we should give an example where the final result indeed
    takes an infinite time. So, what does

        filter (< 5) nats

    denote?

3.  Sometimes, one can replace `filter` with `takeWhile` in the previous
    exercise. Why only sometimes and what happens if one does?

As a last note, the construction of a recursive domain can be done by a
fixed point iteration similar to recursive definition for functions.
Yet, the problem of infinite chains has to be tackled explicitly. See
the literature in [External Links](#External_Links) for a formal
construction.

### Haskell specialities: Strictness Annotations and Newtypes[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=21 "Edit section: Haskell specialities: Strictness Annotations and Newtypes")]

Haskell offers a way to change the default non-strict behavior of data
type constructors by *strictness annotations*. In a data declaration
like

    data Maybe' a = Just' !a | Nothing'

an exclamation point `!` before an argument of the constructor specifies
that it should be strict in this argument. Hence we have `Just' ⊥ = ⊥`
in our example. Further information may be found in chapter
[Strictness](/wiki/Haskell/Strictness "Haskell/Strictness").

In some cases, one wants to rename a data type, like in

    data Couldbe a = Couldbe (Maybe a)

However, `Couldbe a` contains both the elements `⊥` and `Couldbe ⊥`.
With the help of a `newtype` definition

    newtype Couldbe a = Couldbe (Maybe a)

we can arrange that `Couldbe a` is semantically equal to `Maybe a`, but
different during type checking. In particular, the constructor `Couldbe`
is strict. Yet, this definition is subtly different from

    data Couldbe' a = Couldbe' !(Maybe a)

To explain how, consider the functions

    f  (Couldbe  m) = 42
    f' (Couldbe' m) = 42

Here, `f' ⊥` will cause the pattern match on the constructor `Couldbe'`
fail with the effect that `f' ⊥ = ⊥`. But for the newtype, the match on
`Couldbe` will never fail, we get `f ⊥ = 42`. In a sense, the difference
can be stated as:

-   for the strict case, `Couldbe' ⊥` is a synonym for ⊥
-   for the newtype, ⊥ is a synonym for `Couldbe ⊥`

with the agreement that a pattern match on ⊥ fails and that a match on
`Constructor ⊥` does not.

Newtypes may also be used to define recursive types. An example is the
alternate definition of the list type `[a]`

     newtype List a = In (Maybe (a, List a))

Again, the point is that the constructor `In` does not introduce an
additional lifting with ⊥.

Other Selected Topics[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=22 "Edit section: Other Selected Topics")]
---------------------------------------------------------------------------------------------------------------------------------------------

### Abstract Interpretation and Strictness Analysis[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=23 "Edit section: Abstract Interpretation and Strictness Analysis")]

As lazy evaluation means a constant computational overhead, a Haskell
compiler may want to discover where inherent non-strictness is not
needed at all which allows it to drop the overhead at these particular
places. To that extent, the compiler performs **strictness analysis**
just like we proved in some functions to be strict section [Strict
Functions](#Strict_Functions). Of course, details of strictness
depending on the exact values of arguments like in our example `cond`
are out of scope (this is in general undecidable). But the compiler may
try to find approximate strictness information and this works in many
common cases like `power2`.

Now, **abstract interpretation** is a formidable idea to reason about
strictness: ...

![Clipboard](//upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Clipboard.svg/45px-Clipboard.svg.png)

**To do:**\
 Complete section

For more about strictness analysis, see the [research papers about
strictness analysis on the Haskell
wiki](http://haskell.org/haskellwiki/Research_papers/Compilation#Strictness).

### Interpretation as Powersets[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=24 "Edit section: Interpretation as Powersets")]

So far, we have introduced ⊥ and the semantic approximation order
![\\sqsubseteq](//upload.wikimedia.org/math/b/1/b/b1be6c28d38e18390ea808e56c4e1d93.png)
abstractly by specifying their properties. However, both as well as any
inhabitants of a data type like `Just ⊥` can be interpreted as ordinary
sets. This is called the **powerset construction**. NOTE: *i'm not sure
whether this is really true. Someone how knows, please correct this.*

The idea is to think of ⊥ as the *set of all possible values* and that a
computation retrieves more information this by choosing a subset. In a
sense, the denotation of a value starts its life as the set of all
values which will be reduced by computations until there remains a set
with a single element only.

As an example, consider `Bool` where the domain looks like

    {True}  {False}
       \      /
        \    /
       ⊥ = {True, False}

The values `True` and `False` are encoded as the singleton sets `{True}`
and `{False}` and ⊥ is the set of all possible values.

Another example is `Maybe Bool`:

     {Just True}   {Just False}
             \     /
              \   /
    {Nothing} {Just True, Just False}
         \      /
          \    /
     ⊥ = {Nothing, Just True, Just False}

We see that the semantic approximation order is equivalent to set
inclusion, but with arguments switched:

![x\\sqsubseteq y \\iff x \\supseteq
y](//upload.wikimedia.org/math/9/d/6/9d6752389f0df52d202ff6b909323593.png)

This approach can be used to give a semantics to exceptions in
Haskell^[[6]](#cite_note-6)^.

### Naïve Sets are unsuited for Recursive Data Types[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=25 "Edit section: Naïve Sets are unsuited for Recursive Data Types")]

In the section [What to choose as Semantic
Domain?](#What_to_choose_as_Semantic_Domain.3F), we argued that taking
simple sets as denotation for types doesn't work well with partial
functions. In the light of recursive data types, things become even
worse as John C. Reynolds showed in his paper *Polymorphism is not
set-theoretic*^[[7]](#cite_note-7)^.

Reynolds actually considers the recursive type

    newtype U = In ((U -> Bool) -> Bool)

Interpreting `Bool` as the set `{True,False}` and the function type
`A -> B` as the set of functions from `A` to `B`, the type `U` cannot
denote a set. This is because `(A -> Bool)` is the set of subsets
(powerset) of `A` which, due to a diagonal argument analogous to
Cantor's argument that there are "more" real numbers than natural ones,
always has a bigger cardinality than `A`. Thus, `(U -> Bool) -> Bool`
has an even bigger cardinality than `U` and there is no way for it to be
isomorphic to `U`. Hence, the set `U` must not exist, a contradiction.

In our world of partial functions, this argument fails. Here, an element
of `U` is given by a sequence of approximations taken from the sequence
of domains

`⊥, (⊥ -> Bool) -> Bool, (((⊥ -> Bool) -> Bool) -> Bool) -> Bool` and so
on

where ⊥ denotes the domain with the single inhabitant ⊥. While the
author of this text admittedly has no clue on what such a thing should
mean, the constructor gives a perfectly well defined object for `U`. We
see that the type `(U -> Bool) -> Bool` merely consists of shifted
approximating sequences which means that it is isomorphic to `U`.

As a last note, Reynolds actually constructs an equivalent of `U` in the
second order polymorphic lambda calculus. There, it happens that all
terms have a normal form, i.e. there are only total functions when we do
not include a primitive recursion operator `fix :: (a -> a) -> a`. Thus,
there is no true need for partial functions and ⊥, yet a naïve set
theoretic semantics fails. We can only speculate that this has to do
with the fact that not every mathematical function is computable. In
particular, the set of computable functions `A -> Bool` should not have
a bigger cardinality than `A`.

\

Notes[[edit](/w/index.php?title=Template:Haskell/NotesSection&action=edit&section=T-1 "Template:Haskell/NotesSection")]
-----------------------------------------------------------------------------------------------------------------------

1.  [↑](#cite_ref-1) In fact, there are no written down and complete
    denotational semantics of Haskell. This would be a tedious task void
    of additional insight and we happily embrace the folklore and common
    sense semantics.
2.  [↑](#cite_ref-2) Monads are one of the most successful ways to give
    denotational semantics to imperative programs. See also
    [Haskell/Advanced
    monads](/wiki/Haskell/Advanced_monads "Haskell/Advanced monads").
3.  [↑](#cite_ref-3) Strictness as premature evaluation of function
    arguments is elaborated in the chapter [Graph
    Reduction](/w/index.php?title=Haskell/Graph_Reduction&action=edit&redlink=1 "Haskell/Graph Reduction (does not exist)").
4.  [↑](#cite_ref-4) The term *Laziness* comes from the fact that the
    prevalent implementation technique for non-strict languages is
    called *lazy evaluation*
5.  [↑](#cite_ref-5) The term *lifted* is somewhat overloaded, see also
    [Unboxed Types](#Unboxed_Types).
6.  [↑](#cite_ref-6) S. Peyton Jones, A. Reid, T. Hoare, S. Marlow, and
    F. Henderson. [A semantics for imprecise
    exceptions.](http://research.microsoft.com/~simonpj/Papers/imprecise-exn.htm)
    In Programming Languages Design and Implementation. ACM press, May
    1999.
7.  [↑](#cite_ref-7) John C. Reynolds. *Polymorphism is not
    set-theoretic*. INRIA Rapports de Recherche No. 296. May 1984.

\

External Links[[edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit&section=26 "Edit section: External Links")]
-------------------------------------------------------------------------------------------------------------------------------

![Wikipedia-logo.png](//upload.wikimedia.org/wikipedia/commons/thumb/6/63/Wikipedia-logo.png/40px-Wikipedia-logo.png)

[Wikipedia](//en.wikipedia.org/wiki/ "w:") has related information at
[***Denotational
semantics***](//en.wikipedia.org/wiki/Denotational_semantics)

Online books about Denotational Semantics

-   Schmidt, David A. (1986). [*Denotational Semantics. A Methodology
    for Language
    Development*](http://www.cis.ksu.edu/~schmidt/text/densem.html).
    Allyn and Bacon.
    [http://www.cis.ksu.edu/\~schmidt/text/densem.html](http://www.cis.ksu.edu/~schmidt/text/densem.html).

**Denotational semantics**

[Solutions to
exercises](/wiki/Haskell/Solutions/Denotational_semantics "Haskell/Solutions/Denotational semantics")

**Wider Theory**

**Denotational semantics** [![75%
developed](//upload.wikimedia.org/wikipedia/commons/thumb/6/62/75_percent.svg/9px-75_percent.svg.png)](/wiki/Help:Development_stages "75% developed")
\>\> [Equational
reasoning](/w/index.php?title=Haskell/Equational_reasoning&action=edit&redlink=1 "Haskell/Equational reasoning (does not exist)")
\>\> [Program
derivation](/w/index.php?title=Haskell/Program_derivation&action=edit&redlink=1 "Haskell/Program derivation (does not exist)")
\>\> [Category
theory](/wiki/Haskell/Category_theory "Haskell/Category theory") \>\>
[The Curry-Howard
isomorphism](/wiki/Haskell/The_Curry-Howard_isomorphism "Haskell/The Curry-Howard isomorphism")
\>\> [fix and
recursion](/wiki/Haskell/Fix_and_recursion "Haskell/Fix and recursion")

[edit this
chapter](//en.wikibooks.org/w/index.php?title=Template:Haskell_chapter/Wider_Theory&action=edit)

\

**[Haskell](/wiki/Haskell "Haskell")**

[Haskell Basics](/wiki/Haskell/Haskell_Basics "Haskell/Haskell Basics")
\>\> [Elementary
Haskell](/wiki/Haskell/Elementary_Haskell "Haskell/Elementary Haskell")
\>\> [Intermediate
Haskell](/wiki/Haskell/Intermediate_Haskell "Haskell/Intermediate Haskell")
\>\> [Monads](/wiki/Haskell/Monads "Haskell/Monads")\
 [Advanced
Haskell](/wiki/Haskell/Advanced_Haskell "Haskell/Advanced Haskell") \>\>
[Fun with Types](/wiki/Haskell/Fun_with_Types "Haskell/Fun with Types")
\>\> [Wider Theory](/wiki/Haskell/Wider_Theory "Haskell/Wider Theory")
\>\> [Haskell
Performance](/wiki/Haskell/Haskell_Performance "Haskell/Haskell Performance")\

* * * * *

[Libraries
Reference](/wiki/Haskell/Libraries_Reference "Haskell/Libraries Reference")
\>\> [General
Practices](/wiki/Haskell/General_Practices "Haskell/General Practices")
\>\> [Specialised
Tasks](/wiki/Haskell/Specialised_Tasks "Haskell/Specialised Tasks")

[edit book
structure](//en.wikibooks.org/w/index.php?title=Template:Haskell_navigation&action=edit)

![image](//en.wikibooks.org/wiki/Special:CentralAutoLogin/start?type=1x1)

Retrieved from
"[http://en.wikibooks.org/w/index.php?title=Haskell/Denotational\_semantics&oldid=2687507](http://en.wikibooks.org/w/index.php?title=Haskell/Denotational_semantics&oldid=2687507)"

[Category](/wiki/Special:Categories "Special:Categories"):

-   [Haskell](/wiki/Category:Haskell "Category:Haskell")

Navigation menu
---------------

### Personal tools

-   [Create
    account](/w/index.php?title=Special:UserLogin&returnto=Haskell%2FDenotational+semantics&type=signup)
-   [Log
    in](/w/index.php?title=Special:UserLogin&returnto=Haskell%2FDenotational+semantics "You are encouraged to log in; however, it is not mandatory [o]")

### Namespaces

-   [Book](/wiki/Haskell/Denotational_semantics "View the content page [c]")
-   [Discussion](/wiki/Talk:Haskell/Denotational_semantics "Discussion about the content page [t]")

### Variants[](#)

### Views

-   [Read](/wiki/Haskell/Denotational_semantics)
-   [Edit](/w/index.php?title=Haskell/Denotational_semantics&action=edit "You can edit this page. Please use the preview button before saving [e]")
-   [View
    history](/w/index.php?title=Haskell/Denotational_semantics&action=history "Past revisions of this page [h]")

### More[](#)

### Search

[](/wiki/Main_Page "Visit the main page")

### Navigation

-   [Main Page](/wiki/Main_Page "Visit the main page [z]")
-   [Help](https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents "Find help on how to use and edit Wikibooks")
-   [Browse
    wiki](/wiki/Wikibooks:Card_Catalog_Office "Check out what Wikibooks has to offer")
-   [Cookbook](/wiki/Cookbook:Table_of_Contents "Learn recipes from around the world")
-   [Wikijunior](/wiki/Wikijunior "Books for children")
-   [Featured
    books](/wiki/Wikibooks:Featured_books "The best of Wikibooks")
-   [Recent
    changes](/wiki/Special:RecentChanges "A list of recent changes in the wiki [r]")
-   [Donations](//donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&utm_medium=sidebar&utm_campaign=C13_en.wikibooks.org&uselang=en "Support Wikibooks")
-   [Random book](/wiki/Special:RandomRootpage)
-   [Using Wikibooks](/wiki/Using_Wikibooks)

### Community

-   [Reading
    room](/wiki/Wikibooks:Reading_room "Discuss Wikibooks-related questions and concerns with others")
-   [Community
    portal](/wiki/Wikibooks:Community_Portal "Find your way around the Wikibooks community")
-   [Bulletin
    Board](/wiki/Wikibooks:Reading_room/Bulletin_Board "Important community news")
-   [Help
    out!](/wiki/Wikibooks:Maintenance "Frequent tasks that you can help with")
-   [Policies and
    guidelines](/wiki/Wikibooks:Policies_and_guidelines "Pages detailing important rules and procedures")
-   [Contact
    us](/wiki/Wikibooks:Contact_us "Alternative methods of communication")

### Tools

-   [What links
    here](/wiki/Special:WhatLinksHere/Haskell/Denotational_semantics "A list of all wiki pages that link here [j]")
-   [Related
    changes](/wiki/Special:RecentChangesLinked/Haskell/Denotational_semantics "Recent changes in pages linked from this page [k]")
-   [Upload
    file](//commons.wikimedia.org/wiki/Special:UploadWizard "Upload files [u]")
-   [Special
    pages](/wiki/Special:SpecialPages "A list of all special pages [q]")
-   [Permanent
    link](/w/index.php?title=Haskell/Denotational_semantics&oldid=2687507 "Permanent link to this revision of the page")
-   [Page
    information](/w/index.php?title=Haskell/Denotational_semantics&action=info)
-   [Cite this
    page](/w/index.php?title=Special:Cite&page=Haskell%2FDenotational_semantics&id=2687507 "Information on how to cite this page")

### In other languages

-   [](#)

### Sister projects

-   [Wikipedia](//en.wikipedia.org/wiki/Main_Page)
-   [Wikiversity](//en.wikiversity.org/wiki/Wikiversity:Main_Page)
-   [Wiktionary](//en.wiktionary.org/wiki/Wiktionary:Main_Page)
-   [Wikiquote](//en.wikiquote.org/wiki/Main_Page)
-   [Wikisource](//en.wikisource.org/wiki/Main_Page)
-   [Wikinews](//en.wikinews.org/wiki/Main_Page)
-   [Wikivoyage](//en.wikivoyage.org/wiki/Main_Page)
-   [Commons](//commons.wikimedia.org/wiki/Main_Page)
-   [Wikidata](//www.wikidata.org/wiki/Wikidata:Main_Page)

### Print/export

-   [Create a
    collection](/w/index.php?title=Special:Book&bookcmd=book_creator&referer=Haskell%2FDenotational+semantics)
-   [Download as
    PDF](/w/index.php?title=Special:Book&bookcmd=render_article&arttitle=Haskell%2FDenotational+semantics&oldid=2687507&writer=rl)
-   [Printable
    version](/w/index.php?title=Haskell/Denotational_semantics&printable=yes "Printable version of this page [p]")

-   This page was last modified on 1 August 2014, at 11:38.
-   Text is available under the [Creative Commons Attribution-ShareAlike
    License.](//creativecommons.org/licenses/by-sa/3.0/); additional
    terms may apply. By using this site, you agree to the [Terms of
    Use](//wikimediafoundation.org/wiki/Terms_of_Use) and [Privacy
    Policy.](//wikimediafoundation.org/wiki/Privacy_policy)

-   [Privacy
    policy](//wikimediafoundation.org/wiki/Privacy_policy "wikimedia:Privacy policy")
-   [About Wikibooks](/wiki/Wikibooks:Welcome "Wikibooks:Welcome")
-   [Disclaimers](/wiki/Wikibooks:General_disclaimer "Wikibooks:General disclaimer")
-   [Developers](https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute)
-   [Mobile
    view](//en.m.wikibooks.org/w/index.php?title=Haskell/Denotational_semantics&mobileaction=toggle_view_mobile)

-   [![Wikimedia
    Foundation](//bits.wikimedia.org/images/wikimedia-button.png)](//wikimediafoundation.org/)
-   [![Powered by
    MediaWiki](//bits.wikimedia.org/static-1.24wmf21/skins/common/images/poweredby_mediawiki_88x31.png)](//www.mediawiki.org/)


This markdown document has been converted from the html document located at:
https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
