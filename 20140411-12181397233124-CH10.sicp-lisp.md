[![image](http://hackerretreat.com/wp-content/themes/hackretreatv02/images/logo_02.png)](http://hackerretreat.com/ "Hacker Retreat Berlin")
===========================================================================================================================================

[Menu](/)

-   [About](http://hackerretreat.com/about/)
-   [Contact](http://hackerretreat.com/contact/)
-   [Imprint](http://hackerretreat.com/imprint/)
-   [Blog](http://hackerretreat.com/blog/)
-   [FAQs](http://hackerretreat.com/faqs/)
-   [Be a Sponsor](http://hackerretreat.com/sponsors/)
-   [Mentors](http://hackerretreat.com/mentors/)

-   [Be a Sponsor](http://hackerretreat.com/sponsors/)

-   [About](http://hackerretreat.com/about/)
-   [Contact](http://hackerretreat.com/contact/)
-   [Blog](http://hackerretreat.com/blog/)
-   [FAQs](http://hackerretreat.com/faqs/)
-   [Mentors](http://hackerretreat.com/mentors/)

Why and How to Start Your SICP Trek
===================================

###### Posted by [Kai Wu](http://hackerretreat.com/author/kai/ "View all posts by Kai Wu") on [April 7, 2014](http://hackerretreat.com/2014/04/07/ "2:20 pm")

**TL;DR***The Structure and Interpretation of Computer Programs*, aka
SICP or the Wizard book, is one of the very few books in computer
science and software engineering that has stood the test of time. Here
is an overview of why it’s a classic work and worthy of study, and why
it’s always ON at Hacker Retreat Berlin, including the upcoming
[Batch-02 this
summer](http://hackerretreat.com/batch-next/ "This Summer, Catalyze Your Code Career").
If you want to make serious headway on SICP and a slew of other tough
tech skills, [consider applying, and hack Lisp in
Berlin](http://hackerretreat.com/batch-next/?r=SICP "This Summer, Catalyze Your Code Career")!

> ![Wizards of
> SICP](http://hackerretreat.com/wp-content/uploads/2014/04/Wizards-of-SICP-300x295.jpg)
>
> We are about to study the idea of a *computational process*.
> Computational processes are abstract beings that inhabit computers. As
> they evolve, processes manipulate other abstract things called *data*.
> The evolution of a process is directed by a pattern of rules called a
> *program*. People create programs to direct processes. In effect, we
> conjure the spirits of the computer with our spells.
>
> A computational process is indeed much like a sorcerer’s idea of a
> spirit. It cannot be seen or touched. It is not composed of matter at
> all. However, it is very real. It can perform intellectual work. It
> can answer questions. It can affect the world by disbursing money at a
> bank or by controlling a robot arm in a factory. The programs we use
> to conjure processes are like a sorcerer’s spells.
>
> — *SICP, Chapter 1*

A Recurrent Question, a Recursive Answer
----------------------------------------

This post was first envisioned for those at [Hacker
Retreat](http://hackerretreat.com/about/ "About") – or thinking of
attending – before it became more general. It’s meant to be a standing
answer to the question, “How can I best improve as a coder?”

Because I hear that question from people committed to coding – i.e.
professionally for the long haul – the short answer I always give is,
“Do SICP!” \*

Since that never seems to be convincing enough, here’s the long answer.
![:)](http://hackerretreat.com/wp-includes/images/smilies/icon_smile.gif)
I’ll give a short overview of SICP’s benefits, then use arguments from
(justified) authority and argument by analogy to convince you that
working through SICP is worth the time and effort. Then I’ll share some
practical tips to help you on your SICP trek.

\* Where SICP = *The Structure and Interpretation of Computer Programs*
by Hal Abelson and Gerald Sussman of MIT, aka the [Wizard
book](http://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs).

BTW, excuse my enthusiasm for SICP if it comes across at times as
monolingual theistic fanaticism. I’m aware that there are many
interesting developments in CS and software engineering outside of the
Wizard book – and no single book can cover everything. Nevertheless,
SICP has been enormously influential as an enduring text on the nature
and fundamentals of computing – and tends to pay very solid dividends on
your investments of attention.

Your SICP-derived Augmentations Await
-------------------------------------

> “I’m augmented.”
>
> — J.C. Denton, *Deus Ex*

SICP is a sizable, dense book. Especially for those without a CS degree
or any exposure to Lisp, it may seem impenetrably obscure, and far
removed from the day-to-day coding concerns of use-cases, wireframes,
API calls, StackOverflow, failing tests, and [TPS
reports](https://www.youtube.com/watch?v=Fy3rjQGc6lA). For the working
coder, of what possible concern are SICP sections like “Symbolic Data,”
“Streams,” or even “Formulating Abstractions with Higher-Order
Procedures”? Quite a lot, as I’ll try to give a sense of.

Without exception, everyone I know who put time into SICP was richly
rewarded for it, in becoming more skillful coders. The foundation of
skill is understanding. One big, clear sign of understanding is knowing
and accurately predicting the immediate and longer-term consequences of
the many, many decisions made while coding. In that light, what does
SICP help you understand and do better?

1.  **Write less code that does more** – aka code that’s more
    “expressive,” “higher-order,” and “declarative.” After all,
    everything else being equal (readability, correctness, performance,
    etc.), the less code there is, the better! Less to read (and code
    gets read at least 20x more often than it’s written), less to debug,
    less to debug :), less space (screen, drive, network), less
    documentation – less code is generally preferable. SICP offers many
    techniques and examples of this maxim, e.g. with first-class
    functions in Ch.1, generic operations in Ch.2, and so on. The “SICP
    jewel” of Ch.4 is a crowning example, to be discussed below.
2.  **Design and write code that’s easier to evolve and change**.
    Expressive code that’s structured and designed properly – i.e. with
    the correct abstractions – enables such flexibility. This lesson
    shows up over and over again in SICP, as choosing the right
    abstractions is a major, recurrent theme.
3.  **Faster, semantics-focused, language-agnostic understanding**. Yes,
    SICP is taught using a Lisp dialect, Scheme, but it is not
    ultimately about Lisp or Scheme. The rules and syntax of Lisp are so
    simple that they fade quickly from conscious concern – which lets
    you focus on semantics, and “see” the real problem, process, or
    system being addressed. No matter the language, using concepts like
    functions, data, processes, state, time, and abstraction will always
    be involved. Once this focus on the semantics becomes a habit, you
    can pick up other languages and libraries quicker than before.
4.  **Domain-level coding**. If the maxim of makers everywhere is “Pick
    the right tool for the job!” then SICP takes that idea to the max:
    **create the right language for the job**. This ability is most
    evident by Ch.4 where you play with Lisp-in-Lisp, modifying it to
    have different semantics: lazy evaluation, back-tracking, and logic.
    But it is a recurrent theme throughout SICP, and starts appearing
    early in the book, in various disguises.

What (Great) Coders Say About SICP
----------------------------------

Perhaps software development is too young a domain to have any of its
works deserving the label *timeless classic*. But for now, SICP would be
on the shortlist for such consideration. There are books that are
frequently mentioned as classics, such as Knuth’s *The Art of Computer
Programming*, or the style and career-focused books *Code Complete* or
*The Pragmatic Programmer*. But **SICP is on its own shelf, for
imparting a way of thinking transcending any single language.**

What follows are commentaries by some software masters and veterans to
motivate your own SICP journey:

[Peter Norvig](http://norvig.com/), world-renowned AI expert and
Director of Research at Google, wrote a [review of SICP on
Amazon.com](http://www.amazon.com/review/R403HR4VL71K8/) – and here’s a
choice snippet:

> To use an analogy, if SICP were about automobiles, it would be for the
> person who wants to know how cars work, how they are built, and how
> one might design fuel-efficient, safe, reliable vehicles for the 21st
> century. The people who hate SICP are the ones who just want to know
> how to drive their car on the highway, just like everyone else.\
>  Those who hate SICP think it doesn’t deliver enough tips and tricks
> for the amount of time it takes to read. But if you’re like me, you’re
> not looking for one more trick, rather you’re looking for a way of
> synthesizing what you already know, and building a rich framework onto
> which you can add new learning over a career. That’s what SICP has
> done for me. I read a draft version of the book around 1982, when I
> was in grad school, and it changed the way I think about my
> profession. If you’re a thoughtful computer scientist (or want to be
> one), it will change your life too.

[Why SICP matters](http://www.eecs.berkeley.edu/~bh/sicp.html) by Brian
Harvey, veteran UC Berkeley CS teacher. This is a short essay on the
impact and importance of SICP, especially with his students. You can
also read [extensive discussion on
HN](https://news.ycombinator.com/item?id=5631441) about this essay and
the value of SICP to veteran software developers (including comments
from former students of Harvey).

> SICP itself has had a longevity that’s very unusual for introductory
> CS textbooks. Usually, a book lasts only as long as the language fad
> to which it is attached. SICP has been going strong for over 25 years
> and shows no sign of going out of print. Computing has changed
> enormously over that time, from giant mainframe computers to personal
> computers to the Internet on cell phones. And yet the big ideas behind
> these changes remain the same, and they are well captured by SICP.

Paul Graham, founder of [Hacker News](http://news.ycombinator.com/),
YCombinator, and author of the much-praised *On Lisp*, also wrote a
[review of SICP on
Amazon](http://www.amazon.com/review/R3G05B1TQ5XGZP/ref=cm_cr_pr_perm),
partly reacting to some of the negative reviews SICP has received:

> This is one of the great classics of computer science. I bought my
> first copy 15 years ago, and I still don’t feel I have learned
> everything the book has to teach.\
>  I have learned enough to write a couple books on Lisp that
> (currently) have four to five stars. Yet SICP, which is pretty much
> the bible of our world, has only three? How can this be?
>
> Reading the reviews made it clear what happened. An optimistic
> professor somewhere has been feeding SICP to undergrads who are not
> ready for it. But it is encouraging to see how many thoughtful people
> have come forward to defend the book.
>
> Let’s see if we can put this in terms that the undergrads will
> understand – a problem set:
>
> 1.  Kenneth Clark said that if a lot of smart people have liked
>     something that you don’t, you should try and figure out what they
>     saw in it. List 10 qualities that SICP’s defenders have claimed
>     for it.
> 2.  How is the intention of SICP different from that of Knuth?
>     Kernighan & Ritchie? An algorithms textbook?
> 3.  Does any other book fulfill this purpose better?
> 4.  What other programming books first published in the mid 1980s are
>     still relevant today?
> 5.  Could the concepts in this book have been presented any better in
>     a language other than Scheme?

From the book *Coders at Work*, Jamie Zawinksi of XEmacs and Netscape
fame:

> Seibel: What about books? Are there particular computer-science or
> programming books that everyone should read?
>
> Zawinski: The one I always recommend is *Structure and Interpretation
> of Computer Programs*, which a lot of people are afraid of because
> it’s Lispy, but I think does a really good job of teaching programming
> without teaching a language. I think a lot of introductory-level stuff
> focuses on syntax and I definitely saw that in the classes I had in
> high school and in the intro classes at Carnegie-Mellon during my
> brief time there.

Also from *Coders at Work*, Simon Peyton [Jones of Haskell
fame](http://en.wikipedia.org/wiki/Simon_Peyton_Jones) has SICP on his
shortlist when asked for favorite books:

> Of course, Don Knuth’s series, *The Art of Computer Programming*. I
> don’t think it was ever anything I read straight through; it’s not
> that kind of book. I certainly referred to it a lot at one stage.
> Chris Okasaki’s book *Purely Functional Data Structures*. Fantastic.
> It’s like Arthur Norman’s course only spread out to a whole book. It’s
> about how you can do queues and lookup tables and heaps without any
> side effects but with good complexity bounds. Really, really nice
> book. Everyone should read this. It’s also quite short and accessible
> as well. *Structure and Interpretation of Computer Programs*. Abelson
> and Sussman. I loved that.

If you spend any time on [Hacker News](http://news.ycombinator.com/)
you’ll also find many, many recommendations and great respect for SICP
by experienced coders. You can [search for “SICP” on Hacker
News](https://hn.algolia.com/?q=sicp#!/all/forever/0/sicp) and see over
2300 results as of Spring 2014. Here are some highlights:

-   A few years ago, some flagship US universities (UC/Berkeley, MIT)
    removed SICP from their introductory curricula, causing much uproar.
    SICP endures at those schools, but more for upper-level and graduate
    courses (there’s an important tangent of lowered academic standards
    and over-emphasizing practicality at elite schools, but I won’t
    digress). You can read passionate defenses of the value of SICP at
    this thread:
    [https://news.ycombinator.com/item?id=2843715](https://news.ycombinator.com/item?id=2843715)
-   Poll: Have you read SICP?
    [https://news.ycombinator.com/item?id=2846799](https://news.ycombinator.com/item?id=2846799)
    Many interesting comments here.
-   The already mentioned essay *Why SICP Matters* had great commentary
    on HN here:
    [https://news.ycombinator.com/item?id=5631441](https://news.ycombinator.com/item?id=5631441)
    One quote from user calinet:

> SICP was, in retrospect, a masterpiece of education. Someone sat down
> and thought about exactly these concepts and how best to elucidate
> them without getting in the way of the connections being made. The new
> trend toward applications-focused education feels to me like the wrong
> direction, and I don’t think I would get as good an education today as
> I did learning abstract concepts theoretical computer science taught
> as the most important part.

You can also find mentions of SICP on StackOverflow and
Programmers.StackExchange – but the over-zealous moderators there have
deleted many popular threads (with scores to hundreds of upvotes) on
SICP and other topics, destroying community knowledge willy-nilly.

The Jewel in SICP
-----------------

> Everything should be made as simple as possible, but not simpler.
>
> — Einstein

> Any intelligent fool can make things bigger, more complex, and more
> violent. It takes a touch of genius – and a lot of courage – to move
> in the opposite direction.
>
> — Einstein

My college degree was in physics. At the time, being younger and often
stuck in my head, I was drawn to the elegance and beauty of physics
equations (solving them was another matter). It still remains incredible
and marvelous that a handful of mathematical expressions could so
concisely describe a huge range of phenomena.

Newton’s laws of motion from the 17th century – in particular the 2nd
law – kicked off the modern era of science and technology.
Re-formulations of Newton’s laws using more basic concepts like
conservation of momentum and energy still owe their existence to his
deceptively simple set of rules, the most famous of which is:

![Newton's 2nd
Law](http://hackerretreat.com/wp-content/uploads/2014/04/Newton-2nd-law.png)

Maxwell’s equations were published in the 19th century, and remain
popular as t-shirt decorations. It took some struggles with calculus to
appreciate them in their native form, but what a rush when the parts
came together! I still remember a final-exam question of Professor
Lovelace’s electromagnetism class, “Assume the existence of magnetic
monopoles; reformulate Maxwell’s equations accordingly.” And a lecture
by Professor LePage in junior-level electrodynamics, where he connected
the different electric and magnetic field/potential equations into the
seamless wholeness of Maxwell’s. LePage spoke louder and faster as he
chalked furiously on the blackboard, the equations reduced again and
again to simpler forms, until the final form emerged…and it was like the
doors of heaven being cracked open:

![Maxwell's
equations](http://hackerretreat.com/wp-content/uploads/2014/04/Maxwell-equations-300x224.png)

So, what does physics have to do with SICP and software? In my journey
from a writer of toy-programs to framework-user to efficient glue-coder
to systems-integrator to architect-own-libraries into usable-systems –
**only SICP’s content and exercises have ever given me the same sense of
awe and delight that physics did** (well, that plus Rich Hickey’s works,
and Alan Kay’s).

How did SICP inspire such delight? By revealing minimalist, foundational
simplicity at the heart of many outer, seemingly unrelated complexities.
“This is it – it cannot be simpler. And behold its elegance!” When you
realize that many complex things are just special cases of something
simpler, the eyes open wide, the spine tingles, and you may just feel
part of something grander.

> …the half page of code on the bottom of page 13…was Lisp in itself.
> These were “Maxwell’s Equations of Software!”
>
> — Alan Kay, Turing Award recipient

Let’s start with the t-shirt level of expression, from SICP. Being
Asian, I certify this as a legitimate derivative/cross-cultural use of
the ancient symbol of cosmic duality between Yin and Yang (aka the Tao):

![Eval and apply as the
Tao](http://hackerretreat.com/wp-content/uploads/2014/04/eval-apply-300x119.gif)

Colloquially, **a program is what directs a process**. A process
involves *evaluating* expressions within an environment. In particular,
evaluating procedure expressions (i.e. combinations of expressions)
requires *applying* the procedure’s operator to its operands/arguments –
and those arguments may need to be evaluated themselves.

This interplay between eval and apply (and eval and apply again, and so
on) is the program’s *process*. If that sounds recursive, that’s because
it is – it’s eval and apply all the way down! When you work through
enough SICP to see, feel, and use how this works, you’ll have a
“Eureka!” high, far exceeding my brief dabbling here.

And what makes eval and apply work? Are they black boxes? Not at all. In
fact, they can be built up from**just 7 operators, and 1 notation for
functions**:

-   The primitive operators: quote, atom, eq, car, cdr, cons, cond
-   Function notation: lambda

I only list these parts – explanation has been better done elsewhere
(see SICP of course, or for brevity, Paul Graham’s [The Roots of
Lisp](http://paulgraham.com/rootsoflisp.html)). Where do those 8 basic
parts come from? From John McCarthy, Lisp creator, per his 1960
foundational paper, *Recursive Functions of Symbolic Expressions and
Their Computation by Machine*, [available online in multiple
formats](http://www-formal.stanford.edu/jmc/recursive.html).

And where/how did McCarthy get these core ideas? The Great Coder in the
Sky? Maybe… As Paul Graham’s elegant paper *The Roots of Lisp* put it,
Lisp creator John **McCarthy didn’t so much invent as discover these
core parts**, which reflect the lambda calculus computing model ([versus
the better-known Turing machine
model](http://cstheory.stackexchange.com/questions/625/relationship-between-turing-machine-and-lambda-calculus)).

Those models – like physics models – reflect deeper realities in our
universe: space, time, and changes in energy/information through space
and time. An apple or satellite falling towards Earth is mass (which is
energy) changing across space and time, which we model with Newton’s
laws. A computer simulation of the apple or satellite falling towards
Earth is a model of space, time and energy – and itself is modeled by a
process that evolves through space (memory, energy/information) and time
(sequences, steps)…

Here’s another way to look at it: A formal language has just three
concepts that combine and multiply fruitfully: **primitive expressions**
(e.g. numbers), **special forms** (e.g. quoted expressions, assignments,
logic, lambda), and **combinations** (i.e. procedures and applying
them). Or as the SICP authors put it, understanding any computer
language just comes down to three questions:

1.  What are the primitives?
2.  What are the means of abstraction?
3.  What are the means of combination?

Just asking those questions of your favorite language may spark new
insights – a **new mental framework to structure your understanding**,
instead of just memorizing language syntax and APIs.

Now, before we get to SICP’s jewel – if you’ve never seen Lisp before,
you can still get an inkling of the jewel by learning one simple rule.
The most common Lisp expression is a combination expression, which is a
list of expressions within parentheses. The first element is the
*operator* (e.g. the function), the rest *operands*. This simple,
utterly consistent prefix notation enables great generality and power,
especially later with macros:

Basic Lisp/Scheme examples.

Scheme

(+ 1 2) ; operator is +, returns 3 (\* 2 3) ; operator is \*, returns 6
;; anonymous function taking and adding two args, x and y (lambda (x y)
(+ x y)) ;; Putting that anonymous function in a list makes it the
operator: ((lambda (x y) (+ x y)) 1 2) ; returns 3 ;; Defining a
procedure - notice how w/ Lisp prefix notation, using ;; symbols like -
or ? are allowed, and improve code readability: (define (is-positive? x)
(cond ((\> x 0) true) (else false))) (is-positive? 1) ; returns \#t,
i.e. true

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

(+ 1 2) ; operator is +, returns 3

(\* 2 3) ; operator is \*, returns 6

;; anonymous function taking and adding two args, x and y

(lambda (x y) (+ x y))

;; Putting that anonymous function in a list makes it the operator:

((lambda (x y) (+ x y)) 1 2) ; returns 3

;; Defining a procedure - notice how w/ Lisp prefix notation, using

;; symbols like - or ? are allowed, and improve code readability:

(define (is-positive? x)

(cond ((\> x 0) true)

(else false)))

(is-positive? 1) ; returns \#t, i.e. true

Alright, with all that said, here’s the jewel in the heart of SICP –
it’s Lisp defined in Lisp. This comes in Chapter 4, introduced after
hundreds of pages and work on functions, data, and state:

Lisp in Lisp

Scheme

(define (eval exp env) (cond ((self-evaluating? exp) exp) ((variable?
exp) (lookup-variable-value exp env)) ((quoted? exp) (text-of-quotation
exp)) ((assignment? exp) (eval-assignment exp env)) ((definition? exp)
(eval-definition exp env)) ((if? exp) (eval-if exp env)) ((lambda? exp)
(make-procedure (lambda-parameters exp) (lambda-body exp) env)) ((begin?
exp) (eval-sequence (begin-actions exp) env)) ((cond? exp) (eval
(cond-\>if exp) env)) ((application? exp) (apply (eval (operator exp)
env) (list-of-values (operands exp) env))) (else (error "Unknown
expression type -- EVAL" exp)))) (define (apply procedure arguments)
(cond ((primitive-procedure? procedure) (apply-primitive-procedure
procedure arguments)) ((compound-procedure? procedure) (eval-sequence
(procedure-body procedure) (extend-environment (procedure-parameters
procedure) arguments (procedure-environment procedure)))) (else (error
"Unknown procedure type -- APPLY" procedure))))

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

(define (eval exp env)

(cond ((self-evaluating? exp) exp)

((variable? exp) (lookup-variable-value exp env))

((quoted? exp) (text-of-quotation exp))

((assignment? exp) (eval-assignment exp env))

((definition? exp) (eval-definition exp env))

((if? exp) (eval-if exp env))

((lambda? exp)

(make-procedure (lambda-parameters exp)

(lambda-body exp)

env))

((begin? exp)

(eval-sequence (begin-actions exp) env))

((cond? exp) (eval (cond-\>if exp) env))

((application? exp)

(apply (eval (operator exp) env)

(list-of-values (operands exp) env)))

(else

(error "Unknown expression type -- EVAL" exp))))

(define (apply procedure arguments)

(cond ((primitive-procedure? procedure)

(apply-primitive-procedure procedure arguments))

((compound-procedure? procedure)

(eval-sequence

(procedure-body procedure)

(extend-environment

(procedure-parameters procedure)

arguments

(procedure-environment procedure))))

(else

(error

"Unknown procedure type -- APPLY" procedure))))

In the original video lectures recorded in the 1980′s with the authors
Sussman and Abelson, [the above
code](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/7a-metacircular-evaluator-part-1/)
is introduced with Richard Strauss’ *Thus Spoke Zarathustra* and wizard
costumes – entirely appropriate, methinks. **Code is data is code** is
manifest above – a process that shapes and directs other processes,
including itself.

Now, some may complain the above code is just a gobbleygook of
parentheses and not elegant at all. But just like the calculus forms of
Newton’s laws and Maxwell’s equations, the message takes time to
appreciate and use, and is always longer when expressed for real
contexts. F=ma is used to launch rockets and guide interplanetary
probes, but it takes a few more lines of expanding what m and a are.

To sum up: If you work through the book, you’ll understand how and why
all the above code works. Furthermore, you’ll be able to modify it and
**invent new languages supporting new ideas and processes** – an ability
that the SICP authors consider the ultimate benefit of their teaching.
And that is why Lisp-in-Lisp remains – decades after its invention – the
jewel of not just SICP, but programming languages generally.

What to Pack on Your SICP Journey
---------------------------------

> You do not know anything until you have practiced.
>
> — Richard Feynman, Nobel laureate in physics

> The difference between a bad programmer and a good programmer is
> **understanding**.
>
> — Max Kanat-Alexander, *Code Simplicity*

You must do the exercises to get the most out of SICP. Reading will not
suffice. Videos will not suffice. Putting on a wizard cape will not
suffice. Only doing the exercises will bring lasting shifts to how you
see and understand code.

*Post-pub note: But which SICP exercises?? Great question. A very
advanced coding friend suggested I need to pick out the subset of
exercises that yield the most understanding. I’ll take up her challenge
in future posts.*

I started my SICP journey a few years ago while working on my doctorate
degree – for many months at a time, the first task at dawn was to read
SICP and do exercises. Progress was interrupted by a lengthy
dissertation, startup work, and relocating to a new
city/country/continent – but I’m still at it, because the journey has
been a fantastic mental-adventure, and made me a far better coder.

So the following suggestions are from someone who has attempted every
exercise through Chapter 4.3, and completed most of them (\>95%, I’d
estimate). I’ve also taken extensive notes, watched the videos, and
checked multiple solutions after I finished an exercise, to see if
someone did it better. The best SICP resources:

1.  [The online book,
    ToC](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%25_toc_start)
    – this tab is always open. The [main book
    site](http://mitpress.mit.edu/sicp/) also has useful links like the
    book’s code, sometimes with key comments and tweaks not seen in the
    book – especially handy in later chapters.
2.  [MIT-Scheme](http://www.gnu.org/software/mit-scheme/) and the
    documentation links there, especially the section on
    [debugging](http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/Debugging.html#Debugging).
    Use the same tool that the authors – and generations of MIT students
    – used. **Do NOT waste your time with any other Scheme or Lisp
    dialect** for doing SICP. Of course, if you’re a hobbyist and want
    to write your own Lisp to do SICP, ignore this advice. For everyone
    else: there are many well-intentioned tips to use Racket, Common
    Lisp, Clojure, and even attempts to translate SICP for non-Lisps
    like JavaScript, Python, or Haskell – but don’t waste your time. Why
    not? On a close look, you’ll notice that none of these alternatives
    address later SICP chapters (3, 4, sometimes even giving up by
    chapter 2), as language features are missing or incompatible. I know
    this by direct experience, as I had to drop several non-MIT Scheme
    versions along the way. Stick with the parentheses of MIT-Scheme!
3.  [Video lectures by Abelson and
    Sussman](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/)
    and the [course homepage at
    OCW](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/index.htm).
    See 80′s hairstyles, wizard costumes, good questions by an audience
    of professionals, and great answers by the authors. Because these
    lectures predate the 2nd edition text (online above), the order of
    topics won’t match the book exactly, but that’s not a major problem.
4.  [Emacs is well-supported by
    MIT-Scheme](http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/GNU-Emacs-Interface.html#GNU-Emacs-Interface),
    with parentheses highlighting and balancing (ParEdit or
    SmartParens), letting you edit in one buffer, and then with a single
    keystroke, send the code to the Scheme REPL for evaluation. Vim
    users can still keep their fingers happy with
    [Evil](http://www.emacswiki.org/emacs/Evil). For Emacs newcomers,
    it’s worth installing the [Prelude
    configuration](https://github.com/bbatsov/prelude) for good,
    sane-defaults behavior. And for those who are “life-optimizers” –
    with editors I’ve found nothing as generally useful as [Org mode for
    Emacs](http://orgmode.org/). Besides delivering on its promise as
    “Your life in plain text,” Org has excellent [literate programming
    capabilities](http://orgmode.org/org.html#Working-With-Source-Code),
    letting you combine structured text (including tables and
    subsections) with code blocks that are executable (or turned off).
    I’m in the process of readying all my solutions into Org files to be
    shared – more on this in the future.
5.  Online solutions – generally search for “sicp exercise FOO” where
    FOO is the number, and you’ll find other solutions to contrast and
    compare. Sometimes, you’ll be amazed how much simpler someone else’s
    code is. Notable names: [Eli
    Bendersky](http://eli.thegreenplace.net/category/programming/lisp/sicp/)
    finished the book in 2008 and generally has good commentary on his
    solutions, though some are written in Common Lisp, and he bunches
    solutions together so if you don’t want hints to the next one,
    scroll carefully. [Weiqun
    Zhang](http://wqzhang.wordpress.com/sicp-solutions/) solved most of
    the exercises and is always worth comparing against, as his code is
    almost always concise and correct. But he very rarely provides any
    comments on his thinking process.

Number 6 would be the SICP exercises, which you must do! Maybe not every
single one, but it’s worth trying at least 10 minutes on each one. I
generally follow a rule of 1-hour on my own, then look for a hint if
stuck. That’s my hack for not having classmates to talk about it with.

SICP Will Always be ON at Hacker Retreat
----------------------------------------

If the above has inspired you to start your SICP Trek, great! Let me
know how it goes. Grab a code buddy if you can, it’ll be more fun that
way.

Now here’s a shameless plug: **Hacker Retreat’s largest mission is to
find and share what works to create great software**. Until and unless
something better than SICP comes along, it’s on our A-list. As a
co-founder and facilitator at Hacker Retreat Berlin, know that SICP will
always be ON at our sessions – meaning anyone attending will have me
around and available to talk SICP. That includes the upcoming [Batch-02
May-July 2014, at the swank office of MSVentures
Berlin](http://hackerretreat.com "Homepage, Batch-02"). I will always
recommend it to anyone at Hacker Retreat who is past the beginner stage
and wants a deeper, cross-language, multi-paradigm understanding of
creating code. And like everyone else at [Hacker
Retreat](http://hackerretreat.com/about/ "About"), I’m happy to help
share what I know.

Most people find SICP very challenging. So having someone around who’s
done it and will encourage you to keep at it – until it’s a habit –
should be a strong catalyst for your learning. If you take it up, I’ll
also show you my careful time-tracking table of how long each exercise
takes – and welcome more data from your experience.

In sum, even if MIT, Berkeley, and other schools ultimately give up
teaching SICP, it will live on - because its content reflects the widest
range of software fundamentals in the most coherent presentation
available.

*Starting in May, YOU could be learning and working faster and better,
surrounded by smart and friendly coders in one of the coolest cities in
Europe. Hacker Retreat Berlin has a handful of spots left for its summer
session.*

[Hacker Retreat Batch-02](/batch-next?r=SICP "Apply to HRet Batch-02")

*Also, if you’re a coder who wants to become a data scientist, or a
scientist who wants to code, consider the sister-program of Data Science
Retreat.*

**[Data Science
Retreat](http://datascienceretreat.com/?r=SICP "Apply to Data Science Retreat")**\

p.s. Below is the Seal of the Knights of the Lambda Calculus –
understanding it is one more benefit of trekking through SICP. So join
the Order!

![Seal of the Knights of the Lambda
Calculus](http://hackerretreat.com/wp-content/uploads/2014/04/Knights-Lambda-Calculus-300x300.png)

Posted in
[Uncategorized](http://hackerretreat.com/category/uncategorized/ "View all posts in Uncategorized")
| Tagged [classics](http://hackerretreat.com/tag/classics/),
[Lisp](http://hackerretreat.com/tag/lisp/),
[SICP](http://hackerretreat.com/tag/sicp/) | [**14**
Replies](http://hackerretreat.com/why-how-start-sicp/#comments "Comment on Why and How to Start Your SICP Trek")

![image](http://0.gravatar.com/avatar/23df98f044e55b8c041e556c4c0060b4?s=68&d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D68&r=G)

About Kai Wu
------------

(× (+ energy software) (+ engineer entrepreneur) (facilitator
Hacker-Retreat)) Dr. Kai Wu is working on a clean energy startup in the
urban utopia known as Berlin. Favorite tools include Emacs,
Lisp/Clojure, and the peerless Org mode.

[View all posts by Kai Wu →](http://hackerretreat.com/author/kai/)

### Post navigation

[← Do soft-skills matter to coders? Will being at Hacker Retreat help
build them? Heck
yeah!](http://hackerretreat.com/soft-skills-matter-coders-will-hacker-retreat-help-build-heck-yeah/)
[R: The Good Parts →](http://hackerretreat.com/r-good-parts/)

-   talykar

    Thank you. I’ve become interested to try to read it again.

    -   http://limist.com/ Kai

        Cool, glad to hear it! Feel free to post follow-up questions
        here, will be happy to help. It’s not a short nor easy journey,
        but it’s very worthwhile.

-   http://rs.io adbge

    I think the real genius of SICP — something you’ve touched on here —
    is the authors’ insistence on asking, “What’s this about, really?”
    This gives the book a depth that’s very hard to find elsewhere.

    -   http://limist.com/ Kai

        Yes, that’s a big part of its enduring lessons. Many of the SICP
        footnotes touch and hint on the larger questions too. One good
        example is 3.5.5, which ends of a profound note of how the two
        competing computational models of reality currently seem
        incompatible (time-bound objects with mutating state, vs. single
        timeless unity), and separately seem not quite adequate.

-   http://www.facebook.com/terrence.a.davis1 Terrence Andrew Davis

    Sadly, most of the theoretical people don’t know a switch()
    statement is not if-else’s. Most think a hash is for security.
    People are being giving bad education by the CIA, ironically.

-   http://www.facebook.com/emsternberg E. Mathieu Sternberg

    What features of MIT Scheme are lacking from other Lisps, such that
    you couldn’t complete SICP using another Lisp?

    -   http://limist.com/ Kai

        You’ll find lots of little things are off or slightly different
        w/ Racket, PLT/Scheme, Clojure, SBCL, etc. e.g. even though
        there is/was a SICP pack for PLT/Scheme, things like hashes/maps
        started working differently by Chapter 2 – it’s as if no one
        tried using it with SICP past Chapter 1. Now, that’s of no
        matter to someone who just loves Racket or PLT and wants to use
        that for other coding projects, but I’m in SICP mainly for its
        lessons, not to tinker with dialects. I prefer Clojure for
        production work.

        -   http://www.estebanrules.com Damian Esteban

            I’ve been meaning to work through SICP, this article has
            inspired me to do so. Thank you ;). One thing, I know it is
            easy to use Dr. Racket for SICP, but can anyone point me in
            the direction of a guide for using Emacs?

            -   http://limist.com/ Kai

                Do you mean a general guide to using Emacs? Try
                searching for “emacs for beginners” If you meant to ask
                about MIT-Scheme and Emacs, see
                [http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/GNU-Emacs-Interface.html\#GNU-Emacs-Interface](http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/GNU-Emacs-Interface.html#GNU-Emacs-Interface)

    -   http://puntoblogspot.blogspot.com Raimon Grau

        Comparing MIT Scheme to SBCL or Emacs lisp is apples to oranges,
        as CL and elisp are lisp-2 (opposed to scheme, lisp-1).

        Most schemes (GNU Guile, chicken…) should work fine.

        From the preface to second edition:

        “we have rewritten all the program examples to ensure that any
        Scheme implementation conforming to the IEEE Scheme standard
        (IEEE 1990)”

        -   http://limist.com/ Kai

            Of course, one can attempt to do SICP exercises with any
            Lisp dialect. The problem is that you’ll run into slight or
            significant differences sooner or later, e.g. w/ Racket and
            the SICP package, by Chapter 2.4 there are issues with put
            and get, and no straightforward solutions. For people who
            want to focus on SICP instead of tinkering with dialect
            differences, just use MIT-Scheme.

-   Ted Fujimoto

    Thanks for this motivating article. I just wish a Scala version
    existed. Martin Odersky loves SICP and even uses some of its
    problems to teach his Scala MOOC.

-   Derp McHaxk

    This is the greatest idea ever. By comparison all the ‘codeschools’
    in my community are the blandest of corporatist node.js and
    unimaginative java CRUD factories whereas this is like the temple of
    Lisp ninjas. The price is right too, considering $7,500 is the min
    price for any so-called bootcamp or codeschool for ruby/node.js
    here. They don’t even last a month either.

    -   http://limist.com/ Kai

        Hey, thanks for the kind words. Well we can’t claim the title of
        “ninjas” but we do have a preference for functional programming
        here at Hacker Retreat. Consider joining us in Berlin this
        summer to throw shurikens of parentheses at your projects!

Search for:

#### Recent Posts

-   [Why We Made a European Alternative to Hacker
    School](http://hackerretreat.com/europe-alternative-hacker-school/)
-   [R: The Good Parts](http://hackerretreat.com/r-good-parts/)
-   [Why and How to Start Your SICP
    Trek](http://hackerretreat.com/why-how-start-sicp/)
-   [Do soft-skills matter to coders? Will being at Hacker Retreat help
    build them? Heck
    yeah!](http://hackerretreat.com/soft-skills-matter-coders-will-hacker-retreat-help-build-heck-yeah/)
-   [Batch-01 wrap-up, what will be different in
    2014](http://hackerretreat.com/batch-01-wrap-what-different-2014/)

#### Recent Comments

-   [Kai](http://limist.com/) on [Why and How to Start Your SICP
    Trek](http://hackerretreat.com/why-how-start-sicp/#comment-36)
-   [Kai](http://limist.com/) on [Why and How to Start Your SICP
    Trek](http://hackerretreat.com/why-how-start-sicp/#comment-34)
-   [Damian Esteban](http://www.estebanrules.com) on [Why and How to
    Start Your SICP
    Trek](http://hackerretreat.com/why-how-start-sicp/#comment-32)
-   [A few R things | Sam
    Clifford](http://samclifford.info/2014/04/10/a-few-r-things/) on [R:
    The Good Parts](http://hackerretreat.com/r-good-parts/#comment-31)
-   Derp McHaxk on [Why and How to Start Your SICP
    Trek](http://hackerretreat.com/why-how-start-sicp/#comment-30)

#### Archives

-   [April 2014](http://hackerretreat.com/2014/04/)
-   [February 2014](http://hackerretreat.com/2014/02/)
-   [December 2013](http://hackerretreat.com/2013/12/)
-   [November 2013](http://hackerretreat.com/2013/11/)
-   [October 2013](http://hackerretreat.com/2013/10/)
-   [September 2013](http://hackerretreat.com/2013/09/)
-   [August 2013](http://hackerretreat.com/2013/08/)
-   [July 2013](http://hackerretreat.com/2013/07/)

#### Categories

-   [Blog](http://hackerretreat.com/category/blog/ "View all posts filed under Blog")
-   [State-of-the-Stack](http://hackerretreat.com/category/state-of-the-stack/ "View all posts filed under State-of-the-Stack")
-   [Uncategorized](http://hackerretreat.com/category/uncategorized/ "View all posts filed under Uncategorized")

Interested in becoming better with data with a more structured
curriculum and Chief-Data-Scientist mentors?

[Try our sister program, Data Science
Retreat!](http://http://datascienceretreat.com/)

Want to stay in touch? You'll be the first to hear of new content and
the next HRet Batch.

-   [About](http://hackerretreat.com/about/)
-   [Contact](http://hackerretreat.com/contact/)
-   [Imprint](http://hackerretreat.com/imprint/)
-   [Blog](http://hackerretreat.com/blog/)
-   [FAQs](http://hackerretreat.com/faqs/)
-   [Mentors](http://hackerretreat.com/mentors/)

© 2014 Hacker Retreat. [Terms of Use](/#/) | [Policy](/#/) | [Be a
Sponsor](/sponsors/)

-   [Facebook](https://facebook.com/hackerretreat)
-   [@hackerRetreat](https://twitter.com/hackerRetreat)


This markdown document has been converted from the html document located at:
http://hackerretreat.com/why-how-start-sicp/
