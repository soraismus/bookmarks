A blog about software engineering, fitness, travel, and everything else
I think about.

Wednesday, April 9, 2014
------------------------

### Six programming paradigms that will change how you think about coding

Every now and then, I stumble across a programming language that does
something so different that it changes how I think about coding. In this
post, I want to share some of my favorite finds.\
 \
 This is not your grandma's "functional programming will change the
world!" blog post: this list is much more esoteric. I'd wager most
readers haven't heard of the majority of the languages and paradigms
below, so I hope you have as much fun learning about these new concepts
as I did. \
 \
 Note: I have only minimal experience with most of the languages below:
I find the ideas behind them fascinating, but claim no expertise in
them, so please point out any corrections and errors. Also, if you've
found any new paradigms and ideas not covered here, please share them!\
 \
 *Update: this post hit the front page of
[r/programming](http://www.reddit.com/r/programming/comments/22nhb2/six_programming_paradigms_that_will_change_how/)
and [HN](https://news.ycombinator.com/item?id=7565153). Thank you for
the great feedback! I've added some corrections below.*\
 \
 **Concurrent by default**\
 \

[![image](http://3.bp.blogspot.com/-63sh4SYTtDI/U0UJ7KZif5I/AAAAAAAAQZo/0i6pGxL0X7w/s1600/velociraptor3.jpg)](https://code.google.com/p/anic/)

Example languages: [ANI](https://code.google.com/p/anic/),
[Plaid](http://www.cs.cmu.edu/~aldrich/plaid/)\
 \
 Let's kick things off with a real mind bender: there are programming
languages out there that are concurrent by default. That is, every line
of code is executed in parallel!\
 \
 For example, imagine you wrote three lines of code, A, B, and C:\
 \

In most programming languages, A would execute first, then B, and then
C. In a language like [ANI](https://code.google.com/p/anic/), A, B, and
C would all execute at the same time!\
 \
 Control flow or ordering between lines of code in
[ANI](https://code.google.com/p/anic/) is merely a side effect of
explicit dependencies between lines of code. For example, if B had a
reference to a variable defined in A, then A and C would execute at the
same time, and B would execute only after A finished.\
 \
 Let's look at an example in ANI. As described in the
[tutorial](https://code.google.com/p/anic/wiki/Tutorial), ANI programs
consists of "pipes" and "latches" that are used to manipulate streams
and data flows. The unusual syntax is tough to parse, and the language
seems dead, but the concepts are pretty interesting.\
 \
 Here's a "Hello World" example in ANI:\
 \

In ANI terminology, we are sending the `"Hello, World!"` object (a
string) to the `std.out` stream. What happens if we send another string
to `std.out`?\
 \

Both of these lines of code execute in parallel, so they could end up in
any order in the console. Now, look what happens when we introduce a
variable on one line and reference it later:\
 \

The first line declares a "latch" (latches are a bit like variables)
called `s` that contains a string; the second line sends the text
`"Hello, World!"` to `s`; the third line "unlatches" `s` and sends the
contents to `std.out`. Here, you can see ANI's implicit program
sequencing: since each line depends on the previous one, this code will
execute in the order it is written.\
 \
 The [Plaid language](http://www.cs.cmu.edu/~aldrich/plaid/) also claims
to support concurrency by default, but uses a permissions model, as
described in [this
paper](http://www.cs.cmu.edu/~aldrich/papers/onward2009-concurrency.pdf),
to setup control flow. Plaid also explores other interesting concepts,
such as [Typestate-Oriented
Programming](http://www.cs.cmu.edu/~aldrich/papers/onward2009-state.pdf),
where state changes become a first class citizen of the language: you
define objects not as classes, but as a series of states and transitions
that can be checked by the compiler. This seems like an interesting take
on exposing *time* as a first class language construct as discussed in
Rich Hickey's [Are we there
yet](http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey)
talk.\
 \
 Multicore is on the rise and concurrency is still harder than it should
be in most languages. ANI and Plaid offer a fresh a fresh take on this
problem that could lead to amazing performance gains; the question is
whether "parallel by default" makes concurrency easier or harder to
manage.\
 \
 *Update: the description above captures the basic essence of ANI and
Plaid, but I used the terms "concurrent" and "parallel" interchangeably,
even though they have different meanings. See [Concurrency Is Not
Parallelism](http://vimeo.com/49718712) for more info.*\
 \
 **Dependent types**\
 \

[![image](http://3.bp.blogspot.com/-vw6KjsdBowY/U0WPdWRwK6I/AAAAAAAAQaQ/JIDP1nYlAhE/s1600/Screen+Shot+2014-04-09+at+11.20.08+AM.png)](http://www.idris-lang.org/)

\
 Example languages: [Idris](http://www.idris-lang.org/),
[Agda](http://wiki.portal.chalmers.se/agda/pmwiki.php),
[Coq](http://en.wikipedia.org/wiki/Coq)\
 \
 You're probably used to type systems in languages like C and Java,
where the compiler can check that a variable is an integer, list, or
string. But what if your compiler could check that a variable is "a
positive integer", "a list of length 2", or "a string that is a
palindrome"?\
 \
 This is the idea behind languages that support [dependent
types](http://en.wikipedia.org/wiki/Dependent_type): you can specify
*types* that can check the *value* of your variables at *compile time*.
The [shapeless library](https://github.com/milessabin/shapeless) for
Scala adds partial, experimental support (read: probably not ready for
primetime) for dependent types to Scala and offers an easy way to see
some examples.\
 \
 Here is how you can declare a `Vector` that contains the values 1, 2, 3
with the shapeless library:\
 \

This creates a variable `l1` who's type signature specifies not only
that it's a `Vector` that contains `Ints`, but also that it is a
`Vector` of length 3. The compiler can use this information to catch
errors. Let's use the `vAdd` method in Vector to perform a pairwise
addition between two `Vectors`:\
 \

The example above works fine because the type system knows both
`Vectors` have length 3. However, if we tried to `vAdd` two `Vectors` of
different lengths, we'd get an error at *compile time*instead of having
to wait until run time!\
 \

Shapeless is an amazing library, but from what I've seen, it's still a
bit rough, only supports a subset of dependent typing, and leads to
fairly verbose code and type signatures.
[Idris](http://www.idris-lang.org/), on the other hand, makes types a
first class member of the programming language, so the dependent type
system seems much more powerful and clean. For a comparison, check out
the [Scala vs Idris: Dependent Types, Now and in the
Future](http://www.infoq.com/presentations/scala-idris) talk:\
 \

\
 [Formal verification
methods](http://en.wikipedia.org/wiki/Formal_verification) have been
around for a long type, but were often too cumbersome to be usable for
general purpose programming. Dependent types in languages like Idris,
and perhaps even Scala in the future, may offer lighter-weight and more
practical alternatives that still dramatically increase the power of the
type system in catching errors. Of course, no dependent type system can
catch all errors due to to ineherent limitations from the halting
problem, but if done well, dependent types may be the next big leap for
static type systems.\
 \
 **Concatenative languages**\
 \

  --------------------------------------------------------------------------------------------------------------------------------------------------------
  [![image](http://2.bp.blogspot.com/-vOK1K5dOnXo/U0ULlE9918I/AAAAAAAAQZ0/HB3uefoHgn4/s1600/cat-logo-160-b.jpg)](http://www.cat-language.com/index.html)
  [cat](http://www.cat-language.com/index.html)
  --------------------------------------------------------------------------------------------------------------------------------------------------------

Example languages: [Forth](http://www.forth.com/forth/),
[cat](http://www.cat-language.com/),
[joy](http://c2.com/cgi/wiki?JoyLanguage)\
 \
 Ever wonder what it would be like to program without variables and
function application? No? Me neither. But apparently some folks did, and
they came up with [concatenative
programming](http://en.wikipedia.org/wiki/Concatenative_programming_language).
The idea is that everything in the language is a function that pushes
data onto a stack or pops data off the stack; programs are built up
almost exclusively through functional composition ([concatenation is
composition](http://concatenative.org/wiki/view/Concatenative%20language/Concatenation%20is%20composition)).\
 \
 This sounds pretty abstract, so let's look at a simple example in
[cat](http://www.cat-language.com/):\
 \

Here, we push two numbers onto the stack and then call the `+` function,
which pops both numbers off the stack and pushes the result of adding
them back onto the stack: the output of the code is 5. Here's a slightly
more interesting example:\
 \

Let's walk through this line by line:\

1.  First, we declare a function `foo`. Note that functions in cat
    specify no input parameters: all parameters are implicitly read from
    the stack.
2.  `foo` calls the `<` function, which pops the first item on the
    stack, compares it to 10, and pushes either `True` or `False` back
    onto the stack.
3.  Next, we push the values 0 and 42 onto the stack: we wrap them in
    brackets to ensure they get pushed onto the stack unevaluated. This
    is because they will be used as the "then" and "else" branches
    (respectively) for the call to the `if` function on the next line.
4.  The `if` function pops 3 items off the stack: the boolean condition,
    the "then" branch, and the "else" branch. Depending on the value of
    the boolean condition, it'll push the result of either the "then" or
    "else" branch back onto the stack.
5.  Finally, we push 20 onto the stack and call the `foo` function.
6.  When all is said and done, we'll end up with the number 42.

For a much more detailed introduction, check out [The Joy of
Concatenative
Languages](http://www.codecommit.com/blog/cat/the-joy-of-concatenative-languages-part-1).\
 \
 This style of programming has some interesting properties: programs can
be split and concatenated in countless ways to create new programs;
remarkably minimal syntax (even more minimal than LISP) that leads to
very concise programs; strong meta programming support. I found
concatenative programming to be an eye opening thought experiment, but
I'm not sold on its practicality. It seems like you have to remember or
imagine the current state of the stack instead of being able to read it
from the variable names in the code, which can make it hard to reason
about the code.\
 \
 **Declarative programming**\
 \

  ----------------------------------------------------------------------------------------------------------------------------------
  [![image](http://1.bp.blogspot.com/-BIfsqWUieXU/U0UM1e6y_wI/AAAAAAAAQaA/xwDOWGCm3xA/s1600/gprolog.png)](http://www.gprolog.org/)
  [GNU Prolog](http://www.gprolog.org/)
  ----------------------------------------------------------------------------------------------------------------------------------

Example languages: [Prolog](http://en.wikipedia.org/wiki/Prolog),
[SQL](http://en.wikipedia.org/wiki/SQL)\
 \
 [Declarative
programming](http://en.wikipedia.org/wiki/Declarative_programming) has
been around for many years, but most programmers are still unaware of it
as a concept. Here's the gist: in most mainstream languages, you
describe *how* to solve a particular problem; in declarative languages,
you merely describe *the result you want*, and the language itself
figures out how to get there.\
 \
 For example, if you're writing a sorting algorithm from scratch in C,
you might write the instructions for merge sort, which describes, step
by step, how to recursively split the data set in half and merge it back
together in sorted order: [here's an
example](http://www.cs.cityu.edu.hk/~lwang/ccs4335/mergesort.c). If you
were sorting numbers in a declarative language like
[Prolog](http://en.wikipedia.org/wiki/Prolog), you'd instead describe
the output you want: "I want the same list of values, but each item at
index `i` should be less than or equal to the item at index `i + 1`".
Compare the previous C solution to this Prolog code:\
 \

If you've used SQL, you've done a form of declarative programming and
may not have realized it: when you issue a query like
`select X from Y where Z`, you are describing the data set you'd like to
get back; it's the database engine that actually figures out *how* to
execute the query. You can use the explain command in most databases to
see the execution plan and figure out what happened under the hood.\
 \
 The beauty of declarative languages is that they allow you to work at a
much higher level of abstraction: your job is just to describe the
specification for the output you want. For example, the code for a
simple [sudoku solver in
prolog](http://brikis98.blogspot.com/2012/02/seven-languages-in-seven-weeks-prolog_16.html)
just lists out what each row, column, and diagonal of a solved sudoku
puzzle should look like:\
 \

Here is how you would run the sudoku solver above: \
 \

The downside, unfortunately, is that declarative programming languages
can easily hit performance bottlenecks. The naive sorting algorithm
above is likely `O(n!)`; the sudoku solver above does a brute force
search; and most developers have had to provide database hints and extra
indices to avoid expensive and inefficient plans when executing SQL
queries.\
 \
 **Symbolic programming**\
 \

[![image](http://1.bp.blogspot.com/-Lmff2HxggFc/U0WUfI_8MfI/AAAAAAAAQak/1x3J-7nlO-Y/s1600/principle4.png)](http://1.bp.blogspot.com/-Lmff2HxggFc/U0WUfI_8MfI/AAAAAAAAQak/1x3J-7nlO-Y/s1600/principle4.png)

\
 Example languages:
[Aurora](https://www.youtube.com/watch?v=L6iUm_Cqx2s)\
 \
 The [Aurora](https://www.youtube.com/watch?v=L6iUm_Cqx2s) language is
an example of [symbolic
programming](http://en.wikipedia.org/wiki/Symbolic_programming): the
"code" you write in these languages can include not only plain text, but
also images, math equations, graphs, charts, and more. This allows you
to manipulate and describe a large variety of data in the format native
to that data, instead of describing it all in text. Aurora is also
completely interactive, showing you the results from each line of code
instantly, like a REPL on steroids.\
 \

\
 The Aurora language was created by [Chris
Granger](http://www.chris-granger.com/), who also built the [Light Table
IDE](http://www.lighttable.com/). Chris outlines the motivation for
Aurora in his post [Toward a better
programming](http://www.chris-granger.com/2014/03/27/toward-a-better-programming/):
some of the goals are to make programming more observable, direct, and
reduce incidental complexity. For more info, be sure to see [Bret
Victor's](http://worrydream.com/) incredible talks: [Inventing on
Principle](http://vimeo.com/36579366), [Media for Thinking the
Unthinkable](http://vimeo.com/67076984), and [Learnable
Programming](http://worrydream.com/#!/LearnableProgramming).\
 \
 *Update: "symbolic programming" is probably not the right term to use
for Aurora. See the [Symbolic
programming](http://en.wikipedia.org/wiki/Symbolic_programming) wiki for
more info.*\
 \
 **Knowledge-based programming**\
 \

[![image](http://2.bp.blogspot.com/-PbI98Taz9qI/U0WT8yNn3eI/AAAAAAAAQac/nBhPd6fCfug/s1600/Screen+Shot+2014-04-09+at+11.39.24+AM.png)](https://www.wolfram.com/language/)

\
 Examples: [Wolfram Language](https://www.wolfram.com/language/)\
 \
 Much like the Aurora language mentioned above, The [Wolfram
Language](https://www.wolfram.com/language/) is also based on symbolic
programming. However, the symbolic layer is merely a way to provide a
consistent interface to the core of the Wolfram Language, which is
knowledge-based programming: built into the language is a *vast* array
of libraries, algorithms, and data. This makes it easy to do everything
from graphing your Facebook connections, to manipulating images, to
looking up the weather, processing natural language queries, plotting
directions on a map, solving mathematical equations, and much more.\
 \

\
 I suspect the Wolfram Languages has the largest "standard library" and
data set of any language in existence. I'm also excited by the idea that
Internet connectivity is an inherent part of *writing* the code: it's
almost like an IDE where the auto-complete function does a google
search. It'll be very interesting to see if the symbolic programming
model is as flexible as Wolfram claims and can truly take advantage of
all of this data.\

\
 *Update: although Wolfram claims the Wolfram Language supports
"symbolic programming" and "knowledge programming", these terms have
slightly different definitions. See the [Knowledge
level](http://en.wikipedia.org/wiki/Knowledge_level) and [Symbolic
Programming](http://en.wikipedia.org/wiki/Symbolic_programming) wikis
for more info.*\

*\
*

\
 \
 \
 \
 \

\
 \

Posted by [Yevgeniy
Brikman](https://plus.google.com/105725955499217588296 "author profile")
at [11:58
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html "permanent link")
[![image](http://img2.blogblog.com/img/icon18_edit_allbkg.gif)](http://www.blogger.com/post-edit.g?blogID=5422014336627804072&postID=2823320023562008049&from=pencil "Edit Post")

[Email
This](http://www.blogger.com/share-post.g?blogID=5422014336627804072&postID=2823320023562008049&target=email "Email This")[BlogThis!](http://www.blogger.com/share-post.g?blogID=5422014336627804072&postID=2823320023562008049&target=blog "BlogThis!")[Share
to
Twitter](http://www.blogger.com/share-post.g?blogID=5422014336627804072&postID=2823320023562008049&target=twitter "Share to Twitter")[Share
to
Facebook](http://www.blogger.com/share-post.g?blogID=5422014336627804072&postID=2823320023562008049&target=facebook "Share to Facebook")[Share
to
Pinterest](http://www.blogger.com/share-post.g?blogID=5422014336627804072&postID=2823320023562008049&target=pinterest "Share to Pinterest")

Labels: [Software
Engineering](http://brikis98.blogspot.com/search/label/Software%20Engineering)

#### 20 comments:

[![image](http://img1.blogblog.com/img/blank.gif "Nathan Wailes")](http://www.blogger.com/profile/09125198584226750569)

![image](http://4.bp.blogspot.com/-Nhba411D6Qo/TzLHRCD79aI/AAAAAAAAAEA/hWNMOhSrb5U/s45/2.jpg)

[Nathan Wailes](http://www.blogger.com/profile/09125198584226750569)
said...

Great write-up!

[April 9, 2014 at 10:00
PM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397106012074#c8241300586028599540 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=8241300586028599540 "Delete Comment")

[![image](http://img1.blogblog.com/img/blank.gif "doug")](http://www.blogger.com/profile/16041019983406055716)

![image](http://2.bp.blogspot.com/_fxdjCy6SjOI/TEei1OUwdEI/AAAAAAAAALc/gKnRL3DyZuI/S45/avatar_pic.png)

[doug](http://www.blogger.com/profile/16041019983406055716) said...

loved this. the python library sympy i suppose, is a limited example
under the symbolic rubric

[April 10, 2014 at 12:53
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397116380451#c4143328144683812599 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=4143328144683812599 "Delete Comment")

[![image](http://img2.blogblog.com/img/b16-rounded.gif "Asim")](http://www.blogger.com/profile/14141500729962703817)

[Asim](http://www.blogger.com/profile/14141500729962703817) said...

Good essay. Another language that is parallel by default like ANI in
some ways is Pig, which runs on top of Hadoop.

[April 10, 2014 at 4:10
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397128216077#c8279186870547921540 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=8279186870547921540 "Delete Comment")

[![image](http://img1.blogblog.com/img/blank.gif "anta40")](http://www.blogger.com/profile/01204788501454180498)

![image](http://3.bp.blogspot.com/-uipMQJozvjw/UJAYe2ERcWI/AAAAAAAACsI/Tb9yO59N4os/s220/i07e7gz5yh3g80yoenk7.png)

[anta40](http://www.blogger.com/profile/01204788501454180498) said...

I had some experiences with declarative programming in the university:
logic programming (Prolog), and functional programming (Haskell). Even
though I don't write applications in those language nowadays, indeed
they pretty much influence me how I like to think to solve problems :D

[April 10, 2014 at 4:41
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397130103791#c724075197304757228 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=724075197304757228 "Delete Comment")

[![image](http://img2.blogblog.com/img/b16-rounded.gif "Unknown")](http://www.blogger.com/profile/02568572425679389093)

[Unknown](http://www.blogger.com/profile/02568572425679389093) said...

Another concatenative (or stack based) language is PostScript which
might be powering a printer close to you.

[April 10, 2014 at 4:42
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397130140894#c3379434821490699619 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=3379434821490699619 "Delete Comment")

[![image](http://img1.blogblog.com/img/blank.gif "Samuel Bosch")](http://www.blogger.com/profile/00902576471871535529)

![image](//lh3.googleusercontent.com/--D6YquRdq8c/AAAAAAAAAAI/AAAAAAAAB6I/CE58vu9QAvA/s512-c/photo.jpg)

[Samuel Bosch](http://www.blogger.com/profile/00902576471871535529)
said...

And yet another concatenative language is
[Factor](http://factorcode.org/)

[April 10, 2014 at 4:44
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397130275083#c7938245108248282658 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=7938245108248282658 "Delete Comment")

[![image](http://img2.blogblog.com/img/b16-rounded.gif "Praveen C")](http://www.blogger.com/profile/08945648753267492524)

[Praveen C](http://www.blogger.com/profile/08945648753267492524) said...

Perl's Moose supports Dependent Types.

[April 10, 2014 at 5:02
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397131357182#c8363836409025842259 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=8363836409025842259 "Delete Comment")

[![image](http://img1.blogblog.com/img/blank.gif "Uncompetative")](http://www.blogger.com/profile/11740139097865154127)

![image](http://1.bp.blogspot.com/_97a-nJha7Io/TPkgFKUpCiI/AAAAAAAAAAk/Er167R3n-Uk/S45/Uncompetative.png)

[Uncompetative](http://www.blogger.com/profile/11740139097865154127)
said...

No mention of Actors, you might want to add Erlang which supports fault
tolerant distributed concurrency and modules that can be "hot-swapped"
at runtime, it was used to write the server for Black Ops - slides:\
\
http://www.erlang-factory.com/upload/presentations/395/ErlangandFirst-PersonShooters.pdf

[April 10, 2014 at 5:25
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397132748455#c4970966342375406806 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=4970966342375406806 "Delete Comment")

[![image](http://img2.blogblog.com/img/b16-rounded.gif "Chaosape")](http://www.blogger.com/profile/06426522598029410386)

[Chaosape](http://www.blogger.com/profile/06426522598029410386) said...

I would highly recommend looking at lambda prolog. Lambda prolog permits
simply typed lambda terms. This permits a natural encoding of binding
notions. Additionally, it permits a subset of high-order
unification(i.e., logic variables can represent predicates). A powerful
aspect of lambda prolog is that it based on hereditary Harrop formulas
instead of Horn clauses. HH formulas, permit implication and universal
quantifiers in goals. Intuitively, this allows programs to be extended
and new, fresh, variables to be introduced, respectively. More
information can be found here:
http://www.lix.polytechnique.fr/\~dale/lProlog/

[April 10, 2014 at 7:20
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397139600551#c8735615438676207654 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=8735615438676207654 "Delete Comment")

[![image](http://img1.blogblog.com/img/blank.gif "John Seals")](http://www.blogger.com/profile/06680417362968198878)

![image](http://3.bp.blogspot.com/-EuXiQ-3gPPg/USfSzrB7E2I/AAAAAAAAB6k/LguL2zb6zo0/s45/HelmetPicture.jpg)

[John Seals](http://www.blogger.com/profile/06680417362968198878)
said...

Great article!

[April 10, 2014 at 7:49
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397141379661#c6495050252522743092 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=6495050252522743092 "Delete Comment")

[![image](http://img1.blogblog.com/img/blank.gif "Paul W")](http://www.blogger.com/profile/10428294776231452258)

![image](//lh5.googleusercontent.com/-epbw0cgRAcE/AAAAAAAAAAI/AAAAAAAAB-I/MyFIq4KGEYk/s512-c/photo.jpg)

[Paul W](http://www.blogger.com/profile/10428294776231452258) said...

As Samual Bosch said, Factor is a concatenative language, whose stack
effect checker alleviates the problem you mention, of having to keep the
state of the stack in your head. Stack effects look a little bit like
function signatures, and the factor compiler will verify that the
various 'words' in your program have the effect on the stack that their
signature says they do.

[April 10, 2014 at 7:51
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397141489140#c5335457445285163826 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=5335457445285163826 "Delete Comment")

[![image](http://img2.blogblog.com/img/b16-rounded.gif "Warbo")](http://www.blogger.com/profile/11167936627543971536)

[Warbo](http://www.blogger.com/profile/11167936627543971536) said...

I found the description of the concatenative code a bit all over the
place. Two specific issues: you say "concatenation is composition", but
don't show any concatenation. Maybe a better phrase would be
"juxtaposition is concatenation" or even "whitespace is concatenation".
Also, you keep saying that we "call" functions, which is misleading (it
makes the control flow sound very complicated: "why do functions get
called but numbers get pushed?"). In fact concatenative languages are
very uniform: everything is a function from stacks to stacks.\
\
A more uniform description might be something like this:\
\
1. First we declare a variable "foo". This will be a function, which we
will define as the composition of existing functions. This may be
familiar from functional programming, eg. the "." function in Haskell,
but in Cat we can compose by just using whitespace.\
2. The first component of "foo" will be "10", which is a function that
takes a stack and returns a new stack with the number 10 pushed on top.
We compose this with the "<" function, which pops two numbers off a
stack and pushes the boolean result (True or False) of comparing them.\
3. We compose this with two 'anonymous functions', denoted by the
brackets "[...]". These functions push their bodies, unevaluated, on to
a stack. Those bodies just consist of the "0" and "42" functions, which
(when evaluated) will push the numbers 0 and 42 on to a stack
respectively.\
4. We compose this with the "if" function, which pops two functions and
a boolean off the stack and applies one of those functions (depending on
the boolean) to the resulting stack. The functions act as the "then" and
"else" branches of the "if".\
5. We've now finished defining "foo", so we start defining our 'main'
(top-level) function. This consists of the "20" function, which will
push the number 20 on to a stack, composed with the "foo" function we
just defined.\
6. When we run this program, the top-level function is applied to an
empty stack. The result will be a stack containing the number 42.

[April 10, 2014 at 8:01
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397142102909#c7959709204895374317 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=7959709204895374317 "Delete Comment")

[![image](http://img2.blogblog.com/img/b16-rounded.gif "Warbo")](http://www.blogger.com/profile/11167936627543971536)

[Warbo](http://www.blogger.com/profile/11167936627543971536) said...

Another paradigm that's interesting is term-rewriting systems. Examples
are Pure and Maude.\
\
In these systems we define a bunch of rewrite rules (a -\> b) and/or
equations (c = d, equivalent to c -\> d and d -\> c). The system
executes a program by trying to match the input against any of the
rewrite rules. If a match is found, the rewrite is applied and the
system starts looking for another match. For example, here's the
declaration of a couple of Maude operators (ops):\
\
--- Declare some variables to use in our patterns\
vars A B : Nat .\
\
--- Clears B of the least-significant-bits in A\
op \_above\_ : Nat Nat -\> Nat .\
eq (A) above (B) = (A \>\> B) << B .\
\
--- Clears all but the B least-significant-bits of A\
op \_below\_ : Nat Nat -\> Nat .\
eq A below 0 = 0 .\
eq A below B = A rem (1 << B) .

[April 10, 2014 at 8:14
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397142853728#c1644169892986803863 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=1644169892986803863 "Delete Comment")

[![image](http://img2.blogblog.com/img/b16-rounded.gif "Robby")](http://www.blogger.com/profile/09240746346607446981)

[Robby](http://www.blogger.com/profile/09240746346607446981) said...

You might enjoy Icon, noted for its string scanning and goal-directed
evaluation: http://www.cs.arizona.edu/icon/

[April 10, 2014 at 8:14
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397142888580#c8062820382284700652 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=8062820382284700652 "Delete Comment")

[![image](http://img2.blogblog.com/img/b16-rounded.gif "bp")](http://www.blogger.com/profile/17621724422209284250)

[bp](http://www.blogger.com/profile/17621724422209284250) said...

You might enjoy looking at LabVIEW. It is dataflow-based, concurrent by
default, almost fully concatenative , graphical - and most importantly,
it is huge. Used in production. Not some obscure thing, but really big
in science.\
\
And if you master these concepts (which most LabVIEW programmers don't -
you can usually see when they are trying to write Java or C), your way
of programming will be forever changed.

[April 10, 2014 at 8:43
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397144621748#c4582338433039362075 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=4582338433039362075 "Delete Comment")

[![image](http://img2.blogblog.com/img/b16-rounded.gif "Mike Hunt")](http://www.blogger.com/profile/11111973147129155591)

[Mike Hunt](http://www.blogger.com/profile/11111973147129155591) said...

Wolfram reminds of REBOL.

[April 10, 2014 at 9:16
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397146576755#c1970015290707922608 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=1970015290707922608 "Delete Comment")

[![image](http://img1.blogblog.com/img/blank.gif "Zack Morris")](http://www.blogger.com/profile/06653185906461299142)

![image](//lh4.googleusercontent.com/-GEZxLJNdPKs/AAAAAAAAAAI/AAAAAAAAAEA/GFjvHGPyG7s/s512-c/photo.jpg)

[Zack Morris](http://www.blogger.com/profile/06653185906461299142)
said...

Fantastic article, thank you. I had never made the connection between
Prolog and O(n!) solving time. But I stumbled onto the issue when I was
writing a program that when given an isometric view of blocks on a table
(represented as a graph of the vertices), would solve how imaginary
blocks were stacked to result in the same image. The naive method is to
try every permutation (which is n!) but I ended up speeding it up using
a hill climbing algorithm that tried swapping two branches of the tree
and keeping the answer with least error. Worst case was still n! I
believe, but in practice it found the solution in under a second. My
dream would be a language like Prolog that can evolve solutions under
the hood with a time less than n! perhaps by referencing previous
solutions from the web. Also, n! sounds bad until we consider
multiprocessing and quantum computing which could try many possibilities
simultaneously.

[April 10, 2014 at 9:58
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397149110929#c5824821748898407672 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=5824821748898407672 "Delete Comment")

[![image](http://img2.blogblog.com/img/b16-rounded.gif "Ryan Mitchell")](http://www.blogger.com/profile/17110984920467038416)

[Ryan Mitchell](http://www.blogger.com/profile/17110984920467038416)
said...

On concurrent by default; Verilog or VHDL are analogous examples ...
coming from\
 a software background it's a very different paradigm -- hardware is
hardware and every circuit is always "executing".\

[April 10, 2014 at 1:54
PM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397163276953#c3763068757139250708 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=3763068757139250708 "Delete Comment")

[![image](http://img1.blogblog.com/img/blank.gif "Vasudev Ram")](http://www.blogger.com/profile/13568740634188042591)

![image](//lh6.googleusercontent.com/-BEfbKAw-m4k/AAAAAAAAAAI/AAAAAAAAAAA/t0c6ywdxf6M/s512-c/photo.jpg)

[Vasudev Ram](http://www.blogger.com/profile/13568740634188042591)
said...

Icon is another interesting language.\
\
http://en.wikipedia.org/wiki/Icon\_(programming\_language)\
\
https://www.cs.arizona.edu/icon/docs/ipd266.htm

[April 10, 2014 at 3:45
PM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397169930759#c1238663271634845639 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=1238663271634845639 "Delete Comment")

[![image](http://img1.blogblog.com/img/blank.gif "David Warman")](http://www.blogger.com/profile/09945188729754740647)

![image](//lh5.googleusercontent.com/-VVH53teG8Zk/AAAAAAAAAAI/AAAAAAAAAB8/Yh8tqmH3XKs/s512-c/photo.jpg)

[David Warman](http://www.blogger.com/profile/09945188729754740647)
said...

Interesting you think FORTH is a curiosity. It is actually pretty
pervasive, been in space many times (still is), PostScript (mentioned
above) is not only same family, it is actually derived from an early
state of FORTH. \
\
It has many interesting properties you missed, in particular that it is
a language in which you define your domain-specific language to solve
your problem. Every aspect of the base language is extensible, including
all math and syntax. And it is very small and very tight. \
\
I use it as a embedded debug scripting tool in pretty much everything I
wrote the past 15 years or so. Real Time embedded systems have few bugs
that can be found with breakpoint debuggers, one has to be able to
observe them \_behaving\_ for many of the issues that do not lead to
crashes. With FORTH I can interactively explore the workings with a
minimally intrusive and small footprint code prober.

[April 11, 2014 at 12:38
AM](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html?showComment=1397201895076#c4462379723197357823 "comment permalink")
[![image](//www.blogger.com/img/icon_delete13.gif)](http://www.blogger.com/delete-comment.g?blogID=5422014336627804072&postID=4462379723197357823 "Delete Comment")

[Post a
Comment](http://www.blogger.com/comment.g?blogID=5422014336627804072&postID=2823320023562008049)

[Older
Post](http://brikis98.blogspot.com/2014/04/so-long-and-thanks-for-all-t-shirts.html "Older Post")
[Home](http://brikis98.blogspot.com/)

Subscribe to: [Post Comments
(Atom)](http://brikis98.blogspot.com/feeds/2823320023562008049/comments/default)

About Me
--------

[![My
Photo](//lh5.googleusercontent.com/-vXwozIyq1Js/AAAAAAAAAAI/AAAAAAAALt4/KcdfGfdMeNI/s512-c/photo.jpg)](https://plus.google.com/105725955499217588296)

[Yevgeniy Brikman](https://plus.google.com/105725955499217588296) \

Software engineer, Crossfiter, traveler. Visit my [home
page](http://www.ybrikman.com/) for more info.\

[View my complete
profile](https://plus.google.com/105725955499217588296)

[![image](http://img1.blogblog.com/img/icon18_wrench_allbkg.png)](//www.blogger.com/rearrange?blogID=5422014336627804072&widgetType=Profile&widgetId=Profile1&action=editWidget&sectionId=sidebar-right-1 "Edit")

Twitter
-------

[Follow @brikis98](https://twitter.com/brikis98)

[![image](http://img1.blogblog.com/img/icon18_wrench_allbkg.png)](//www.blogger.com/rearrange?blogID=5422014336627804072&widgetType=HTML&widgetId=HTML1&action=editWidget&sectionId=sidebar-right-2-1 "Edit")

[![image](http://img1.blogblog.com/img/icon18_wrench_allbkg.png)](//www.blogger.com/rearrange?blogID=5422014336627804072&widgetType=AdSense&widgetId=AdSense1&action=editWidget&sectionId=sidebar-right-2-1 "Edit")

Blog Archive
------------

-   [▼](javascript:void(0))
    [2014](http://brikis98.blogspot.com/search?updated-min=2014-01-01T00:00:00-08:00&updated-max=2015-01-01T00:00:00-08:00&max-results=5)
    (5)
    -   [▼](javascript:void(0))
        [April](http://brikis98.blogspot.com/2014_04_01_archive.html)
        (2)
        -   [Six programming paradigms that will change how
            you...](http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html)
        -   [So long, and thanks for all the
            t-shirts](http://brikis98.blogspot.com/2014/04/so-long-and-thanks-for-all-t-shirts.html)

    -   [►](javascript:void(0))
        [March](http://brikis98.blogspot.com/2014_03_01_archive.html)
        (1)

    -   [►](javascript:void(0))
        [February](http://brikis98.blogspot.com/2014_02_01_archive.html)
        (1)

    -   [►](javascript:void(0))
        [January](http://brikis98.blogspot.com/2014_01_01_archive.html)
        (1)

-   [►](javascript:void(0))
    [2013](http://brikis98.blogspot.com/search?updated-min=2013-01-01T00:00:00-08:00&updated-max=2014-01-01T00:00:00-08:00&max-results=7)
    (7)
    -   [►](javascript:void(0))
        [November](http://brikis98.blogspot.com/2013_11_01_archive.html)
        (1)

    -   [►](javascript:void(0))
        [September](http://brikis98.blogspot.com/2013_09_01_archive.html)
        (1)

    -   [►](javascript:void(0))
        [May](http://brikis98.blogspot.com/2013_05_01_archive.html) (2)

    -   [►](javascript:void(0))
        [April](http://brikis98.blogspot.com/2013_04_01_archive.html)
        (1)

    -   [►](javascript:void(0))
        [March](http://brikis98.blogspot.com/2013_03_01_archive.html)
        (1)

    -   [►](javascript:void(0))
        [January](http://brikis98.blogspot.com/2013_01_01_archive.html)
        (1)

-   [►](javascript:void(0))
    [2012](http://brikis98.blogspot.com/search?updated-min=2012-01-01T00:00:00-08:00&updated-max=2013-01-01T00:00:00-08:00&max-results=16)
    (16)
    -   [►](javascript:void(0))
        [November](http://brikis98.blogspot.com/2012_11_01_archive.html)
        (2)

    -   [►](javascript:void(0))
        [April](http://brikis98.blogspot.com/2012_04_01_archive.html)
        (1)

    -   [►](javascript:void(0))
        [March](http://brikis98.blogspot.com/2012_03_01_archive.html)
        (2)

    -   [►](javascript:void(0))
        [February](http://brikis98.blogspot.com/2012_02_01_archive.html)
        (7)

    -   [►](javascript:void(0))
        [January](http://brikis98.blogspot.com/2012_01_01_archive.html)
        (4)

-   [►](javascript:void(0))
    [2011](http://brikis98.blogspot.com/search?updated-min=2011-01-01T00:00:00-08:00&updated-max=2012-01-01T00:00:00-08:00&max-results=39)
    (39)
    -   [►](javascript:void(0))
        [October](http://brikis98.blogspot.com/2011_10_01_archive.html)
        (1)

    -   [►](javascript:void(0))
        [August](http://brikis98.blogspot.com/2011_08_01_archive.html)
        (7)

    -   [►](javascript:void(0))
        [July](http://brikis98.blogspot.com/2011_07_01_archive.html)
        (23)

    -   [►](javascript:void(0))
        [April](http://brikis98.blogspot.com/2011_04_01_archive.html)
        (6)

    -   [►](javascript:void(0))
        [February](http://brikis98.blogspot.com/2011_02_01_archive.html)
        (1)

    -   [►](javascript:void(0))
        [January](http://brikis98.blogspot.com/2011_01_01_archive.html)
        (1)

-   [►](javascript:void(0))
    [2010](http://brikis98.blogspot.com/search?updated-min=2010-01-01T00:00:00-08:00&updated-max=2011-01-01T00:00:00-08:00&max-results=8)
    (8)
    -   [►](javascript:void(0))
        [December](http://brikis98.blogspot.com/2010_12_01_archive.html)
        (2)

    -   [►](javascript:void(0))
        [March](http://brikis98.blogspot.com/2010_03_01_archive.html)
        (2)

    -   [►](javascript:void(0))
        [February](http://brikis98.blogspot.com/2010_02_01_archive.html)
        (1)

    -   [►](javascript:void(0))
        [January](http://brikis98.blogspot.com/2010_01_01_archive.html)
        (3)

-   [►](javascript:void(0))
    [2009](http://brikis98.blogspot.com/search?updated-min=2009-01-01T00:00:00-08:00&updated-max=2010-01-01T00:00:00-08:00&max-results=2)
    (2)
    -   [►](javascript:void(0))
        [July](http://brikis98.blogspot.com/2009_07_01_archive.html) (1)

    -   [►](javascript:void(0))
        [April](http://brikis98.blogspot.com/2009_04_01_archive.html)
        (1)

-   [►](javascript:void(0))
    [2008](http://brikis98.blogspot.com/search?updated-min=2008-01-01T00:00:00-08:00&updated-max=2009-01-01T00:00:00-08:00&max-results=10)
    (10)
    -   [►](javascript:void(0))
        [December](http://brikis98.blogspot.com/2008_12_01_archive.html)
        (2)

    -   [►](javascript:void(0))
        [August](http://brikis98.blogspot.com/2008_08_01_archive.html)
        (2)

    -   [►](javascript:void(0))
        [June](http://brikis98.blogspot.com/2008_06_01_archive.html) (1)

    -   [►](javascript:void(0))
        [May](http://brikis98.blogspot.com/2008_05_01_archive.html) (3)

    -   [►](javascript:void(0))
        [January](http://brikis98.blogspot.com/2008_01_01_archive.html)
        (2)

-   [►](javascript:void(0))
    [2007](http://brikis98.blogspot.com/search?updated-min=2007-01-01T00:00:00-08:00&updated-max=2008-01-01T00:00:00-08:00&max-results=6)
    (6)
    -   [►](javascript:void(0))
        [December](http://brikis98.blogspot.com/2007_12_01_archive.html)
        (2)

    -   [►](javascript:void(0))
        [November](http://brikis98.blogspot.com/2007_11_01_archive.html)
        (3)

    -   [►](javascript:void(0))
        [October](http://brikis98.blogspot.com/2007_10_01_archive.html)
        (1)

[![image](http://img1.blogblog.com/img/icon18_wrench_allbkg.png)](//www.blogger.com/rearrange?blogID=5422014336627804072&widgetType=BlogArchive&widgetId=BlogArchive1&action=editWidget&sectionId=sidebar-right-2-1 "Edit")

Tags
----

-   [Crossfit](http://brikis98.blogspot.com/search/label/Crossfit) (12)
-   [Design](http://brikis98.blogspot.com/search/label/Design) (3)
-   [Family](http://brikis98.blogspot.com/search/label/Family) (1)
-   [Gadgets](http://brikis98.blogspot.com/search/label/Gadgets) (6)
-   [Goals](http://brikis98.blogspot.com/search/label/Goals) (4)
-   [Hackday](http://brikis98.blogspot.com/search/label/Hackday) (2)
-   [Health and
    Fitness](http://brikis98.blogspot.com/search/label/Health%20and%20Fitness)
    (17)
-   [Hiring](http://brikis98.blogspot.com/search/label/Hiring) (1)
-   [Home](http://brikis98.blogspot.com/search/label/Home) (3)
-   [HowTo](http://brikis98.blogspot.com/search/label/HowTo) (13)
-   [Humor](http://brikis98.blogspot.com/search/label/Humor) (4)
-   [Ideas](http://brikis98.blogspot.com/search/label/Ideas) (4)
-   [LinkedIn](http://brikis98.blogspot.com/search/label/LinkedIn) (9)
-   [Nutrition](http://brikis98.blogspot.com/search/label/Nutrition) (2)
-   [Open
    Source](http://brikis98.blogspot.com/search/label/Open%20Source) (2)
-   [Philosophy](http://brikis98.blogspot.com/search/label/Philosophy)
    (2)
-   [Psychology](http://brikis98.blogspot.com/search/label/Psychology)
    (5)
-   [Reading](http://brikis98.blogspot.com/search/label/Reading) (2)
-   [Review](http://brikis98.blogspot.com/search/label/Review) (6)
-   [Seven Languages in Seven
    Weeks](http://brikis98.blogspot.com/search/label/Seven%20Languages%20in%20Seven%20Weeks)
    (14)
-   [Software
    Engineering](http://brikis98.blogspot.com/search/label/Software%20Engineering)
    (32)
-   [Travel](http://brikis98.blogspot.com/search/label/Travel) (6)
-   [TV and
    Movies](http://brikis98.blogspot.com/search/label/TV%20and%20Movies)
    (1)
-   [Video](http://brikis98.blogspot.com/search/label/Video) (2)
-   [Web
    Development](http://brikis98.blogspot.com/search/label/Web%20Development)
    (6)
-   [Writing](http://brikis98.blogspot.com/search/label/Writing) (5)

[![image](http://img1.blogblog.com/img/icon18_wrench_allbkg.png)](//www.blogger.com/rearrange?blogID=5422014336627804072&widgetType=Label&widgetId=Label1&action=editWidget&sectionId=sidebar-right-3 "Edit")

Picture Window template. Powered by [Blogger](http://www.blogger.com).

[![image](http://img1.blogblog.com/img/icon18_wrench_allbkg.png)](//www.blogger.com/rearrange?blogID=5422014336627804072&widgetType=Attribution&widgetId=Attribution1&action=editWidget&sectionId=footer-3 "Edit")

This markdown document has been converted from the html document located at:
http://brikis98.blogspot.com/2014/04/six-programming-paradigms-that-will.html
