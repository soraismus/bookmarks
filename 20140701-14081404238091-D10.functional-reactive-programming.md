[](https://gist.github.com/)

[Sign up for a GitHub account](https://github.com/signup?return_to=gist)
[Sign
in](https://gist.github.com/login?return_to=%2Fstaltz%2F868e7e9bc2a7b8c1f754)

-   [All Gists](/discover)

public
======

![image](https://avatars0.githubusercontent.com/u/90512?s=140)
[staltz](/staltz) / **[introrx.md](/staltz/868e7e9bc2a7b8c1f754)**

Last active July 01, 2014

-   [Code
    ![image](https://gist-assets.github.com/assets/spinners/octocat-spinner-32-4ae22f00973f33151cb92eea73616c5c.gif)](/staltz/868e7e9bc2a7b8c1f754)
-   [Revisions
    ![image](https://gist-assets.github.com/assets/spinners/octocat-spinner-32-4ae22f00973f33151cb92eea73616c5c.gif)
    241](/staltz/868e7e9bc2a7b8c1f754/revisions)
-   [Stars
    ![image](https://gist-assets.github.com/assets/spinners/octocat-spinner-32-4ae22f00973f33151cb92eea73616c5c.gif)
    1,014](/staltz/868e7e9bc2a7b8c1f754/stars)
-   [Forks
    ![image](https://gist-assets.github.com/assets/spinners/octocat-spinner-32-4ae22f00973f33151cb92eea73616c5c.gif)
    78](/staltz/868e7e9bc2a7b8c1f754/forks)

### **Embed** URL

### **HTTPS** clone URL

### **SSH** clone URL

You can clone with [HTTPS](#) or [SSH](#).

[Download
Gist](/staltz/868e7e9bc2a7b8c1f754/download "Download introrx.md as a zip file")

The introduction to Reactive Programming you've been missing

[View **introrx.md**](/staltz/868e7e9bc2a7b8c1f754)

**** [**introrx.md**](#file-introrx-md)

[Raw](/staltz/868e7e9bc2a7b8c1f754/raw/d9e7f3b646fa8b52652731ad0137d50e9c39366a/introrx.md)

File suppressed. Click to show.

[](#the-introduction-to-reactive-programming-youve-been-missing)The introduction to Reactive Programming you've been missing
----------------------------------------------------------------------------------------------------------------------------

(by [@andrestaltz](https://twitter.com/andrestaltz))

So you're curious in learning this new thing called (Functional)
Reactive Programming (FRP).

Learning it is hard, even harder by the lack of good material. When I
started, I tried looking for tutorials. I found only a handful of
practical guides, but they just scratched the surface and never tackled
the challenge of building the whole architecture around it. Library
documentations often don't help when you're trying to understand some
function. I mean, honestly, look at this:

> **Rx.Observable.prototype.flatMapLatest(selector, [thisArg])**
>
> Projects each element of an observable sequence into a new sequence of
> observable sequences by incorporating the element's index and then
> transforms an observable sequence of observable sequences into an
> observable sequence producing values only from the most recent
> observable sequence.

Holy cow.

I've read two books, one just painted the big picture, while the other
dived into how to use the FRP library. I ended up learning Reactive
Programming the hard way: figuring it out while building with it. At my
work in [Futurice](https://www.futurice.com) I got to use it in a real
project, and had the [support of some
colleagues](http://blog.futurice.com/top-7-tips-for-rxjava-on-android)
when I ran into troubles.

The hardest part of the learning journey is **thinking in FRP**. It's a
lot about letting go of old imperative and stateful habits of typical
programming, and forcing your brain to work in a different paradigm. I
haven't found any guide on the internet in this aspect, and I think the
world deserves a practical tutorial on how to think in FRP, so that you
can get started. Library documentation can light your way after that. I
hope this helps you.

[](#what-is-functional-reactive-programming-frp)"What is Functional Reactive Programming (FRP)?"
------------------------------------------------------------------------------------------------

There are plenty of bad explanations and definitions out there on the
internet.
[Wikipedia](https://en.wikipedia.org/wiki/Functional_reactive_programming)
is too generic and theoretical as usual.
[Stackoverflow](http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming)'s
canonical answer is obviously not suitable for newcomers. [Reactive
Manifesto](http://www.reactivemanifesto.org/) sounds like the kind of
thing you show to your project manager or the businessmen at your
company. Microsoft's [Rx terminology](https://rx.codeplex.com/) "Rx =
Observables + LINQ + Schedulers" is so heavy and Microsoftish that most
of us are left confused. Terms like "reactive" and "propagation of
change" don't convey anything specifically different to what your
typical MV\* and favorite language already does. Of course my framework
views react to the models. Of course change is propagated. If it
wouldn't, nothing would be rendered.

So let's cut the bullshit.

#### [](#frp-is-programming-with-asynchronous-data-streams)FRP is programming with asynchronous data streams.

In a way, this isn't anything new. Event buses or your typical click
events are really an asynchronous event stream, on which you can observe
and do some side effects. FRP is that idea on steroids. You are able to
create data streams of anything, not just from click and hover events.
Streams are cheap and ubiquitous, anything can be a stream: variables,
user inputs, properties, caches, data structures, etc. For example,
imagine your Twitter feed would be a data stream in the same fashion
that click events are. You can listen to that stream and react
accordingly.

**On top of that, you are given an amazing toolbox of functions to
combine, create and filter any of those streams.** That's where the
"functional" magic kicks in. A stream can be used as an input to another
one. Even multiple streams can be used as inputs to another stream. You
can *merge* two streams. You can *filter* a stream to get another one
that has only those events you are interested in. You can *map* data
values from one stream to another new one.

If streams are so central to FRP, let's take a careful look at them,
starting with our familiar "clicks on a button" event stream.

[![Click event
stream](https://camo.githubusercontent.com/28787087e17e13046655c0f71d6e4080c3508b10/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f343964613639346232343839663965376237323736646633316131646362323036313739613439362f7a636c69636b73747265616d2e706e67)](https://camo.githubusercontent.com/28787087e17e13046655c0f71d6e4080c3508b10/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f343964613639346232343839663965376237323736646633316131646362323036313739613439362f7a636c69636b73747265616d2e706e67)

A stream is a sequence of **ongoing events ordered in time**. It can
emit three different things: a value (of some type), an error, or a
"completed" signal. Consider that the "completed" takes place, for
instance, when the current window or view containing that button is
closed.

We capture these emitted events only **asynchronously**, by defining a
function that will execute when a value is emitted, another function
when an error is emitted, and another function when 'completed' is
emitted. Sometimes these last two can be omitted and you can just focus
on defining the function for values. The "listening" to the stream is
called **subscribing**. The functions we are defining are observers. The
stream is the subject (or "observable") being observed. This is
precisely the [Observer Design
Pattern](https://en.wikipedia.org/wiki/Observer_pattern).

An alternative way of drawing that diagram is with ASCII, which we will
use in some parts of this tutorial:

    --a---b-c---d---X---|->

    a, b, c, d are emitted values
    X is an error
    | is the 'completed' signal
    ---> is the timeline

Since this feels so familiar already, and I don't want you to get bored,
let's do something new: we are going to create new click event streams
transformed out of the original click event stream.

First, let's make a counter stream that indicates how many times a
button was clicked. In common FRP libraries, each stream has many
functions attached to it, such as `map`, `filter`, `scan`, etc. When you
call one of these functions, such as `clickStream.map(f)`, it returns a
**new stream** based on the click stream. It does not modify the
original click stream in any way. This is a property called
**immutability**, and it goes together with FRP streams just like
pancakes are good with syrup. That allows us to chain functions like
`clickStream.map(f).scan(g)`:

      clickStream: ---c----c--c----c------c-->
                   vvvvv map(c becomes 1) vvvv
                   ---1----1--1----1------1-->
                   vvvvvvvvv scan(+) vvvvvvvvv
    counterStream: ---1----2--3----4------5-->

The `map(f)` function replaces (into the new stream) each emitted value
according to a function `f` you provide. In our case, we mapped to the
number 1 on each click. The `scan(g)` function aggregates all previous
values on the stream, producing value `x = g(accumulated, current)`,
where `g` was simply the add function in this example. Then,
`counterStream` emits the total number of clicks whenever a click
happens.

To show the real power of FRP, let's just say that you want to have a
stream of "double click" events. To make it even more interesting, let's
say we want the new stream to consider triple clicks as double clicks,
or in general, multiple clicks (two or more). Take a deep breath and
imagine how you would do that in a traditional imperative and stateful
fashion. I bet it sounds fairly nasty and involves some variables to
keep state and some fiddling with time intervals.

Well, in FRP it's pretty simple. In fact, the logic is just [4 lines of
code](http://jsfiddle.net/staltz/4gGgs/27/). But let's ignore code for
now. Thinking in diagrams is the best way to understand and build
streams, whether you're a beginner or an expert.

[![Multiple clicks
stream](https://camo.githubusercontent.com/74d215aac2e23ae940cf5d1f4e08cc8878c9fecf/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f623538306164346133336236336163623263656439623865356539306661616238636137656632362f7a6d756c7469636c69636b73747265616d2e706e67)](https://camo.githubusercontent.com/74d215aac2e23ae940cf5d1f4e08cc8878c9fecf/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f623538306164346133336236336163623263656439623865356539306661616238636137656632362f7a6d756c7469636c69636b73747265616d2e706e67)

Grey boxes are functions transforming one stream into another. First we
accumulate clicks in lists, whenever 250 milliseconds of "event silence"
has happened (that's what `buffer(stream.throttle(250ms))` does, in a
nutshell. Don't worry about understanding the details at this point, we
are just demoing FRP for now). The result is a stream of lists, from
which we apply `map()` to map each list to an integer matching the
length of that list. Finally, we ignore `1` integers using the
`filter(x >= 2)` function. That's it: 3 operations to produce our
intended stream. We can then subscribe ("listen") to it to react
accordingly how we wish.

I hope you enjoy the beauty of this approach. This example is just the
tip of the iceberg: you can apply the same operations on different kinds
of streams, for instance, on a stream of API responses; on the other
hand, there are many other functions available.

[](#why-should-i-consider-adopting-frp)"Why should I consider adopting FRP?"
----------------------------------------------------------------------------

FRP raises the level of abstraction of your code so you can focus on the
interdependence of events that define the business logic, rather than
having to constantly fiddle with a large amount of implementation
details. Code with FRP will likely be more concise.

The benefit is more evident in modern webapps and mobile apps that are
highly interactive with a multitude of UI events related to data events.
10 years ago, interaction with web pages was basically about submitting
a long form to the backend and performing simple rendering to the
frontend. Apps have evolved to be more real-time: modifying a single
form field can automatically trigger a save to the backend, "likes" to
some content can be reflected in real time to other connected users, and
so forth.

Apps nowadays have an abundancy of real-time events of every kind that
enable a highly interactive experience to the user. We need tools for
properly dealing with that, and Functional Reactive Programming is the
answer.

[](#thinking-in-frp-with-examples)Thinking in FRP, with examples
----------------------------------------------------------------

Let's dive into the real stuff. A real-world example with a step-by-step
guide on how to think in FRP. No synthetic examples, no half-explained
concepts. By the end of this tutorial we will have produced real
functioning code, while knowing why we did each thing.

I picked **JavaScript** and
**[RxJS](https://github.com/Reactive-Extensions/RxJS)** as the tools for
this, for a reason: JavaScript is the most familiar language out there
at the moment, and the [Rx\* library family](https://rx.codeplex.com/)
is widely available for many languages and platforms
([.NET](https://rx.codeplex.com/),
[Java](https://github.com/Netflix/RxJava),
[Scala](https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala),
[Clojure](https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-clojure),
[JavaScript](https://github.com/Reactive-Extensions/RxJS),
[Ruby](https://github.com/Reactive-Extensions/Rx.rb),
[Python](https://github.com/Reactive-Extensions/RxPy),
[C++](https://github.com/Reactive-Extensions/RxCpp),
[Objective-C/Cocoa](https://github.com/ReactiveCocoa/ReactiveCocoa),
[Groovy](https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-groovy),
etc). So whatever your tools are, you can concretely benefit by
following this tutorial.

[](#implementing-a-who-to-follow-suggestions-box)Implementing a "Who to follow" suggestions box
-----------------------------------------------------------------------------------------------

In Twitter there is this UI element that suggests other accounts you
could follow:

[![Twitter Who to follow suggestions
box](https://camo.githubusercontent.com/c30617647900cd2f1e03b2455fc31f72c000f0d2/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f323133303335373061316338633539396535396638663866626461326430336162393433616339622f7a74776974746572626f782e706e67)](https://camo.githubusercontent.com/c30617647900cd2f1e03b2455fc31f72c000f0d2/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f323133303335373061316338633539396535396638663866626461326430336162393433616339622f7a74776974746572626f782e706e67)

We are going to focus on imitating its core features, which are:

-   On startup, load accounts data from the API and display 3
    suggestions
-   On clicking "Refresh", load 3 other account suggestions into the 3
    rows
-   On click 'x' button on an account row, clear only that current
    account and display another
-   Each row displays the account's avatar and links to their page

We can leave out the other features and buttons because they are minor.
And, instead of Twitter, which recently closed its API to the
unauthorized public, let's build that UI for following people on Github.
There's a [Github API for getting
users](https://developer.github.com/v3/users/#get-all-users).

The complete code for this is ready at
[http://jsfiddle.net/staltz/8jFJH/48/](http://jsfiddle.net/staltz/8jFJH/48/)
in case you want to take a peak already.

[](#request-and-response)Request and response
---------------------------------------------

**How do you approach this problem with FRP?** Well, to start with,
(almost) *everything can be a stream*. That's the FRP mantra. Let's
start with the easiest feature: "on startup, load 3 accounts data from
the API". Obviously, this is simply about (1) doing a request, (2)
getting a response, (3) rendering the response. So let's go ahead and
represent our requests as a stream. At first this will feel like an
overkill, but we need to start from the basics, right?

On startup we need to do only one request, so if we model it as a data
stream, it will be a stream with only one emitted value. Later, we know
we will have many requests happening, but for now, it is just one.

    --a------|->

    Where a is the string 'https://api.github.com/users'

This is a stream of URLs that we want to request. Whenever a request
event happens, it tells us two things: when and what. "When" the request
should be executed is when the event is emitted. And "what" should be
requested is the value emitted: a string containing the URL.

To create such stream with a single value is very simple in Rx\*. The
official terminology for a stream is "Observable", for the fact that it
can be observed, but I find it to be a silly name, so I call it
*stream*.

    var requestStream = Rx.Observable.returnValue('https://api.github.com/users');

But now, that is just a stream of strings, doing no other operation, so
we need to somehow make something happen when that value is emitted.
That's done by
[subscribing](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypesubscribeobserver--onnext-onerror-oncompleted)
to the stream.

    requestStream.subscribe(function(requestUrl) {
      // execute the request
      jQuery.getJSON(requestUrl, function(responseData) {
        // ...
      });
    }

Notice we are using a jQuery Ajax callback (which we assume you [should
know already](http://devdocs.io/jquery/jquery.getjson)) to handle the
asynchronicity of the request operation. But wait a moment, FRP is for
dealing with **asynchronous** data streams. Couldn't the response for
that request be a stream containing the data arriving at some time in
the future? Well, at a conceptual level, it sure looks like, so let's
try that.

    requestStream.subscribe(function(requestUrl) {
      // execute the request
      var responseStream = Rx.Observable.create(function (observer) {
        jQuery.getJSON(requestUrl)
        .then(function(response) { observer.onNext(response); })
        .fail(function(jqXHR, status, error) { observer.onError(error); })
        .done(function() { observer.onCompleted(); });
      });

      responseStream.subscribe(function(response) {
        // do something with the response
      });
    }

What
[`Rx.Observable.create()`](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablecreatesubscribe)
does is create your own custom stream by explicitly informing each
observer (or in other words, a "subscriber") about data events
(`onNext()`) or errors (`onError()`). What we did was just wrap that
jQuery Ajax Promise. **Excuse me, does this mean that a Promise is an
Observable?**

[![Amazed](https://camo.githubusercontent.com/4df519edd2d527bf5e90b7d00e22cdc3c3be00d4/687474703a2f2f7777772e6d79666163657768656e2e6e65742f75706c6f6164732f333332342d616d617a65642d666163652e676966)](https://camo.githubusercontent.com/4df519edd2d527bf5e90b7d00e22cdc3c3be00d4/687474703a2f2f7777772e6d79666163657768656e2e6e65742f75706c6f6164732f333332342d616d617a65642d666163652e676966)

Yes.

Observable is Promise++. In Rx you can easily convert a Promise to an
Observable by doing `var stream = Rx.Observable.fromPromise(promise)`,
so let's use that. The only difference is that Observables are not
[Promises/A+](http://promises-aplus.github.io/promises-spec/) compliant,
but conceptually there is no clash. A Promise is simply an Observable
with one single emitted value. FRP streams go beyond promises by
allowing many returned values.

This is pretty nice, and shows how FRP is at least as powerful as
Promises. So if you believe the Promises hype, keep an eye on what FRP
is capable of.

Now back to our example, if you were quick to notice, we have one
`subscribe()` call inside another, which is somewhat akin to callback
hell. Also, the creation of `responseStream` is dependent on
`requestStream`. As you heard before, in FRP there are simple mechanisms
for transforming and creating new streams out of others, so we should be
doing that.

The one basic function that you should know by now is
[`map(f)`](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemapselector-thisarg),
which takes each value of stream A, applies `f()` on it, and produces a
value on stream B. If we do that to our request and response streams, we
can map request URLs to response Promises (disguised as streams).

    var responseMetastream = requestStream
      .map(function(requestUrl) {
        return Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));
      });

Then we will have created a beast called "*metastream*": a stream of
streams. Don't panic yet. A metastream is a stream where each emitted
value is yet another stream. You can think of it as
[pointers](https://en.wikipedia.org/wiki/Pointer_(computer_programming)):
each emitted value is a *pointer* to another stream. In our example,
each request URL is mapped to a pointer to the promise stream containing
the corresponding response.

[![Response
metastream](https://camo.githubusercontent.com/96ffbf34242769e3ffa585594312e6da8a5ab099/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f653866643162623662643933353333636638616661653432626466313962646666393266626332632f7a726573706f6e73656d65746173747265616d2e706e67)](https://camo.githubusercontent.com/96ffbf34242769e3ffa585594312e6da8a5ab099/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f653866643162623662643933353333636638616661653432626466313962646666393266626332632f7a726573706f6e73656d65746173747265616d2e706e67)

A metastream for responses looks confusing, and doesn't seem to help us
at all. We just want a simple stream of responses, where each emitted
value is a JSON object, not a 'Promise' of a JSON object. Say hi to [Mr.
Flatmap](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeflatmapselector-resultselector):
a version of `map()` than "flattens" a metastream, by emitting on the
"trunk" stream everything that will be emitted on "branch" streams.
Flatmap is not a "fix" and metastreams are not a bug, these are really
the tools for dealing with asynchronous responses in FRP.

    var responseStream = requestStream
      .flatMap(function(requestUrl) {
        return Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));
      });

[![Response
stream](https://camo.githubusercontent.com/56bb9263de95fdecdcb4fa75c7c8da63cd80f6dc/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f373436613565313733323833363862636261356462643339376238346665383037396565663764642f7a726573706f6e736573747265616d2e706e67)](https://camo.githubusercontent.com/56bb9263de95fdecdcb4fa75c7c8da63cd80f6dc/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f373436613565313733323833363862636261356462643339376238346665383037396565663764642f7a726573706f6e736573747265616d2e706e67)

Nice. And because the response stream is defined according to request
stream, **if** we have later on more events happening on request stream,
we will have the corresponding response events happening on response
stream, as expected:

    requestStream:  --a-----b--c------------|->
    responseStream: -----A--------B-----C---|->

    (lowercase is a request, uppercase is its response)

Now that we finally have a response stream, we can render the data we
receive:

    responseStream.subscribe(function(response) {
      // render `response` to the DOM however you wish
    });

Joining all the code until now, we have:

    var requestStream = Rx.Observable.returnValue('https://api.github.com/users');

    var responseStream = requestStream
      .flatMap(function(requestUrl) {
        return Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));
      });

    responseStream.subscribe(function(response) {
      // render `response` to the DOM however you wish
    });

[](#the-refresh-button)The refresh button
-----------------------------------------

I did not yet mention that the JSON in the response is a list with 100
users. The API only allows us to specify the page offset, and not the
page size, so we're using just 3 data objects and wasting 97 others. We
can ignore that problem for now, since later on we will see how to cache
the responses.

Everytime the refresh button is clicked, the request stream should emit
a new URL, so that we can get a new response. We need two things: a
stream of click events on the refresh button (mantra: anything can be a
stream), and we need to change the request stream to depend on the
refresh click stream. Gladly, RxJS comes with tools to make Observables
from event listeners.

    var refreshButton = document.querySelector('.refresh');
    var refreshClickStream = Rx.Observable.fromEvent(refreshButton, 'click');

Since the refresh click event doesn't itself carry any API URL, we need
to map each click to an actual URL. Now we change the request stream to
be the refresh click stream mapped to the API endpoint with a random
offset parameter each time.

    var requestStream = refreshClickStream
      .map(function() {
        var randomOffset = Math.floor(Math.random()*500);
        return 'https://api.github.com/users?since=' + randomOffset;
      });

Because I'm dumb and I don't have automated tests, I just broke one of
our previously built features. A request doesn't happen anymore on
startup, it happens only when the refresh is clicked. Urgh. I need both
behaviors: a request when *either* a refresh is clicked *or* the webpage
was just opened.

We know how to make a separate stream for each one of those cases:

    var requestOnRefreshStream = refreshClickStream
      .map(function() {
        var randomOffset = Math.floor(Math.random()*500);
        return 'https://api.github.com/users?since=' + randomOffset;
      });

    var startupRequestStream = Rx.Observable.returnValue('https://api.github.com/users');

But how can we "merge" these two into one? Well, there's
[`merge()`](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemergemaxconcurrent--other).
Explained in the diagram dialect, this is what it does:

    stream A: ---a--------e-----o----->
    stream B: -----B---C-----D-------->
              vvvvvvvvv merge vvvvvvvvv
              ---a-B---C--e--D--o----->

It should be easy now:

    var requestOnRefreshStream = refreshClickStream
      .map(function() {
        var randomOffset = Math.floor(Math.random()*500);
        return 'https://api.github.com/users?since=' + randomOffset;
      });

    var startupRequestStream = Rx.Observable.returnValue('https://api.github.com/users');

    var requestStream = Rx.Observable.merge(
      requestOnRefreshStream, startupRequestStream
    );

There is an alternative and cleaner way of writing that, without the
intermediate streams.

    var requestStream = refreshClickStream
      .map(function() {
        var randomOffset = Math.floor(Math.random()*500);
        return 'https://api.github.com/users?since=' + randomOffset;
      })
      .merge(Rx.Observable.returnValue('https://api.github.com/users'));

Even shorter, even more readable:

    var requestStream = refreshClickStream
      .map(function() {
        var randomOffset = Math.floor(Math.random()*500);
        return 'https://api.github.com/users?since=' + randomOffset;
      })
      .startWith('https://api.github.com/users');

The
[`startWith()`](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypestartwithscheduler-args)
function does exactly what you think it does. No matter how your input
stream looks like, the output stream resulting of `startWith(x)` will
have `x` at the beginning. But I'm not
[DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself) enough, I'm
repeating the API endpoint string. One way to fix this is by moving the
`startWith()` close to the `refreshClickStream`, to essentially
"emulate" a refresh click on startup.

    var requestStream = refreshClickStream.startWith('startup click')
      .map(function() {
        var randomOffset = Math.floor(Math.random()*500);
        return 'https://api.github.com/users?since=' + randomOffset;
      });

Nice. If you go back to the point where I "broke the automated tests",
you should see that the only difference with this last approach is that
I added the `startWith()`.

[](#modelling-the-3-suggestions-with-streams)Modelling the 3 suggestions with streams
-------------------------------------------------------------------------------------

Until now, we have only touched a *suggestion* UI element on the
rendering step that happens in the responseStream's `subscribe()`. Now
with the refresh button, we have a problem: as soon as you click
'refresh', the current 3 suggestions are not cleared. New suggestions
come in only after a response has arrived, but to make the UI look nice,
we need to clean out the current suggestions when clicks happen on the
refresh.

    refreshClickStream.subscribe(function() {
      // clear the 3 suggestion DOM elements 
    });

No, not so fast, pal. This is bad, because we now have **two**
subscribers that affect the suggestion DOM elements (the other one being
`responseStream.subscribe()`), and that doesn't really sound like
[Separation of
concerns](https://en.wikipedia.org/wiki/Separation_of_concerns).
Remember the FRP mantra?

[![Mantra](https://camo.githubusercontent.com/348b1eb60fa6c0d44d7f091240f0ff462b539619/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f373936626539623636666637636535386239306536356134396533623938333262383632646564642f7a6d616e7472612e6a7067)](https://camo.githubusercontent.com/348b1eb60fa6c0d44d7f091240f0ff462b539619/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f373936626539623636666637636535386239306536356134396533623938333262383632646564642f7a6d616e7472612e6a7067)

So let's model a suggestion as a stream, where each emitted value is the
JSON object containing the suggestion data. We will do this separately
for each of the 3 suggestions. This is how the stream for suggestion \#1
could look like:

    var suggestion1Stream = responseStream
      .map(function(listUsers) {
        // get one random user from the list
        return listUsers[Math.floor(Math.random()*listUsers.length)];
      });

The others, `suggestion2Stream` and `suggestion3Stream` can be simply
copy pasted from `suggestion1Stream`. This is not DRY, but it will keep
our example simple for this tutorial, plus I think it's a good exercise
to think how to avoid repetition in this case.

Instead of having the rendering happen in responseStream's subscribe(),
we do that here:

    suggestion1Stream.subscribe(function(suggestion) {
      // render the 1st suggestion to the DOM
    });

Back to the "on refresh, clear the suggestions", we can simply map
refresh clicks to `null` suggestion data, and include that in the
`suggestion1Stream`, as such:

    var suggestion1Stream = responseStream
      .map(function(listUsers) {
        // get one random user from the list
        return listUsers[Math.floor(Math.random()*listUsers.length)];
      })
      .merge(
        refreshClickStream.map(function(){ return null; })
      );

And when rendering, we interpret `null` as "no data", hence hiding its
UI element.

    suggestion1Stream.subscribe(function(suggestion) {
      if (suggestion === null) {
        // hide the first suggestion DOM element
      }
      else {
        // show the first suggestion DOM element
        // and render the data
      }
    });

The big picture is now:

    refreshClickStream: ----------o--------o---->
         requestStream: -r--------r--------r---->
        responseStream: ----R---------R------R-->   
     suggestion1Stream: ----s-----N---s----N-s-->
     suggestion2Stream: ----q-----N---q----N-q-->
     suggestion3Stream: ----t-----N---t----N-t-->

Where `N` stands for `null`.

As a bonus, we can also render "empty" suggestions on startup. That is
done by adding `startWith(null)` to the suggestion streams:

    var suggestion1Stream = responseStream
      .map(function(listUsers) {
        // get one random user from the list
        return listUsers[Math.floor(Math.random()*listUsers.length)];
      })
      .merge(
        refreshClickStream.map(function(){ return null; })
      )
      .startWith(null);

Which results in:

    refreshClickStream: ----------o---------o---->
         requestStream: -r--------r---------r---->
        responseStream: ----R----------R------R-->   
     suggestion1Stream: -N--s-----N----s----N-s-->
     suggestion2Stream: -N--q-----N----q----N-q-->
     suggestion3Stream: -N--t-----N----t----N-t-->

[](#closing-a-suggestion-and-using-cached-responses)Closing a suggestion and using cached responses
---------------------------------------------------------------------------------------------------

There is one feature remaining to implement. Each suggestion should have
its own 'x' button for closing it, and loading another in its place. At
first thought, you could say it's enough to make a new request when any
close button is clicked:

    var close1Button = document.querySelector('.close1');
    var close1ClickStream = Rx.Observable.fromEvent(close1Button, 'click');
    // and the same for close2Button and close3Button

    var requestStream = refreshClickStream.startWith('startup click')
      .merge(close1ClickStream) // we added this
      .map(function() {
        var randomOffset = Math.floor(Math.random()*500);
        return 'https://api.github.com/users?since=' + randomOffset;
      });

That does not work. It will close and reload *all* suggestions, rather
than just only the one we clicked on. There are a couple of different
ways of solving this, and to keep it interesting, we will solve it by
reusing previous responses. The API's response page size is 100 users
while we were using just 3 of those, so there is plenty of fresh data
available. No need to request more.

Again, let's think in streams. When a 'close1' click event happens, we
want to use the *most recently emitted* response on `responseStream` to
get one random user from the list in the response. As such:

        requestStream: --r--------------->
       responseStream: ------R----------->
    close1ClickStream: ------------c----->
    suggestion1Stream: ------s-----s----->

In Rx\* there is a combinator function called
[`combineLatest`](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypecombinelatestargs-resultselector)
that seems to do what we need. It takes two streams A and B as inputs,
and whenever either stream emits a value, `combineLatest` joins the two
most recently emitted values `a` and `b` from both streams and outputs a
value `c = f(x,y)`, where `f` is a function you define. It is better
explained with a diagram:

    stream A: --a-----------e--------i-------->
    stream B: -----b----c--------d-------q---->
              vvvvvvvv combineLatest(f) vvvvvvv
              ----AB---AC--EC---ED--ID--IQ---->

    where f is the uppercase function

We can apply combineLatest() on `close1ClickStream` and
`responseStream`, so that whenever the close 1 button is clicked, we get
the latest response emitted and produce a new value on
`suggestion1Stream`. On the other hand, combineLatest() is symmetric:
whenever a new response is emitted on `responseStream`, it will combine
with the latest 'close 1' click to produce a new suggestion. That is
interesting, because it allows us to simplify our previous code for
`suggestion1Stream`, like this:

    var suggestion1Stream = close1ClickStream
      .combineLatest(responseStream,             
        function(click, listUsers) {
          return listUsers[Math.floor(Math.random()*listUsers.length)];
        }
      )
      .merge(
        refreshClickStream.map(function(){ return null; })
      )
      .startWith(null);

One piece is still missing in the puzzle. The combineLatest() uses the
most recent of the two sources, but if one of those sources hasn't
emitted anything yet, combineLatest() cannot produce a data event on the
output stream. If you look at the ASCII diagram above, you will see that
the output has nothing when the first stream emitted value `a`. Only
when the second stream emitted value `b` could it produce an output
value.

There are different ways of solving this, and we will stay with the
simplest one, which is simulating a click to the 'close 1' button on
startup:

    var suggestion1Stream = close1ClickStream.startWith('startup click') // we added this
      .combineLatest(responseStream,             
        function(click, listUsers) {l
          return listUsers[Math.floor(Math.random()*listUsers.length)];
        }
      )
      .merge(
        refreshClickStream.map(function(){ return null; })
      )
      .startWith(null);

[](#wrapping-up)Wrapping up
---------------------------

And we're done. The complete code for all this was:

    var refreshButton = document.querySelector('.refresh');
    var refreshClickStream = Rx.Observable.fromEvent(refreshButton, 'click');

    var closeButton1 = document.querySelector('.close1');
    var close1ClickStream = Rx.Observable.fromEvent(closeButton1, 'click');
    // and the same logic for close2 and close3

    var requestStream = refreshClickStream.startWith('startup click')
      .map(function() {
        var randomOffset = Math.floor(Math.random()*500);
        return 'https://api.github.com/users?since=' + randomOffset;
      });

    var responseStream = requestStream
      .flatMap(function (requestUrl) {
        return Rx.Observable.fromPromise($.ajax({url: requestUrl}));
      });

    var suggestion1Stream = close1ClickStream.startWith('startup click')
      .combineLatest(responseStream,             
        function(click, listUsers) {
          return listUsers[Math.floor(Math.random()*listUsers.length)];
        }
      )
      .merge(
        refreshClickStream.map(function(){ return null; })
      )
      .startWith(null);
    // and the same logic for suggestion2Stream and suggestion3Stream

    suggestion1Stream.subscribe(function(suggestion) {
      if (suggestion === null) {
        // hide the first suggestion DOM element
      }
      else {
        // show the first suggestion DOM element
        // and render the data
      }
    });

**You can see this working example at
[http://jsfiddle.net/staltz/8jFJH/48/](http://jsfiddle.net/staltz/8jFJH/48/)**

That piece of code is small but dense: it features management of
multiple events with proper separation of concerns, and even caching of
responses. The functional style made the code look more declarative than
imperative: we are not giving a sequence of instructions to execute, we
are just **telling what something is** by defining relationships between
streams. For instance, with FRP we told the computer that
*`suggestion1Stream` **is** the 'close 1' stream combined with one user
from the latest response, besides being `null` when a refresh happens or
program startup happened*.

Notice also the impressive absence of control flow elements such as
`if`, `for`, `while`, and the typical callback-based control flow that
you expect from a JavaScript application. You can even get rid of the
`if` and `else` in the `subscribe()` above by using `filter()` if you
want (I'll leave the implementation details to you as an exercise). In
FRP, we have stream functions such as `map`, `filter`, `scan`, `merge`,
`combineLatest`, `startWith`, and many more to control the flow of an
event-driven program. This toolset of functions gives you more power in
less code.

[](#what-comes-next)What comes next
-----------------------------------

If you think Rx\* will be your preferred library for FRP, take a while
to get acquainted with the [big list of
functions](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md)
for transforming, combining, and creating Observables. If you want to
understand those functions in diagrams of streams, take a look at
[RxJava's very useful documentation with marble
diagrams](https://github.com/Netflix/RxJava/wiki/Creating-Observables).
Whenever you get stuck trying to do something, draw those diagrams,
think on them, look at the long list of functions, and think more. This
workflow has been effective in my experience.

Once you start getting the hang of programming with Rx\*, it is
absolutely required to understand the concept of [Cold vs Hot
Observables](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md#cold-vs-hot-observables).
If you ignore this, it will come back and bite you brutally. You have
been warned. Sharpen your skills further by learning real functional
programming, and getting acquainted with issues such as side effects
that affect Rx\*.

But Functional Reactive Programming is not just Rx\*. There is
[Bacon.js](http://baconjs.github.io/) which is intuitive to work with,
without the quirks you sometimes encounter in Rx\*. The [Elm
Language](http://elm-lang.org/) lives in its own category: it's an FRP
**language** that compiles to JavaScript + HTML + CSS, and features a
[time travelling debugger](http://debug.elm-lang.org/). Pretty awesome.

FRP works great for event-heavy frontends and apps. But it is not just a
client-side thing, it works great also in the backend and close to
databases. In fact, [RxJava is a key component for enabling server-side
concurrency in Netflix's
API](http://techblog.netflix.com/2013/02/rxjava-netflix-api.html). FRP
is not a framework restricted to one specific type of application or
language. It really is a paradigm that you can apply for programming any
event-driven software.

If this tutorial helped you, [tweet it
forward](https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Fgist.github.com%2Fstaltz%2F868e7e9bc2a7b8c1f754%2F&amp;text=The%20introduction%20to%20Reactive%20Programming%20you%27ve%20been%20missing&amp;tw_p=tweetbutton&amp;url=https%3A%2F%2Fgist.github.com%2Fstaltz%2F868e7e9bc2a7b8c1f754&amp;via=andrestaltz).

[View **introrx.md**](/staltz/868e7e9bc2a7b8c1f754)

**** [**zclickstream.png**](#file-zclickstream-png)

[Raw](/staltz/868e7e9bc2a7b8c1f754/raw/49da694b2489f9e7b7276df31a1dcb206179a496/zclickstream.png)

File suppressed. Click to show.

![Zclickstream](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754/raw/49da694b2489f9e7b7276df31a1dcb206179a496/zclickstream.png)

[View **introrx.md**](/staltz/868e7e9bc2a7b8c1f754)

**** [**zmantra.jpg**](#file-zmantra-jpg)

[Raw](/staltz/868e7e9bc2a7b8c1f754/raw/796be9b66ff7ce58b90e65a49e3b9832b862dedd/zmantra.jpg)

File suppressed. Click to show.

![Zmantra](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754/raw/796be9b66ff7ce58b90e65a49e3b9832b862dedd/zmantra.jpg)

[View **introrx.md**](/staltz/868e7e9bc2a7b8c1f754)

**** [**zmulticlickstream.png**](#file-zmulticlickstream-png)

[Raw](/staltz/868e7e9bc2a7b8c1f754/raw/b580ad4a33b63acb2ced9b8e5e90faab8ca7ef26/zmulticlickstream.png)

File suppressed. Click to show.

![Zmulticlickstream](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754/raw/b580ad4a33b63acb2ced9b8e5e90faab8ca7ef26/zmulticlickstream.png)

[View **introrx.md**](/staltz/868e7e9bc2a7b8c1f754)

**** [**zresponsemetastream.png**](#file-zresponsemetastream-png)

[Raw](/staltz/868e7e9bc2a7b8c1f754/raw/e8fd1bb6bd93533cf8afae42bdf19bdff92fbc2c/zresponsemetastream.png)

File suppressed. Click to show.

![Zresponsemetastream](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754/raw/e8fd1bb6bd93533cf8afae42bdf19bdff92fbc2c/zresponsemetastream.png)

[View **introrx.md**](/staltz/868e7e9bc2a7b8c1f754)

**** [**zresponsestream.png**](#file-zresponsestream-png)

[Raw](/staltz/868e7e9bc2a7b8c1f754/raw/746a5e17328368bcba5dbd397b84fe8079eef7dd/zresponsestream.png)

File suppressed. Click to show.

![Zresponsestream](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754/raw/746a5e17328368bcba5dbd397b84fe8079eef7dd/zresponsestream.png)

[View **introrx.md**](/staltz/868e7e9bc2a7b8c1f754)

**** [**ztwitterbox.png**](#file-ztwitterbox-png)

[Raw](/staltz/868e7e9bc2a7b8c1f754/raw/21303570a1c8c599e59f8f8fbda2d03ab943ac9b/ztwitterbox.png)

File suppressed. Click to show.

![Ztwitterbox](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754/raw/21303570a1c8c599e59f8f8fbda2d03ab943ac9b/ztwitterbox.png)

[![image](https://avatars1.githubusercontent.com/u/16389?s=140)](/ryana)

**[ryana](/ryana)** commented [June 30, 2014](#comment-1254997)

This is incredibly well-written. @staltz do you mind talking a little
bit about your process for writing this, how long it took, etc... Very
impressive stuff.

[![image](https://avatars0.githubusercontent.com/u/90512?s=140)](/staltz)

Owner

**[staltz](/staltz)** commented [June 30, 2014](#comment-1255003)

UPDATE: there's been a lot of confusion around the terms *Functional
Reactive Programming* and *Reactive Programming*
[[1]](https://news.ycombinator.com/item?id=7964873)
[[2]](https://twitter.com/ReactiveX/status/483625917491970048).

Sorry, my bad. I guess this sort of confusion happens easily with new
paradigms in computing.\
 Replace all the occurrences of "FRP" with "RP" in the tutorial.
Functional Reactive Programming is a variant of Reactive Programming
that follows Functional Programming principles such as referential
transparency, and seeks to be purely functional. Other people are better
at explaining this than I am.
[[3]](http://www.slideshare.net/deanwampler/reactive-design-languages-and-paradigms)
[[4]](http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote-Duality)
[[5]](http://conal.net/fran/tutorial.htm)

[![image](https://avatars1.githubusercontent.com/u/3745434?s=140)](/trkrameshkumar)

**[trkrameshkumar](/trkrameshkumar)** commented [June 30,
2014](#comment-1255012)

Very informative , well documented

[![image](https://avatars3.githubusercontent.com/u/1468284?s=140)](/se77en)

**[se77en](/se77en)** commented [June 30, 2014](#comment-1255013)

I love this post

[![image](https://avatars2.githubusercontent.com/u/1089089?s=140)](/floatingmonkey)

**[floatingmonkey](/floatingmonkey)** commented [June 30,
2014](#comment-1255024)

great read!

[![image](https://avatars3.githubusercontent.com/u/56947?s=140)](/swanson)

**[swanson](/swanson)** commented [June 30, 2014](#comment-1255055)

I've struggled to grok FRP in the past - I hear lots of smart people
trumpeting it, but I haven't been able to wrap my head around it. This
tutorial was great and I was following along right until it got to the
part about modeling the suggestions as streams
([https://gist.github.com/staltz/868e7e9bc2a7b8c1f754\#modellin...](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#modellin...)).

That was where everything went haywire for me - my brain doesn't want to
think about those UI elements as streams and I instantly tune out and
think "this doesn't make sense". I'm curious if anyone else also got
stuck at that same part, as well as if anyone has suggestions/ideas for
breaking past this mental barrier? Is there a different way of solving
the same problem (that might make more sense to me)?

I can see value in having a `Suggestion` emit some kind of event ("I
need to be refreshed" or "My X was clicked") but I'm struggling to see
how that connects to the network/API stream. Do they have to be so
tightly linked?

[![image](https://avatars0.githubusercontent.com/u/90512?s=140)](/staltz)

Owner

**[staltz](/staltz)** commented [June 30, 2014](#comment-1255065)

Hi @swanson, sorry for that section, I might have gone a bit too fast
near the end.

Try not to think of the suggestion stream as "UI element stream". It is
a data stream in the sense that everything it emits is simply data.
Although, as you noticed, it is tightly linked to the close button click
stream, and also tightly linked to the response stream. In a way, it
lives between Model and View, if you think about an MVC framework.

In fact, suggestion stream is best understood as a ViewModel in the
[MVVM architecture](https://en.wikipedia.org/wiki/Model_View_ViewModel).
MVVM happens to be a good fit for Rx\*. Quoting Wikipedia:

> The view model of MVVM is a value converter meaning that the view
> model is responsible for exposing the data objects from the model in
> such a way that those objects are easily managed and consumed. In this
> respect, the view model is more model than view, and handles most if
> not all of the view’s display logic.

[![MVVM](https://camo.githubusercontent.com/2b52d778c740389d92f284f08c37c5e6fe5e45e7/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f382f38372f4d56564d5061747465726e2e706e67)](https://camo.githubusercontent.com/2b52d778c740389d92f284f08c37c5e6fe5e45e7/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f382f38372f4d56564d5061747465726e2e706e67)

Suggestion stream prepares data coming from the model (response stream)
in such a way that the data it emits can be immediately consumed by the
View (the subscriber which renders to the DOM). It frees the View from
having to do any kind of logic.

If we had followed MVVM strictly in this example, we would need also a
`close1ClickViewModelStream` just to detach the suggestion stream from
`close1ClickStream`, and it would be defined as such:
`close1ClickViewModelStream = close1ClickStream.startWith('startup click')`.

Programming with Rx\* doesn't require MVVM, but I've found it to be a
good architecture.

[![image](https://avatars3.githubusercontent.com/u/56947?s=140)](/swanson)

**[swanson](/swanson)** commented [June 30, 2014](#comment-1255072)

Is there a concept of some independent thing emitting an event to hook
into the stream? I guess I am more used to a traditional event bus,
where a `SuggestionViewModel` might emit `SuggestionRemoved` event which
would trigger the API stream to go get some new data. And the view model
might want to subscribe to a `NewSuggestion` event to render the new
data. My natural feeling is that a view/view model should not care about
the internals of how the data was loaded, that I am using a stream, etc
and the approach you outlined seems like this is all mashed together
because all the streams must be merged/connected directly.

[![image](https://avatars0.githubusercontent.com/u/90512?s=140)](/staltz)

Owner

**[staltz](/staltz)** commented [June 30, 2014](#comment-1255082)

@swanson Nothing stops you from doing that kind of approach. For
instance, you could do
`suggestionRemovedStream = close1ClickStream.startWith('startup click')`.

However, one hint for "thinking in the right way": avoid saying that the
`SuggestionRemoved` event would trigger the API stream. Think the other
way around: the API stream is *triggered by* the `SuggestionRemoved`.
It's an important distinction because Rx is "Push" while imperative is
"Pull".
[https://github.com/Reactive-Extensions/RxJS/tree/master/doc\#rxjs-v22](https://github.com/Reactive-Extensions/RxJS/tree/master/doc#rxjs-v22)
It makes a difference because `SuggestionRemoved` will have no knowledge
of the API stream. It's the API stream that can listen to ("subscribe")
events from `SuggestionRemoved`.

The mashing together happens in the ViewModel, which is typically a
class/module with a couple of streams, assuming two roles: Observer, and
Observed. Events move in both directions (from Model to View and
vice-versa) in the ViewModel. The benefit is that Model streams and View
streams don't need to care about any other streams, they just do their
thing by defining what they emit. The ViewModel glues it together.

View streams: `refreshClickStream`, `closeClickStream`\
 Model streams: `requestStream`, `responseStream`

[![image](https://avatars0.githubusercontent.com/u/90512?s=140)](/staltz)

Owner

**[staltz](/staltz)** commented [June 30, 2014](#comment-1255085)

@swanson That said, I recommend reading about
[Subjects](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/subjects.md)
which are streams that you can explicitly feed in new events,
imperative-style:

`subject.onNext("suggestion removed!")`.

[![image](https://avatars2.githubusercontent.com/u/744973?s=140)](/grant)

**[grant](/grant)** commented [June 30, 2014](#comment-1255086)

![:+1:](https://a248.e.akamai.net/assets.github.com/images/icons/emoji/%2B1.png ":+1:")
Love it.

[![image](https://avatars2.githubusercontent.com/u/1107697?s=140)](/queimadus)

**[queimadus](/queimadus)** commented [June 30, 2014](#comment-1255089)

Great read! After fiddling around a little with the demo I got some
unexpected behavior.\
 Clicking the refresh button, makes not one, but three JSON calls to the
service, each time.\
 Why is that?

Seems like it is the behavior exemplified in the
[Rx.Observable.prototype.publish([selector])](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypepublishselector)
documentation.

[![image](https://avatars0.githubusercontent.com/u/1406667?s=140)](/ajhino)

**[ajhino](/ajhino)** commented [June 30, 2014](#comment-1255114)

This is one of the best FRP breakdowns I've seen. Nice work!

[![image](https://avatars0.githubusercontent.com/u/90512?s=140)](/staltz)

Owner

**[staltz](/staltz)** commented [June 30, 2014](#comment-1255116)

Very good catch @queimadus! We were just bitten by the Cold vs Hot
Observable problem, that I hoped wouldn't show up in this demo, but it
did.

It happened because `responseStream` was a cold observable (observables
are cold by default), and it had 3 observers `suggestion1Stream`,
`suggestion2Stream`, and `suggestion3Stream`. Essentially, these 3
create their own internal response stream, and that's what causes the 3
API requests.

To fix it, we made `responseStream` become a hot observable:

    var responseStream = requestStream
        .flatMap(function (requestUrl) {
            return Rx.Observable.fromPromise($.getJSON(requestUrl));
        })
        .publish().refCount();

Fixed here:
[http://jsfiddle.net/staltz/8jFJH/59/](http://jsfiddle.net/staltz/8jFJH/59/)

As far as I've seen, this is the best example-based explanation of Cold
vs Hot:
[http://leecampbell.blogspot.co.uk/2010/08/rx-part-7-hot-and-cold-observables.html](http://leecampbell.blogspot.co.uk/2010/08/rx-part-7-hot-and-cold-observables.html)\
 Other good references:
[[1]](https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators)
[[2]](http://www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html)
[[3]](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md#cold-vs-hot-observables)

[![image](https://avatars1.githubusercontent.com/u/599112?s=140)](/aeikenberry)

**[aeikenberry](/aeikenberry)** commented [June 30,
2014](#comment-1255255)

Thanks for doing this! Very well done.

[![image](https://avatars2.githubusercontent.com/u/373675?s=140)](/tieTYT)

**[tieTYT](/tieTYT)** commented [July 01, 2014](#comment-1255313)

I'm really confused by the appearance of 'startup click'. Is that a
string with special meaning? I think you should explain that part
because you lost me there.

[![image](https://avatars2.githubusercontent.com/u/3714569?s=140)](/peterkhayes)

**[peterkhayes](/peterkhayes)** commented [July 01,
2014](#comment-1255347)

The 'startup click' is passed to a stream that takes the same action
regardless of what the input is, so it really could be anything.

    var requestStream = refreshClickStream.startWith('startup click')
      .map(function() {
        var randomOffset = Math.floor(Math.random()*500);
        return 'https://api.github.com/users?since=' + randomOffset;
      });

notice that the requestStream is mapped to the link to github, without
reference to any input. This is different from the usual use of `map`,
where the iterator function uses the input in some way, like
map(function(number) {return 2\*number}).

I guess he's using the phrase 'startup click' here to be more
descriptive. You have to pass something (or else the stream won't emit
anything), so why not use something that explains why you're doing it?

[![image](https://avatars0.githubusercontent.com/u/3486467?s=140)](/paulirotta)

**[paulirotta](/paulirotta)** commented [July 01,
2014](#comment-1255461)

Excellent, thanks!

[![image](https://avatars2.githubusercontent.com/u/1714401?s=140)](/prassu21)

**[prassu21](/prassu21)** commented [July 01, 2014](#comment-1255592)

Brilliant article.. Thanks for sharing..

[![image](https://avatars2.githubusercontent.com/u/3759836?s=140)](/ledbutter)

**[ledbutter](/ledbutter)** commented [July 01, 2014](#comment-1255826)

So I'll bite on the exercise to avoid copy/pasting for the different
suggestion streams, would that involve using the `repeat()` method?

[![image](https://avatars0.githubusercontent.com/u/90512?s=140)](/staltz)

Owner

**[staltz](/staltz)** commented [July 01, 2014](#comment-1255878)

Hi @ledbutter, actually `repeat()` doesn't help for that, and the DRY
problem is already solved in the JSFiddle:
[http://jsfiddle.net/staltz/8jFJH/48/](http://jsfiddle.net/staltz/8jFJH/48/)

    function createSuggestionStream(closeClickStream) {
        return closeClickStream.startWith('startup click')
            .combineLatest(responseStream,             
                function(click, listUsers) {
                    return listUsers[Math.floor(Math.random()*listUsers.length)];
                }
            )
            .merge(
                refreshClickStream.map(function(){ 
                    return null;
                })
            )
            .startWith(null);
    }

`repeat()` just "echoes" forward some events that happened in the past.
See
[[1]](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablerepeatvalue-repeatcount-scheduler)
[[2]](https://github.com/Netflix/RxJava/wiki/Creating-Observables#repeat)

[Sign up for free](https://github.com/signup?return_to=gist) **to join
this conversation on GitHub**. Already have an account? [Sign in to
comment](https://gist.github.com/login?return_to=%2Fstaltz%2F868e7e9bc2a7b8c1f754)

Something went wrong with that request. Please try again. [](#)

-   [Status](https://status.github.com/)
-   [API](http://developer.github.com)
-   [Blog](https://github.com/blog)
-   [About](https://github.com/about)

[](/)

-   © 2014 GitHub, Inc.
-   [Terms](https://github.com/site/terms)
-   [Privacy](https://github.com/site/privacy)
-   [Security](https://github.com/security)
-   [Contact](https://github.com/contact)

[](#) [](#)

This markdown document has been converted from the html document located at:
https://gist.github.com/staltz/868e7e9bc2a7b8c1f754
